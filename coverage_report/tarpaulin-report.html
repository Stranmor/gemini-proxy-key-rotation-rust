<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","app","src","admin.rs"],"content":"// src/admin.rs\n\nuse crate::{\n    config::{self, AppConfig},\n    error::{AppError, Result},\n    key_manager::{KeyState, KeyStatus as KmKeyStatus},\n    state::AppState,\n};\nuse axum::{\n    Router,\n    body::Body,\n    extract::{Path, Query, State},\n    http::{Request, StatusCode},\n    middleware::{self, Next},\n    response::{Html, IntoResponse, Json, Response},\n    routing::{delete, get, post, put},\n};\nuse chrono::{DateTime, Utc};\nuse cookie::{SameSite, time::Duration as CookieDuration};\nuse http::HeaderName;\n\n#[cfg(test)]\nuse http_body_util::BodyExt;\nuse rand::{Rng, distributions::Alphanumeric};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse sysinfo::{Disks, System};\nuse tokio::sync::Mutex;\nuse tower_cookies::{Cookie, Cookies};\nuse tracing::{error, info, warn};\n\n// --- Constants ---\n\n/// The name of the custom header for the CSRF token.\nstatic X_CSRF_TOKEN: HeaderName = HeaderName::from_static(\"x-csrf-token\");\n/// The name of the cookie storing the admin authentication token.\nconst ADMIN_TOKEN_COOKIE: \u0026str = \"admin_token\";\n/// The name of the cookie storing the CSRF token.\nconst CSRF_TOKEN_COOKIE: \u0026str = \"csrf_token\";\n\n// --- System Info Collector ---\n\n/// Collector for system information.\n///\n/// This struct holds a `System` instance and is designed to be updated by a background task.\n/// This avoids blocking request threads for expensive data collection like CPU usage.\n#[derive(Debug)]\npub struct SystemInfoCollector {\n    // We use a Mutex as sysinfo::System is not Sync.\n    system: Mutex\u003cSystem\u003e,\n}\n\nimpl SystemInfoCollector {\n    /// Creates a new `SystemInfoCollector` and performs an initial data refresh.\n    pub fn new() -\u003e Self {\n        let mut system = System::new_all();\n        system.refresh_all(); // Initial refresh\n        Self {\n            system: Mutex::new(system),\n        }\n    }\n\n    /// Spawns a background task to periodically refresh system data.\n    ///\n    /// This should be called once when the application starts.\n    pub fn spawn_background_refresh(self: Arc\u003cSelf\u003e, interval: std::time::Duration) {\n        tokio::spawn(async move {\n            let mut timer = tokio::time::interval(interval);\n            // The first tick completes immediately, so we skip it to wait for the first interval.\n            timer.tick().await;\n            loop {\n                timer.tick().await;\n                let mut sys = self.system.lock().await;\n                // Refresh only what we need to be more efficient.\n                (*sys).refresh_cpu_specifics(sysinfo::CpuRefreshKind::everything());\n                (*sys).refresh_memory();\n            }\n        });\n    }\n\n    /// Returns the current memory usage in MB. Reads recently refreshed data.\n    pub async fn get_memory_usage(\u0026self) -\u003e u64 {\n        let sys = self.system.lock().await;\n        sys.used_memory() / (1024 * 1024)\n    }\n\n    /// Returns the current global CPU usage percentage. Reads recently refreshed data.\n    pub async fn get_cpu_usage(\u0026self) -\u003e f64 {\n        let sys = self.system.lock().await;\n        let cpus = sys.cpus();\n        if cpus.is_empty() {\n            0.0\n        } else {\n            cpus.iter().map(|cpu| cpu.cpu_usage() as f64).sum::\u003cf64\u003e() / cpus.len() as f64\n        }\n    }\n\n    /// Returns the total memory in MB.\n    pub async fn get_total_memory(\u0026self) -\u003e u64 {\n        let sys = self.system.lock().await;\n        sys.total_memory() / (1024 * 1024)\n    }\n\n    /// Returns the total used disk space in MB. Reads recently refreshed data.\n    pub async fn get_disk_usage(\u0026self) -\u003e u64 {\n        let disks = Disks::new_with_refreshed_list();\n        disks\n            .iter()\n            .map(|disk| disk.total_space() - disk.available_space())\n            .sum::\u003cu64\u003e()\n            / (1024 * 1024)\n    }\n\n    /// Returns the OS information.\n    pub async fn get_os_info(\u0026self) -\u003e String {\n        System::long_os_version()\n            .or_else(System::os_version)\n            .unwrap_or_else(|| \"Unknown OS\".to_string())\n    }\n\n    /// Returns the number of CPUs.\n    pub async fn get_num_cpus(\u0026self) -\u003e usize {\n        let sys = self.system.lock().await;\n        sys.cpus().len()\n    }\n}\n\nimpl Default for SystemInfoCollector {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// --- Router Definition ---\n\n/// Defines all administrative API routes.\npub fn admin_routes() -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    // Routes that require admin authentication and CSRF protection\n    // Order of middleware matters: auth first, then CSRF.\n    let authed_routes = Router::new()\n        .route(\"/keys\", post(add_keys))\n        .route(\"/keys\", delete(delete_keys))\n        .route(\"/keys/:key_id/verify\", post(verify_key))\n        .route(\"/keys/:key_id/reset\", post(reset_key))\n        .route(\"/config\", put(update_config))\n        .route_layer(middleware::from_fn(csrf_middleware));\n\n    // Combine all admin routes under a common `/admin` prefix.\n    Router::new().nest(\n        \"/admin\",\n        Router::new()\n            .route(\"/\", get(serve_dashboard))\n            .route(\"/health\", get(detailed_health))\n            .route(\"/keys\", get(list_keys))\n            .route(\"/keys-page\", get(serve_keys_management_page))\n            .route(\"/config\", get(get_config))\n            .route(\"/metrics\", get(get_metrics_summary))\n            .route(\"/model-stats\", get(get_model_stats))\n            .route(\"/csrf-token\", get(get_csrf_token))\n            .route(\"/login\", post(login))\n            .merge(authed_routes),\n    )\n}\n\n// --- Request/Response Structs ---\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DetailedHealthStatus {\n    pub status: String,\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub version: String,\n    pub uptime_seconds: u64,\n    pub server_info: ServerInfo,\n    pub key_status: KeyStatus,\n    pub proxy_status: HashMap\u003cString, ProxyStatus\u003e,\n    pub system_info: SystemInfo,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ServerInfo {\n    pub host: String,\n    pub port: u16,\n    pub rust_version: String,\n    pub build_info: BuildInfo,\n    pub os_info: String,\n    pub num_cpus: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BuildInfo {\n    pub version: String,\n    pub git_hash: String,\n    pub build_date: String,\n    pub target: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct KeyStatus {\n    pub total_keys: usize,\n    pub active_keys: usize,\n    pub limited_keys: usize,\n    pub invalid_keys: usize,\n    pub temporarily_unavailable_keys: usize,\n    pub groups: Vec\u003cGroupStatus\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GroupStatus {\n    pub name: String,\n    pub total_keys: usize,\n    pub active_keys: usize,\n    pub proxy_url: Option\u003cString\u003e,\n    pub target_url: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ProxyStatus {\n    pub url: String,\n    pub status: String,\n    pub last_check: DateTime\u003cUtc\u003e,\n    pub groups_using: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SystemInfo {\n    pub memory_usage_mb: u64,\n    pub total_memory_mb: u64,\n    pub cpu_usage_percent: f64,\n    pub disk_usage_mb: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddKeysRequest {\n    pub group_name: String,\n    pub api_keys: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DeleteKeysRequest {\n    pub group_name: String,\n    pub api_keys: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ModelBlockInfo {\n    pub model: String,\n    pub blocked_until: DateTime\u003cUtc\u003e,\n    pub reason: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ModelStats {\n    pub model: String,\n    pub blocked_keys_count: usize,\n    pub next_reset_time: DateTime\u003cUtc\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ModelStatsResponse {\n    pub models: Vec\u003cModelStats\u003e,\n    pub total_keys: usize,\n    pub timestamp: DateTime\u003cUtc\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct KeyInfo {\n    pub id: String,\n    pub group_name: String,\n    pub key_preview: String,\n    pub status: String,\n    pub last_used: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub reset_time: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    pub model_blocks: Vec\u003cModelBlockInfo\u003e,\n}\n\nimpl KeyInfo {\n    /// Creates a new `KeyInfo` for API responses from internal key data.\n    fn new(\n        key_info: \u0026crate::key_manager::FlattenedKeyInfo,\n        key_state: Option\u003c\u0026KeyState\u003e,\n        now: DateTime\u003cUtc\u003e,\n    ) -\u003e Self {\n        let (status_str, reset_time) = get_key_status_str(key_state, now);\n        let key_preview = if key_info.key.len() \u003e 10 {\n            format!(\n                \"{}...{}\",\n                \u0026key_info.key[..6],\n                \u0026key_info.key[key_info.key.len() - 4..]\n            )\n        } else {\n            key_info.key.clone()\n        };\n\n        // Extract model blocks information\n        let model_blocks = key_state\n            .map(|ks| {\n                ks.model_blocks\n                    .iter()\n                    .filter(|(_, block_state)| now \u003c block_state.blocked_until)\n                    .map(|(model, block_state)| ModelBlockInfo {\n                        model: model.clone(),\n                        blocked_until: block_state.blocked_until,\n                        reason: block_state.reason.clone(),\n                    })\n                    .collect()\n            })\n            .unwrap_or_default();\n\n        Self {\n            id: format!(\"{:x}\", md5::compute(\u0026key_info.key)),\n            group_name: key_info.group_name.clone(),\n            key_preview,\n            status: status_str.to_string(),\n            last_used: None, // TODO: Track last usage time in KeyManager\n            reset_time,\n            model_blocks,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct ListKeysQuery {\n    pub group: Option\u003cString\u003e,\n    pub status: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginRequest {\n    // For production, consider using a secret-wrapper type to prevent accidental logging.\n    pub token: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CsrfTokenResponse {\n    pub csrf_token: String,\n}\n\n// --- Middleware ---\n\n/// Middleware for Cross-Site Request Forgery (CSRF) protection.\n///\n/// It expects a `csrf_token` in a cookie and a matching token in the `X-CSRF-Token` header.\nasync fn csrf_middleware(cookies: Cookies, req: Request\u003cBody\u003e, next: Next) -\u003e Result\u003cResponse\u003e {\n    let cookie_token = cookies\n        .get(CSRF_TOKEN_COOKIE)\n        .map(|cookie| cookie.value().to_string());\n\n    let header_token = req\n        .headers()\n        .get(\u0026X_CSRF_TOKEN)\n        .and_then(|value| value.to_str().ok())\n        .map(String::from);\n\n    match (cookie_token, header_token) {\n        (Some(c_token), Some(h_token)) if !c_token.is_empty() \u0026\u0026 c_token == h_token =\u003e {\n            info!(\"CSRF token matched.\");\n            Ok(next.run(req).await)\n        }\n        _ =\u003e {\n            warn!(\"CSRF token mismatch or missing. Access forbidden.\");\n            Err(AppError::Csrf)\n        }\n    }\n}\n\n// --- Route Handlers ---\n\n/// Provides a detailed health check of the application.\n#[axum::debug_handler]\npub async fn detailed_health(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e Result\u003cJson\u003cDetailedHealthStatus\u003e\u003e {\n    let key_manager_guard = state.key_manager.read().await;\n    let now = Utc::now();\n\n    let key_status = calculate_key_status_summary(\u0026key_manager_guard, now);\n    let proxy_status = HashMap::new(); // TODO: Implement proxy health checks.\n    let uptime = state.start_time.elapsed().as_secs();\n    let config_guard = state.config.read().await;\n\n    let health_status = DetailedHealthStatus {\n        status: \"healthy\".to_string(),\n        timestamp: now,\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        uptime_seconds: uptime,\n        server_info: ServerInfo {\n            host: \"0.0.0.0\".to_string(), // Host is no longer part of config\n            port: config_guard.server.port,\n            rust_version: option_env!(\"RUSTC_VERSION\").unwrap_or(\"N/A\").to_string(),\n            build_info: BuildInfo {\n                version: env!(\"CARGO_PKG_VERSION\").to_string(),\n                git_hash: option_env!(\"GIT_HASH\").unwrap_or(\"N/A\").to_string(),\n                build_date: option_env!(\"BUILD_DATE\").unwrap_or(\"N/A\").to_string(),\n                target: option_env!(\"TARGET\").unwrap_or(\"N/A\").to_string(),\n            },\n            os_info: state.system_info.get_os_info().await,\n            num_cpus: state.system_info.get_num_cpus().await,\n        },\n        key_status,\n        proxy_status,\n        system_info: SystemInfo {\n            memory_usage_mb: state.system_info.get_memory_usage().await,\n            total_memory_mb: state.system_info.get_total_memory().await,\n            cpu_usage_percent: state.system_info.get_cpu_usage().await,\n            disk_usage_mb: state.system_info.get_disk_usage().await,\n        },\n    };\n\n    Ok(Json(health_status))\n}\n\n/// Lists API keys with optional filtering by group and status.\n#[axum::debug_handler]\npub async fn list_keys(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Query(query): Query\u003cListKeysQuery\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cKeyInfo\u003e\u003e\u003e {\n    let key_manager_guard = state.key_manager.read().await;\n    let key_states = key_manager_guard.get_key_states();\n    let all_key_info = key_manager_guard.get_all_key_info();\n    let now = Utc::now();\n\n    let keys = all_key_info\n        .iter()\n        .filter(|key_info| {\n            query\n                .group\n                .as_ref()\n                .is_none_or(|g| g == \u0026key_info.group_name)\n        })\n        .filter_map(|key_info| {\n            let key_state = key_states.get(\u0026key_info.key);\n            let api_key_info = KeyInfo::new(key_info, key_state, now);\n            if query\n                .status\n                .as_ref()\n                .is_none_or(|s| s == \u0026api_key_info.status)\n            {\n                Some(api_key_info)\n            } else {\n                None\n            }\n        })\n        .collect();\n\n    Ok(Json(keys))\n}\n\n/// Verifies a single API key by making a test request to its target service.\n#[axum::debug_handler]\npub async fn verify_key(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(key_id): Path\u003cString\u003e,\n) -\u003e Result\u003cStatusCode\u003e {\n    let mut key_manager_guard = state.key_manager.write().await;\n\n    let (key_to_verify, proxy_url, target_url) = match key_manager_guard.get_key_info_by_id(\u0026key_id)\n    {\n        Some(info) =\u003e (\n            info.key.clone(),\n            info.proxy_url.clone(),\n            info.target_url.clone(),\n        ),\n        None =\u003e {\n            warn!(\"Verification failed: Key with ID '{}' not found.\", key_id);\n            return Err(AppError::NotFound(format!(\n                \"Key with ID '{key_id}' not found\"\n            )));\n        }\n    };\n\n    info!(\n        \"Attempting to verify key with ID '{}' for target '{}'.\",\n        key_id, target_url\n    );\n\n    let client = state.get_client(proxy_url.as_deref()).await?;\n    let verification_result = key_manager_guard\n        .perform_key_verification(\u0026key_to_verify, \u0026target_url, \u0026client)\n        .await;\n\n    if key_manager_guard.update_key_status_from_verification(\u0026key_to_verify, verification_result) {\n        info!(\n            \"Key with ID '{}' status updated after verification.\",\n            key_id\n        );\n        key_manager_guard.save_states().await?;\n    } else {\n        info!(\n            \"Key with ID '{}' status did not change after verification.\",\n            key_id\n        );\n    }\n\n    Ok(StatusCode::OK)\n}\n\n/// Resets the status of a single API key to 'Available'.\n#[axum::debug_handler]\npub async fn reset_key(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(key_id): Path\u003cString\u003e,\n) -\u003e Result\u003cStatusCode\u003e {\n    let mut key_manager_guard = state.key_manager.write().await;\n    if key_manager_guard.reset_key_status(\u0026key_id) {\n        info!(\"Key with ID '{}' status reset to available.\", key_id);\n        key_manager_guard.save_states().await?;\n        Ok(StatusCode::OK)\n    } else {\n        warn!(\n            \"Attempted to reset key with ID '{}' but it was not found.\",\n            key_id\n        );\n        Err(AppError::NotFound(format!(\n            \"Key with ID '{key_id}' not found\"\n        )))\n    }\n}\n\n/// Returns the current application configuration.\n#[axum::debug_handler]\npub async fn get_config(State(state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e Result\u003cJson\u003cAppConfig\u003e\u003e {\n    let config = state.config.read().await;\n    Ok(Json(config.clone()))\n}\n\n/// Updates the entire configuration and reloads the application state.\n#[axum::debug_handler]\npub async fn update_config(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(new_config): Json\u003cAppConfig\u003e,\n) -\u003e Result\u003cStatusCode\u003e {\n    info!(\"Attempting to update application configuration.\");\n    modify_config_and_reload(\u0026state, \"admin_update\", new_config, |_| Ok(())).await?;\n    info!(\"Application configuration updated successfully.\");\n    Ok(StatusCode::OK)\n}\n\n/// Adds new API keys to a specified group, avoiding duplicates.\n#[axum::debug_handler]\npub async fn add_keys(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(request): Json\u003cAddKeysRequest\u003e,\n) -\u003e Result\u003cStatusCode\u003e {\n    info!(\"Attempting to add keys to group '{}'.\", request.group_name);\n    let config_base = state.config.read().await.clone();\n    modify_config_and_reload(\u0026state, \"admin_add_keys\", config_base, |config| {\n        let group = config\n            .groups\n            .iter_mut()\n            .find(|g| g.name == request.group_name)\n            .ok_or_else(|| {\n                warn!(\n                    \"Failed to add keys: Group '{}' not found.\",\n                    request.group_name\n                );\n                AppError::NotFound(format!(\"Group '{}' not found\", request.group_name))\n            })?;\n\n        let mut added_count = 0;\n        for key in request.api_keys {\n            let trimmed_key = key.trim();\n            if !trimmed_key.is_empty() \u0026\u0026 !group.api_keys.iter().any(|k| k == trimmed_key) {\n                group.api_keys.push(trimmed_key.to_string());\n                added_count += 1;\n            }\n        }\n        info!(\n            \"Added {} new keys to group '{}'.\",\n            added_count, request.group_name\n        );\n        Ok(())\n    })\n    .await?;\n    Ok(StatusCode::OK)\n}\n\n/// Removes specified API keys from a group.\n#[axum::debug_handler]\npub async fn delete_keys(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Json(request): Json\u003cDeleteKeysRequest\u003e,\n) -\u003e Result\u003cStatusCode\u003e {\n    info!(\n        \"Attempting to delete keys from group '{}'.\",\n        request.group_name\n    );\n    let config_base = state.config.read().await.clone();\n    modify_config_and_reload(\u0026state, \"admin_delete_keys\", config_base, |config| {\n        let group = config\n            .groups\n            .iter_mut()\n            .find(|g| g.name == request.group_name)\n            .ok_or_else(|| {\n                warn!(\n                    \"Failed to delete keys: Group '{}' not found.\",\n                    request.group_name\n                );\n                AppError::NotFound(format!(\"Group '{}' not found\", request.group_name))\n            })?;\n\n        let keys_to_delete: HashSet\u003c_\u003e = request.api_keys.iter().map(String::as_str).collect();\n        let initial_count = group.api_keys.len();\n        group\n            .api_keys\n            .retain(|k| !keys_to_delete.contains(k.as_str()));\n        let deleted_count = initial_count - group.api_keys.len();\n        info!(\n            \"Deleted {} keys from group '{}'.\",\n            deleted_count, request.group_name\n        );\n        Ok(())\n    })\n    .await?;\n    Ok(StatusCode::OK)\n}\n\n/// Provides a summary of application metrics (placeholder).\n#[axum::debug_handler]\npub async fn get_metrics_summary(\n    State(_state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e Result\u003cJson\u003cserde_json::Value\u003e\u003e {\n    info!(\"Metrics summary requested. (Placeholder)\");\n    Ok(Json(serde_json::json!({\n        \"message\": \"Metrics collection not yet implemented.\",\n        \"note\": \"This endpoint will provide detailed application metrics in the future.\"\n    })))\n}\n\n/// Provides statistics about model-specific key blocking.\n#[axum::debug_handler]\npub async fn get_model_stats(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n) -\u003e Result\u003cJson\u003cModelStatsResponse\u003e\u003e {\n    info!(\"Model statistics requested.\");\n\n    let key_manager_guard = state.key_manager.read().await;\n    let blocked_models_info = key_manager_guard.get_blocked_models_info();\n    let total_keys = key_manager_guard.get_all_key_info().len();\n\n    let models = blocked_models_info\n        .into_iter()\n        .map(|(model, blocked_count, next_reset_time)| ModelStats {\n            model,\n            blocked_keys_count: blocked_count,\n            next_reset_time,\n        })\n        .collect();\n\n    Ok(Json(ModelStatsResponse {\n        models,\n        total_keys,\n        timestamp: Utc::now(),\n    }))\n}\n\n/// Handles admin login by setting a secure, HttpOnly cookie with the admin token.\n#[axum::debug_handler]\npub async fn login(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    jar: Cookies,\n    Json(request): Json\u003cLoginRequest\u003e,\n) -\u003e Result\u003cimpl IntoResponse\u003e {\n    let config = state.config.read().await;\n    let expected_token = config.server.admin_token.as_deref();\n\n    match expected_token {\n        Some(token) if !token.is_empty() \u0026\u0026 request.token == token =\u003e {\n            let cookie = Cookie::build((ADMIN_TOKEN_COOKIE, token.to_string()))\n                .path(\"/\")\n                .http_only(true)\n                .secure(true)\n                .same_site(SameSite::Strict)\n                .max_age(CookieDuration::days(7))\n                .build();\n            info!(\"Admin login successful.\");\n            Ok((jar.add(cookie), StatusCode::OK))\n        }\n        _ =\u003e {\n            warn!(\"Failed admin login attempt: Invalid token or no token configured.\");\n            Err(AppError::Unauthorized)\n        }\n    }\n}\n\n/// Generates a CSRF token, sets it as a cookie, and returns it in the response body.\n#[axum::debug_handler]\npub async fn get_csrf_token(jar: Cookies) -\u003e Result\u003cimpl IntoResponse\u003e {\n    let token: String = rand::thread_rng()\n        .sample_iter(\u0026Alphanumeric)\n        .take(32)\n        .map(char::from)\n        .collect();\n\n    let cookie = Cookie::build((CSRF_TOKEN_COOKIE, token.clone()))\n        .path(\"/\")\n        .secure(true)\n        .same_site(SameSite::Strict)\n        // This cookie should be readable by JS, so it must NOT be HttpOnly.\n        // It is session-based for stricter security (no max_age).\n        .build();\n\n    info!(\"Generated new CSRF token.\");\n    Ok((\n        jar.add(cookie),\n        Json(CsrfTokenResponse { csrf_token: token }),\n    ))\n}\n\n// --- HTML Serving Handlers ---\n\n/// Serves the main admin dashboard HTML page.\n#[axum::debug_handler]\npub async fn serve_dashboard() -\u003e Html\u003cString\u003e {\n    Html(include_str!(\"../static/dashboard.html\").to_string())\n}\n\n/// Serves the key management HTML page.\n#[axum::debug_handler]\npub async fn serve_keys_management_page() -\u003e Html\u003cString\u003e {\n    Html(include_str!(\"../static/keys_management.html\").to_string())\n}\n\n// --- Helper Functions ---\n\n/// Atomically modifies, validates, saves, and reloads the application configuration.\nasync fn modify_config_and_reload\u003cF\u003e(\n    state: \u0026Arc\u003cAppState\u003e,\n    source: \u0026str,\n    mut config: AppConfig,\n    modification: F,\n) -\u003e Result\u003c()\u003e\nwhere\n    F: FnOnce(\u0026mut AppConfig) -\u003e Result\u003c()\u003e,\n{\n    modification(\u0026mut config)?;\n\n    if !config::validate_config(\u0026mut config, source) {\n        let msg =\n            format!(\"Validation failed for new configuration from '{source}'; changes not saved.\");\n        error!(\"{}\", msg);\n        return Err(AppError::Config(msg));\n    }\n\n    config::save_config(\u0026config, \u0026state.config_path).await?;\n    info!(\"Configuration saved to disk from '{}'.\", source);\n\n    // Atomically swap the in-memory config and reload state.\n    *state.config.write().await = config;\n    state.reload_state_from_config().await?;\n    info!(\n        \"Application state reloaded successfully after config update from '{}'.\",\n        source\n    );\n\n    Ok(())\n}\n\n/// Calculates a summary of key statuses and group information.\nfn calculate_key_status_summary(\n    key_manager_guard: \u0026tokio::sync::RwLockReadGuard\u003ccrate::key_manager::KeyManager\u003e,\n    now: DateTime\u003cUtc\u003e,\n) -\u003e KeyStatus {\n    let all_key_info = key_manager_guard.get_all_key_info();\n    let key_states = key_manager_guard.get_key_states();\n\n    let mut summary = KeyStatus {\n        total_keys: all_key_info.len(),\n        active_keys: 0,\n        limited_keys: 0,\n        invalid_keys: 0,\n        temporarily_unavailable_keys: 0,\n        groups: Vec::new(),\n    };\n\n    let mut groups_map: HashMap\u003cString, GroupStatus\u003e = HashMap::new();\n\n    for key_info in \u0026all_key_info {\n        let (status_str, _) = get_key_status_str(key_states.get(\u0026key_info.key), now);\n        match status_str {\n            \"available\" =\u003e summary.active_keys += 1,\n            \"limited\" =\u003e summary.limited_keys += 1,\n            \"invalid\" =\u003e summary.invalid_keys += 1,\n            \"unavailable\" =\u003e summary.temporarily_unavailable_keys += 1,\n            _ =\u003e warn!(\n                \"Unknown key status '{}' for key in group '{}'.\",\n                status_str, key_info.group_name\n            ),\n        }\n\n        let entry = groups_map\n            .entry(key_info.group_name.clone())\n            .or_insert_with(|| GroupStatus {\n                name: key_info.group_name.clone(),\n                total_keys: 0,\n                active_keys: 0,\n                proxy_url: key_info.proxy_url.clone(),\n                target_url: key_info.target_url.clone(),\n            });\n        entry.total_keys += 1;\n        if status_str == \"available\" {\n            entry.active_keys += 1;\n        }\n    }\n\n    summary.groups = groups_map.into_values().collect();\n    summary\n}\n\n/// Returns a string representation of the key's status and its potential reset time.\nfn get_key_status_str(\n    key_state: Option\u003c\u0026KeyState\u003e,\n    now: DateTime\u003cUtc\u003e,\n) -\u003e (\u0026'static str, Option\u003cDateTime\u003cUtc\u003e\u003e) {\n    match key_state {\n        Some(state) =\u003e {\n            let is_expired = state.reset_time.is_some_and(|rt| now \u003e= rt);\n            let status = match state.status {\n                KmKeyStatus::Available =\u003e \"available\",\n                KmKeyStatus::RateLimited if is_expired =\u003e \"available\",\n                KmKeyStatus::RateLimited =\u003e \"limited\",\n                KmKeyStatus::Invalid =\u003e \"invalid\",\n                KmKeyStatus::TemporarilyUnavailable if is_expired =\u003e \"available\",\n                KmKeyStatus::TemporarilyUnavailable =\u003e \"unavailable\",\n            };\n            (status, state.reset_time)\n        }\n        None =\u003e (\"available\", None), // Default to 'available' if no state is recorded yet.\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{KeyGroup as GroupConfig, ServerConfig};\n    use crate::key_manager::{KeyState, KeyStatus as KmKeyStatus};\n    use axum::{\n        Router,\n        body::Body,\n        http::{Request, StatusCode, header},\n        routing::post,\n    };\n    use chrono::Duration;\n    use std::sync::Arc;\n    use tempfile::TempDir;\n    use tower::util::ServiceExt;\n    use tower_cookies::CookieManagerLayer;\n\n    // --- Test Setup ---\n\n    async fn setup_state(admin_token: Option\u003cString\u003e) -\u003e (Arc\u003cAppState\u003e, TempDir) {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let config_path = temp_dir.path().join(\"config.toml\");\n        let config = AppConfig {\n            server: ServerConfig {\n                admin_token,\n                port: 8080,\n                ..Default::default()\n            },\n            groups: vec![\n                GroupConfig {\n                    name: \"test_group\".to_string(),\n                    target_url: \"http://example.com\".to_string(),\n                    api_keys: vec![\"key1\".to_string(), \"key2\".to_string()],\n                    ..Default::default()\n                },\n                GroupConfig {\n                    name: \"another_group\".to_string(),\n                    target_url: \"http://another.com\".to_string(),\n                    api_keys: vec![\"key3\".to_string()],\n                    ..Default::default()\n                },\n            ],\n            ..Default::default()\n        };\n        config::save_config(\u0026config, \u0026config_path).await.unwrap();\n\n        let app_state = Arc::new(AppState::new(\u0026config, \u0026config_path).await.unwrap());\n        (app_state, temp_dir)\n    }\n\n    /// Creates a test app with the CSRF middleware applied.\n    fn csrf_app() -\u003e Router {\n        Router::new()\n            .route(\"/\", post(|| async { StatusCode::OK }))\n            .route_layer(middleware::from_fn(csrf_middleware))\n            .layer(CookieManagerLayer::new())\n    }\n\n    // --- Unit Tests ---\n\n    #[test]\n    fn test_get_key_status_str() {\n        let now = Utc::now();\n        let past = now - Duration::seconds(10);\n        let future = now + Duration::seconds(10);\n\n        assert_eq!(get_key_status_str(None, now), (\"available\", None));\n\n        let state_available = KeyState {\n            status: KmKeyStatus::Available,\n            reset_time: None,\n            model_blocks: HashMap::new(),\n        };\n        assert_eq!(\n            get_key_status_str(Some(\u0026state_available), now),\n            (\"available\", None)\n        );\n\n        let state_limited_pending = KeyState {\n            status: KmKeyStatus::RateLimited,\n            reset_time: Some(future),\n            model_blocks: HashMap::new(),\n        };\n        assert_eq!(\n            get_key_status_str(Some(\u0026state_limited_pending), now),\n            (\"limited\", Some(future))\n        );\n\n        let state_limited_expired = KeyState {\n            status: KmKeyStatus::RateLimited,\n            reset_time: Some(past),\n            model_blocks: HashMap::new(),\n        };\n        assert_eq!(\n            get_key_status_str(Some(\u0026state_limited_expired), now),\n            (\"available\", Some(past))\n        );\n\n        let state_invalid = KeyState {\n            status: KmKeyStatus::Invalid,\n            reset_time: None,\n            model_blocks: HashMap::new(),\n        };\n        assert_eq!(\n            get_key_status_str(Some(\u0026state_invalid), now),\n            (\"invalid\", None)\n        );\n\n        let state_unavailable_pending = KeyState {\n            status: KmKeyStatus::TemporarilyUnavailable,\n            reset_time: Some(future),\n            model_blocks: HashMap::new(),\n        };\n        assert_eq!(\n            get_key_status_str(Some(\u0026state_unavailable_pending), now),\n            (\"unavailable\", Some(future))\n        );\n\n        let state_unavailable_expired = KeyState {\n            status: KmKeyStatus::TemporarilyUnavailable,\n            reset_time: Some(past),\n            model_blocks: HashMap::new(),\n        };\n        assert_eq!(\n            get_key_status_str(Some(\u0026state_unavailable_expired), now),\n            (\"available\", Some(past))\n        );\n    }\n\n    // --- Middleware Tests ---\n    // --- Middleware Tests ---\n\n    #[tokio::test]\n    async fn test_csrf_middleware_success() {\n        let app = csrf_app();\n        let token = \"correct_csrf_token\";\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/\")\n                    .header(header::COOKIE, format!(\"{CSRF_TOKEN_COOKIE}={token}\"))\n                    .header(\u0026X_CSRF_TOKEN, token)\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[tokio::test]\n    async fn test_csrf_middleware_no_header() {\n        let app = csrf_app();\n        let token = \"correct_csrf_token\";\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/\")\n                    .header(header::COOKIE, format!(\"{CSRF_TOKEN_COOKIE}={token}\"))\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::FORBIDDEN);\n    }\n\n    #[tokio::test]\n    async fn test_csrf_middleware_no_cookie() {\n        let app = csrf_app();\n        let token = \"correct_csrf_token\";\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/\")\n                    .header(\u0026X_CSRF_TOKEN, token)\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::FORBIDDEN);\n    }\n\n    #[tokio::test]\n    async fn test_csrf_middleware_mismatch() {\n        let app = csrf_app();\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/\")\n                    .header(\n                        header::COOKIE,\n                        format!(\"{CSRF_TOKEN_COOKIE}=token_in_cookie\"),\n                    )\n                    .header(\u0026X_CSRF_TOKEN, \"token_in_header\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::FORBIDDEN);\n    }\n\n    #[tokio::test]\n    async fn test_csrf_middleware_empty_tokens() {\n        let app = csrf_app();\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/\")\n                    .header(header::COOKIE, format!(\"{CSRF_TOKEN_COOKIE}=\"))\n                    .header(\u0026X_CSRF_TOKEN, \"\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::FORBIDDEN);\n    }\n\n    // --- Route Handler Tests ---\n\n    #[tokio::test]\n    async fn test_get_csrf_token() {\n        let (state, _temp_dir) = setup_state(None).await;\n        let app = admin_routes()\n            .layer(CookieManagerLayer::new())\n            .with_state(state);\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .uri(\"/admin/csrf-token\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n\n        let cookie_header = response\n            .headers()\n            .get(header::SET_COOKIE)\n            .unwrap()\n            .to_str()\n            .unwrap();\n        assert!(cookie_header.contains(CSRF_TOKEN_COOKIE));\n        // CSRF cookie must be readable by client-side JS, so it should NOT be HttpOnly.\n        assert!(!cookie_header.contains(\"HttpOnly\"));\n        assert!(cookie_header.contains(\"Secure\"));\n        assert!(cookie_header.contains(\"SameSite=Strict\"));\n\n        let body_bytes = response.into_body().collect().await.unwrap().to_bytes();\n        let csrf_response: CsrfTokenResponse = serde_json::from_slice(\u0026body_bytes).unwrap();\n        assert!(!csrf_response.csrf_token.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_login_success() {\n        let admin_token = \"test_admin_token\".to_string();\n        let (state, _temp_dir) = setup_state(Some(admin_token.clone())).await;\n        let app = admin_routes()\n            .layer(CookieManagerLayer::new())\n            .with_state(state);\n\n        let login_request = LoginRequest { token: admin_token };\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/admin/login\")\n                    .header(header::CONTENT_TYPE, \"application/json\")\n                    .body(Body::from(serde_json::to_vec(\u0026login_request).unwrap()))\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n        let cookie_header = response\n            .headers()\n            .get(header::SET_COOKIE)\n            .unwrap()\n            .to_str()\n            .unwrap();\n        assert!(cookie_header.contains(ADMIN_TOKEN_COOKIE));\n        assert!(cookie_header.contains(\"HttpOnly\"));\n        assert!(cookie_header.contains(\"Secure\"));\n        assert!(cookie_header.contains(\"SameSite=Strict\"));\n    }\n\n    #[tokio::test]\n    async fn test_login_failure() {\n        let admin_token = \"test_admin_token\".to_string();\n        let (state, _temp_dir) = setup_state(Some(admin_token.clone())).await;\n        let app = admin_routes()\n            .layer(CookieManagerLayer::new())\n            .with_state(state);\n\n        let login_request = LoginRequest {\n            token: \"wrong_token\".to_string(),\n        };\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/admin/login\")\n                    .header(header::CONTENT_TYPE, \"application/json\")\n                    .body(Body::from(serde_json::to_vec(\u0026login_request).unwrap()))\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);\n        assert!(response.headers().get(header::SET_COOKIE).is_none());\n    }\n\n    #[tokio::test]\n    async fn test_add_keys_success() {\n        let admin_token = \"test_admin_token\".to_string();\n        let (state, _temp_dir) = setup_state(Some(admin_token.clone())).await;\n        let app = admin_routes()\n            .layer(CookieManagerLayer::new())\n            .with_state(state.clone());\n\n        let add_request = AddKeysRequest {\n            group_name: \"test_group\".to_string(),\n            api_keys: vec![\"new_key_1\".to_string(), \"new_key_2\".to_string()],\n        };\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/admin/keys\")\n                    .header(header::AUTHORIZATION, format!(\"Bearer {admin_token}\"))\n                    .header(\u0026X_CSRF_TOKEN, \"dummy_csrf_token\")\n                    .header(\n                        header::COOKIE,\n                        format!(\"{CSRF_TOKEN_COOKIE}=dummy_csrf_token\"),\n                    )\n                    .header(header::CONTENT_TYPE, \"application/json\")\n                    .body(Body::from(serde_json::to_vec(\u0026add_request).unwrap()))\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n\n        let config_guard = state.config.read().await;\n        let group = config_guard\n            .groups\n            .iter()\n            .find(|g| g.name == \"test_group\")\n            .unwrap();\n        assert!(group.api_keys.contains(\u0026\"new_key_1\".to_string()));\n        assert!(group.api_keys.contains(\u0026\"new_key_2\".to_string()));\n        assert_eq!(group.api_keys.len(), 4);\n    }\n\n    #[tokio::test]\n    async fn test_delete_keys_success() {\n        let admin_token = \"test_admin_token\".to_string();\n        let (state, _temp_dir) = setup_state(Some(admin_token.clone())).await;\n        let app = admin_routes()\n            .layer(CookieManagerLayer::new())\n            .with_state(state.clone());\n\n        let delete_request = DeleteKeysRequest {\n            group_name: \"test_group\".to_string(),\n            api_keys: vec![\"key1\".to_string()],\n        };\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"DELETE\")\n                    .uri(\"/admin/keys\")\n                    .header(header::AUTHORIZATION, format!(\"Bearer {admin_token}\"))\n                    .header(\u0026X_CSRF_TOKEN, \"dummy_csrf_token\")\n                    .header(\n                        header::COOKIE,\n                        format!(\"{CSRF_TOKEN_COOKIE}=dummy_csrf_token\"),\n                    )\n                    .header(header::CONTENT_TYPE, \"application/json\")\n                    .body(Body::from(serde_json::to_vec(\u0026delete_request).unwrap()))\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n\n        let config_guard = state.config.read().await;\n        let group = config_guard\n            .groups\n            .iter()\n            .find(|g| g.name == \"test_group\")\n            .unwrap();\n        assert!(!group.api_keys.contains(\u0026\"key1\".to_string()));\n        assert_eq!(group.api_keys.len(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_list_keys() {\n        let (state, _temp_dir) = setup_state(None).await;\n        let app = admin_routes().with_state(state.clone());\n\n        {\n            let mut key_manager_guard = state.key_manager.write().await;\n            key_manager_guard.reset_key_state_to_available(\"key1\");\n            key_manager_guard.mark_key_as_limited(\"key2\");\n            key_manager_guard.mark_key_as_invalid(\"key3\");\n        }\n\n        // Test without filters\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .uri(\"/admin/keys\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n        let body_bytes = response.into_body().collect().await.unwrap().to_bytes();\n        let keys: Vec\u003cKeyInfo\u003e = serde_json::from_slice(\u0026body_bytes).unwrap();\n        assert_eq!(keys.len(), 3);\n\n        // Test with group filter\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .uri(\"/admin/keys?group=test_group\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n        let body_bytes = response.into_body().collect().await.unwrap().to_bytes();\n        let keys: Vec\u003cKeyInfo\u003e = serde_json::from_slice(\u0026body_bytes).unwrap();\n        assert_eq!(keys.len(), 2);\n        assert!(keys.iter().all(|k| k.group_name == \"test_group\"));\n\n        // Test with status filter\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .uri(\"/admin/keys?status=limited\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n        let body_bytes = response.into_body().collect().await.unwrap().to_bytes();\n        let keys: Vec\u003cKeyInfo\u003e = serde_json::from_slice(\u0026body_bytes).unwrap();\n        assert_eq!(keys.len(), 1);\n        assert_eq!(keys[0].status, \"limited\");\n    }\n\n    #[tokio::test]\n    async fn test_detailed_health() {\n        let (state, _temp_dir) = setup_state(None).await;\n        let app = admin_routes().with_state(state.clone());\n\n        let response = app\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .uri(\"/admin/health\")\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n        let body_bytes = response.into_body().collect().await.unwrap().to_bytes();\n        let health: DetailedHealthStatus = serde_json::from_slice(\u0026body_bytes).unwrap();\n\n        assert_eq!(health.status, \"healthy\");\n        assert_eq!(health.version, env!(\"CARGO_PKG_VERSION\"));\n        // uptime_seconds is u64, so it's always \u003e= 0. This check is redundant but kept for clarity.\n        assert_eq!(health.server_info.port, 8080);\n        assert_eq!(health.server_info.host, \"0.0.0.0\");\n        assert!(!health.server_info.rust_version.is_empty());\n        assert!(!health.server_info.os_info.is_empty());\n        assert!(health.server_info.num_cpus \u003e 0);\n\n        assert_eq!(health.key_status.total_keys, 3);\n        assert_eq!(health.key_status.active_keys, 3);\n        assert_eq!(health.key_status.groups.len(), 2);\n\n        assert!(health.system_info.memory_usage_mb \u003e 0);\n        assert!(health.system_info.total_memory_mb \u003e 0);\n        assert!(health.system_info.cpu_usage_percent \u003e= 0.0);\n    }\n}\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":60}},{"line":57,"address":[],"length":0,"stats":{"Line":120}},{"line":58,"address":[],"length":0,"stats":{"Line":120}},{"line":60,"address":[],"length":0,"stats":{"Line":60}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":75}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":27}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":9}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":27}},{"line":141,"address":[],"length":0,"stats":{"Line":54}},{"line":142,"address":[],"length":0,"stats":{"Line":81}},{"line":143,"address":[],"length":0,"stats":{"Line":81}},{"line":144,"address":[],"length":0,"stats":{"Line":81}},{"line":145,"address":[],"length":0,"stats":{"Line":81}},{"line":146,"address":[],"length":0,"stats":{"Line":81}},{"line":147,"address":[],"length":0,"stats":{"Line":54}},{"line":150,"address":[],"length":0,"stats":{"Line":54}},{"line":152,"address":[],"length":0,"stats":{"Line":27}},{"line":153,"address":[],"length":0,"stats":{"Line":81}},{"line":154,"address":[],"length":0,"stats":{"Line":81}},{"line":155,"address":[],"length":0,"stats":{"Line":81}},{"line":156,"address":[],"length":0,"stats":{"Line":81}},{"line":157,"address":[],"length":0,"stats":{"Line":81}},{"line":158,"address":[],"length":0,"stats":{"Line":81}},{"line":159,"address":[],"length":0,"stats":{"Line":81}},{"line":160,"address":[],"length":0,"stats":{"Line":81}},{"line":161,"address":[],"length":0,"stats":{"Line":81}},{"line":162,"address":[],"length":0,"stats":{"Line":54}},{"line":279,"address":[],"length":0,"stats":{"Line":12}},{"line":284,"address":[],"length":0,"stats":{"Line":48}},{"line":285,"address":[],"length":0,"stats":{"Line":24}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":12}},{"line":296,"address":[],"length":0,"stats":{"Line":24}},{"line":297,"address":[],"length":0,"stats":{"Line":24}},{"line":298,"address":[],"length":0,"stats":{"Line":12}},{"line":299,"address":[],"length":0,"stats":{"Line":12}},{"line":300,"address":[],"length":0,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":12}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":12}},{"line":311,"address":[],"length":0,"stats":{"Line":60}},{"line":312,"address":[],"length":0,"stats":{"Line":36}},{"line":314,"address":[],"length":0,"stats":{"Line":36}},{"line":344,"address":[],"length":0,"stats":{"Line":46}},{"line":345,"address":[],"length":0,"stats":{"Line":46}},{"line":346,"address":[],"length":0,"stats":{"Line":46}},{"line":347,"address":[],"length":0,"stats":{"Line":59}},{"line":349,"address":[],"length":0,"stats":{"Line":46}},{"line":351,"address":[],"length":0,"stats":{"Line":46}},{"line":352,"address":[],"length":0,"stats":{"Line":77}},{"line":353,"address":[],"length":0,"stats":{"Line":23}},{"line":355,"address":[],"length":0,"stats":{"Line":46}},{"line":356,"address":[],"length":0,"stats":{"Line":78}},{"line":357,"address":[],"length":0,"stats":{"Line":15}},{"line":358,"address":[],"length":0,"stats":{"Line":45}},{"line":361,"address":[],"length":0,"stats":{"Line":8}},{"line":371,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":6}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":377,"address":[],"length":0,"stats":{"Line":12}},{"line":378,"address":[],"length":0,"stats":{"Line":6}},{"line":379,"address":[],"length":0,"stats":{"Line":9}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":383,"address":[],"length":0,"stats":{"Line":6}},{"line":385,"address":[],"length":0,"stats":{"Line":6}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":7}},{"line":419,"address":[],"length":0,"stats":{"Line":14}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":13}},{"line":427,"address":[],"length":0,"stats":{"Line":13}},{"line":428,"address":[],"length":0,"stats":{"Line":13}},{"line":429,"address":[],"length":0,"stats":{"Line":13}},{"line":430,"address":[],"length":0,"stats":{"Line":19}},{"line":432,"address":[],"length":0,"stats":{"Line":12}},{"line":433,"address":[],"length":0,"stats":{"Line":48}},{"line":434,"address":[],"length":0,"stats":{"Line":60}},{"line":435,"address":[],"length":0,"stats":{"Line":12}},{"line":436,"address":[],"length":0,"stats":{"Line":12}},{"line":437,"address":[],"length":0,"stats":{"Line":12}},{"line":438,"address":[],"length":0,"stats":{"Line":18}},{"line":440,"address":[],"length":0,"stats":{"Line":10}},{"line":442,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":4}},{"line":456,"address":[],"length":0,"stats":{"Line":8}},{"line":458,"address":[],"length":0,"stats":{"Line":20}},{"line":460,"address":[],"length":0,"stats":{"Line":8}},{"line":461,"address":[],"length":0,"stats":{"Line":12}},{"line":462,"address":[],"length":0,"stats":{"Line":12}},{"line":463,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":4}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":16}},{"line":479,"address":[],"length":0,"stats":{"Line":4}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":12}},{"line":484,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":4}},{"line":501,"address":[],"length":0,"stats":{"Line":2}},{"line":505,"address":[],"length":0,"stats":{"Line":4}},{"line":506,"address":[],"length":0,"stats":{"Line":4}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":508,"address":[],"length":0,"stats":{"Line":2}},{"line":509,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":16}},{"line":524,"address":[],"length":0,"stats":{"Line":16}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":2}},{"line":535,"address":[],"length":0,"stats":{"Line":12}},{"line":536,"address":[],"length":0,"stats":{"Line":2}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":3}},{"line":546,"address":[],"length":0,"stats":{"Line":3}},{"line":547,"address":[],"length":0,"stats":{"Line":12}},{"line":548,"address":[],"length":0,"stats":{"Line":15}},{"line":549,"address":[],"length":0,"stats":{"Line":6}},{"line":550,"address":[],"length":0,"stats":{"Line":3}},{"line":551,"address":[],"length":0,"stats":{"Line":3}},{"line":552,"address":[],"length":0,"stats":{"Line":9}},{"line":553,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":15}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":34}},{"line":565,"address":[],"length":0,"stats":{"Line":6}},{"line":566,"address":[],"length":0,"stats":{"Line":6}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":3}},{"line":576,"address":[],"length":0,"stats":{"Line":3}},{"line":581,"address":[],"length":0,"stats":{"Line":3}},{"line":585,"address":[],"length":0,"stats":{"Line":3}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":12}},{"line":590,"address":[],"length":0,"stats":{"Line":15}},{"line":591,"address":[],"length":0,"stats":{"Line":6}},{"line":592,"address":[],"length":0,"stats":{"Line":3}},{"line":593,"address":[],"length":0,"stats":{"Line":3}},{"line":594,"address":[],"length":0,"stats":{"Line":9}},{"line":595,"address":[],"length":0,"stats":{"Line":3}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":18}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":3}},{"line":616,"address":[],"length":0,"stats":{"Line":3}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":16}},{"line":665,"address":[],"length":0,"stats":{"Line":32}},{"line":666,"address":[],"length":0,"stats":{"Line":48}},{"line":668,"address":[],"length":0,"stats":{"Line":16}},{"line":669,"address":[],"length":0,"stats":{"Line":62}},{"line":670,"address":[],"length":0,"stats":{"Line":45}},{"line":674,"address":[],"length":0,"stats":{"Line":30}},{"line":675,"address":[],"length":0,"stats":{"Line":30}},{"line":677,"address":[],"length":0,"stats":{"Line":15}},{"line":678,"address":[],"length":0,"stats":{"Line":30}},{"line":681,"address":[],"length":0,"stats":{"Line":1}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":22}},{"line":690,"address":[],"length":0,"stats":{"Line":33}},{"line":691,"address":[],"length":0,"stats":{"Line":22}},{"line":693,"address":[],"length":0,"stats":{"Line":11}},{"line":696,"address":[],"length":0,"stats":{"Line":33}},{"line":699,"address":[],"length":0,"stats":{"Line":22}},{"line":704,"address":[],"length":0,"stats":{"Line":11}},{"line":705,"address":[],"length":0,"stats":{"Line":11}},{"line":706,"address":[],"length":0,"stats":{"Line":33}},{"line":707,"address":[],"length":0,"stats":{"Line":11}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":8}},{"line":737,"address":[],"length":0,"stats":{"Line":8}},{"line":739,"address":[],"length":0,"stats":{"Line":8}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":24}},{"line":747,"address":[],"length":0,"stats":{"Line":8}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":8}},{"line":752,"address":[],"length":0,"stats":{"Line":8}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":3}},{"line":765,"address":[],"length":0,"stats":{"Line":6}},{"line":766,"address":[],"length":0,"stats":{"Line":6}},{"line":769,"address":[],"length":0,"stats":{"Line":6}},{"line":774,"address":[],"length":0,"stats":{"Line":3}},{"line":777,"address":[],"length":0,"stats":{"Line":9}},{"line":779,"address":[],"length":0,"stats":{"Line":13}},{"line":782,"address":[],"length":0,"stats":{"Line":5}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":8}},{"line":798,"address":[],"length":0,"stats":{"Line":8}},{"line":799,"address":[],"length":0,"stats":{"Line":8}},{"line":802,"address":[],"length":0,"stats":{"Line":5}},{"line":803,"address":[],"length":0,"stats":{"Line":5}},{"line":807,"address":[],"length":0,"stats":{"Line":12}},{"line":808,"address":[],"length":0,"stats":{"Line":3}},{"line":812,"address":[],"length":0,"stats":{"Line":24}},{"line":816,"address":[],"length":0,"stats":{"Line":24}},{"line":817,"address":[],"length":0,"stats":{"Line":23}},{"line":818,"address":[],"length":0,"stats":{"Line":83}},{"line":819,"address":[],"length":0,"stats":{"Line":28}},{"line":820,"address":[],"length":0,"stats":{"Line":11}},{"line":821,"address":[],"length":0,"stats":{"Line":2}},{"line":822,"address":[],"length":0,"stats":{"Line":4}},{"line":823,"address":[],"length":0,"stats":{"Line":5}},{"line":824,"address":[],"length":0,"stats":{"Line":2}},{"line":825,"address":[],"length":0,"stats":{"Line":1}},{"line":827,"address":[],"length":0,"stats":{"Line":23}},{"line":829,"address":[],"length":0,"stats":{"Line":1}}],"covered":208,"coverable":301},{"path":["/","app","src","config.rs"],"content":"// src/config.rs\nuse serde::{Deserialize, Serialize};\nuse std::{collections::HashSet, fs, io, path::Path};\nuse tracing::{debug, error, info, warn};\nuse url::Url;\nuse uuid::Uuid;\n\nuse crate::error::{AppError, Result};\n\n// --- Data Structures ---\n\n#[derive(Debug, Deserialize, Clone, PartialEq, Serialize)]\n#[serde(deny_unknown_fields)]\npub struct KeyGroup {\n    pub name: String,\n    #[serde(default)]\n    pub api_keys: Vec\u003cString\u003e,\n    #[serde(default)]\n    pub proxy_url: Option\u003cString\u003e,\n    #[serde(default = \"default_target_url\")]\n    pub target_url: String,\n    #[serde(default)]\n    pub top_p: Option\u003cf32\u003e,\n}\n\nimpl Default for KeyGroup {\n    fn default() -\u003e Self {\n        Self {\n            name: String::new(),\n            api_keys: Vec::new(),\n            proxy_url: None,\n            target_url: default_target_url(),\n            top_p: None,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize, Clone, PartialEq, Default, Serialize)]\n#[serde(deny_unknown_fields)]\npub struct AppConfig {\n    #[serde(default)]\n    pub server: ServerConfig,\n    #[serde(default)]\n    pub groups: Vec\u003cKeyGroup\u003e,\n\n    #[serde(default = \"default_internal_retries\")]\n    pub internal_retries: u32,\n    #[serde(default = \"default_temporary_block_minutes\")]\n    pub temporary_block_minutes: i64,\n}\n\n#[derive(Debug, Deserialize, Clone, PartialEq, Serialize)]\n#[serde(deny_unknown_fields)]\npub struct ServerConfig {\n    #[serde(default = \"default_server_port\")]\n    pub port: u16,\n    #[serde(default)]\n    pub top_p: Option\u003cf32\u003e,\n    #[serde(default)]\n    pub admin_token: Option\u003cString\u003e,\n}\n\n// --- Default Implementations ---\n\nimpl Default for ServerConfig {\n    fn default() -\u003e Self {\n        Self {\n            port: default_server_port(),\n            top_p: None,\n            admin_token: None,\n        }\n    }\n}\nconst fn default_server_port() -\u003e u16 {\n    8080\n}\n\nconst fn default_internal_retries() -\u003e u32 {\n    2\n}\n\nconst fn default_temporary_block_minutes() -\u003e i64 {\n    5\n}\n\nfn default_target_url() -\u003e String {\n    \"https://generativelanguage.googleapis.com/\".to_string()\n}\n\n// --- Helper Functions ---\n\nfn clean_target_url(url_str: \u0026str) -\u003e String {\n    url_str.strip_suffix('/').unwrap_or(url_str).to_string()\n}\n\n// --- Configuration Validation Functions ---\nfn validate_server_config(server: \u0026ServerConfig) -\u003e bool {\n    let mut errors = 0;\n    // Port 0 is valid, it means the OS will assign a random available port.\n    if server.port != 0 \u0026\u0026 (server.port \u003c 1024) {\n        warn!(p = server.port, w = \"low server port warning\");\n    }\n    if let Some(tp) = server.top_p {\n        if !(0.0..=1.0).contains(\u0026tp) {\n            error!(err = \"server top_p out of range\", top_p = tp);\n            errors += 1;\n        }\n    }\n    errors == 0\n}\nfn validate_target_url(g: \u0026str, url: \u0026str) -\u003e bool {\n    match Url::parse(url) {\n        Ok(p) =\u003e {\n            if !p.has_host() || p.host_str().is_none_or(str::is_empty) || p.cannot_be_a_base() {\n                error!(group = g, err = \"invalid/base\", url = %url);\n                false\n            } else {\n                true\n            }\n        }\n        Err(e) =\u003e {\n            error!(group = g, err = %e, url = %url, \"target parse err\");\n            false\n        }\n    }\n}\nfn validate_proxy_url(g: \u0026str, url: \u0026str) -\u003e bool {\n    match Url::parse(url) {\n        Ok(p) =\u003e {\n            if !p.has_host() || p.host_str().is_none_or(str::is_empty) {\n                error!(group = g, err = \"no_host\", url = %url);\n                return false;\n            }\n            let s = p.scheme().to_lowercase();\n            if [\"http\", \"https\", \"socks5\"].contains(\u0026s.as_str()) {\n                true\n            } else {\n                error!(group = g, err = \"bad_scheme\", url = %url, scheme = %s);\n                false\n            }\n        }\n        Err(e) =\u003e {\n            error!(group = g, err = %e, url = %url, \"proxy parse err\");\n            false\n        }\n    }\n}\n\n#[tracing::instrument(level = \"debug\", skip(cfg, source), fields(cfg.source = %source))]\npub fn validate_config(cfg: \u0026mut AppConfig, source: \u0026str) -\u003e bool {\n    let mut errors = 0;\n    if !validate_server_config(\u0026cfg.server) {\n        errors += 1;\n    }\n\n    if cfg.groups.is_empty() {\n        error!(source = source, err = \"no_groups\");\n        errors += 1;\n    } else {\n        let mut names = HashSet::new();\n        let mut keys_total = 0;\n        for group in \u0026mut cfg.groups {\n            let name = group.name.trim();\n            if name.is_empty() {\n                // Check for empty name first\n                error!(err = \"empty_name\");\n                errors += 1;\n            } else {\n                // Only check for duplicates if name is not empty\n                let upper_name = group.name.to_uppercase(); // Use uppercase for HashSet check\n                debug!(group.name = %group.name, group.upper = %upper_name, ?names, \"Attempting to insert into HashSet\"); // Added debug before insert\n                let insert_result = names.insert(upper_name.clone());\n                debug!(group.name = %group.name, group.upper = %upper_name, set.insert_result = insert_result, set.current_size = names.len(), \"Checking group name for duplicates\");\n                if !insert_result {\n                    // Check duplicate result\n                    error!(group = %group.name, err = \"duplicate\");\n                    errors += 1;\n                }\n            }\n            // Check for empty keys independently\n            if group.api_keys.is_empty() {\n                warn!(group = %group.name, warn = \"no_keys\"); /* Group without keys is warned, but not instant error */\n            }\n            keys_total += group.api_keys.len();\n\n            // Clean the target URL in-place\n            group.target_url = clean_target_url(\u0026group.target_url);\n\n            if !validate_target_url(\u0026group.name, \u0026group.target_url) {\n                errors += 1;\n            }\n            if let Some(p) = \u0026group.proxy_url {\n                if !validate_proxy_url(\u0026group.name, p) {\n                    errors += 1;\n                }\n            }\n            if let Some(tp) = group.top_p {\n                if !(0.0..=1.0).contains(\u0026tp) {\n                    error!(group = %group.name, err = \"top_p_out_of_range\", top_p = tp);\n                    errors += 1;\n                }\n            }\n        }\n        // Error only if total keys across all groups is zero (ignoring groups that might have been defined but had no keys)\n        if keys_total == 0 {\n            error!(err = \"no_usable_keys\");\n            errors += 1;\n        }\n    }\n    if errors \u003e 0 {\n        error!(count = errors, \"Validation finished: ERRORS.\");\n        false\n    } else {\n        debug!(\"Validation OK.\");\n        true\n    }\n}\n\n// --- Main Loading Function ---\n#[tracing::instrument(level = \"info\", skip(path), fields(config.path = %path.display()))]\n/// Loads the application configuration from a YAML file.\n///\n/// # Arguments\n/// * `path` - The path to the configuration YAML file.\n///\n/// # Errors\n/// Returns an `AppError::Config` if:\n/// - The YAML file cannot be read or parsed.\n/// - Validation of the final configuration fails.\n/// - Any I/O error occurs during file reading.\npub fn load_config(path: \u0026Path) -\u003e Result\u003cAppConfig\u003e {\n    let path_str = path.display().to_string();\n    let contents = match fs::read_to_string(path) {\n        Ok(c) =\u003e c,\n        Err(e) if e.kind() == io::ErrorKind::NotFound =\u003e {\n            error!(src = \"yaml\", path = %path_str, \"Config file not found.\");\n            return Err(AppError::Config(format!(\n                \"Config file not found: {path_str}\"\n            )));\n        }\n        Err(e) =\u003e {\n            error!(src = \"yaml\", e = %e, \"Read error\");\n            return Err(AppError::Io(io::Error::new(\n                e.kind(),\n                format!(\"Read error {path_str}: {e}\"),\n            )));\n        }\n    };\n\n    if contents.trim().is_empty() {\n        warn!(src = \"yaml\", \"Config file is empty.\");\n        return Err(AppError::Config(format!(\n            \"Config file is empty: {path_str}\"\n        )));\n    }\n\n    let mut config: AppConfig = match serde_yaml::from_str(\u0026contents) {\n        Ok(cfg) =\u003e cfg,\n        Err(e) =\u003e {\n            error!(src = \"yaml\", e = %e, \"Parse error\");\n            return Err(AppError::Config(format!(\n                \"Failed to parse config file {path_str}: {e}\"\n            )));\n        }\n    };\n\n    if !validate_config(\u0026mut config, \u0026path_str) {\n        error!(config.source = %path_str, \"Validation failed.\");\n        return Err(AppError::Config(\"Validation failed\".to_string()));\n    }\n\n    info!(\n        groups = config.groups.len(),\n        keys_total = config\n            .groups\n            .iter()\n            .map(|g| g.api_keys.len())\n            .sum::\u003cusize\u003e(),\n        \"Config loaded OK.\"\n    );\n    Ok(config)\n}\n\n/// Asynchronously saves the application configuration to a YAML file atomically.\n///\n/// # Arguments\n/// * `config` - A reference to the `AppConfig` to be saved.\n/// * `path` - The path to the target configuration YAML file.\n///\n/// # Errors\n/// Returns an `AppError` if:\n/// - The configuration cannot be serialized to YAML.\n/// - The parent directory of the path does not exist.\n/// - The temporary file cannot be written.\n/// - The temporary file cannot be renamed to the final path.\n#[tracing::instrument(level = \"info\", skip(config, path), fields(config.path = %path.display()))]\npub async fn save_config(config: \u0026AppConfig, path: \u0026Path) -\u003e Result\u003c()\u003e {\n    let yaml_data = serde_yaml::to_string(config).map_err(|e| {\n        error!(error = %e, \"Failed to serialize AppConfig to YAML\");\n        AppError::Config(format!(\"Failed to serialize config: {e}\"))\n    })?;\n\n    let parent_dir = path.parent().ok_or_else(|| {\n        error!(\"Config file path has no parent directory\");\n        AppError::Io(io::Error::new(\n            io::ErrorKind::InvalidInput,\n            \"Config file path has no parent directory\",\n        ))\n    })?;\n\n    tokio::fs::create_dir_all(parent_dir).await?;\n\n    let base_filename = path.file_name().unwrap_or_default().to_string_lossy();\n    let temp_filename = format!(\".{}.{}.tmp\", base_filename, Uuid::new_v4());\n    let temp_path = parent_dir.join(\u0026temp_filename);\n\n    tokio::fs::write(\u0026temp_path, yaml_data).await?;\n\n    if let Err(e) = tokio::fs::rename(\u0026temp_path, path).await {\n        error!(\n            from = %temp_path.display(),\n            to = %path.display(),\n            error = ?e,\n            \"Failed to atomically rename temporary config file\"\n        );\n        // Attempt to clean up the temp file on rename failure\n        if let Err(rm_err) = tokio::fs::remove_file(\u0026temp_path).await {\n            warn!(\n                temp_file.path = %temp_path.display(),\n                error = ?rm_err,\n                \"Failed to remove temporary file after rename failure\"\n            );\n        }\n        return Err(e.into());\n    }\n\n    info!(\"Successfully saved configuration.\");\n    Ok(())\n}\n\n// --- Tests ---\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use std::io::Write;\n    use std::path::PathBuf;\n    use tempfile::tempdir;\n    fn create_temp_config_file(d: \u0026tempfile::TempDir, c: \u0026str) -\u003e PathBuf {\n        let p = d.path().join(\"t.yaml\");\n        File::create(\u0026p).unwrap().write_all(c.as_bytes()).unwrap();\n        p\n    }\n    #[test]\n    fn test_clean_url() {\n        assert_eq!(clean_target_url(\"h://a/p/\"), \"h://a/p\");\n        assert_eq!(clean_target_url(\"h://a/p\"), \"h://a/p\");\n    }\n    #[test]\n    fn test_val_srv() {\n        // Default config should be valid\n        assert!(validate_server_config(\u0026ServerConfig::default()));\n        // Port 0 is now considered valid for testing purposes (OS assigns a random port)\n        assert!(validate_server_config(\u0026ServerConfig {\n            port: 0,\n            top_p: None,\n            admin_token: None,\n        }));\n    }\n    #[test]\n    fn test_val_target_ok() {\n        assert!(validate_target_url(\"g\", \"https://e.com\"));\n    }\n    #[test]\n    fn test_val_target_bad() {\n        let _ = tracing::subscriber::set_default(\n            tracing_subscriber::fmt()\n                .with_max_level(tracing::Level::WARN)\n                .finish(),\n        );\n        assert!(!validate_target_url(\"g\", \":b\"));\n        assert!(!validate_target_url(\"g\", \"e.com\"));\n        assert!(!validate_target_url(\"g\", \"https://\"));\n        assert!(!validate_target_url(\"g\", \"\"));\n        assert!(!validate_target_url(\"g\", \"http://\"));\n    }\n    #[test]\n    fn test_val_proxy_ok() {\n        assert!(validate_proxy_url(\"g\", \"http://p\"));\n        assert!(validate_proxy_url(\"g\", \"socks5://p\"));\n    }\n    #[test]\n    fn test_val_proxy_bad() {\n        let _ = tracing::subscriber::set_default(\n            tracing_subscriber::fmt()\n                .with_max_level(tracing::Level::WARN)\n                .finish(),\n        );\n        assert!(!validate_proxy_url(\"g\", \":b\"));\n        assert!(!validate_proxy_url(\"g\", \"ftp://p\"));\n        assert!(!validate_proxy_url(\"g\", \"http://\"));\n        assert!(!validate_proxy_url(\"g\", \"socks5://\"));\n        assert!(!validate_proxy_url(\"g\", \"\"));\n    }\n    #[test]\n    fn test_val_cfg_ok() {\n        let mut cfg = AppConfig {\n            groups: vec![KeyGroup {\n                name: \"G\".into(),\n                api_keys: vec![\"k\".into()],\n                proxy_url: None,\n                target_url: default_target_url(),\n                top_p: None,\n            }],\n            ..Default::default()\n        };\n        assert!(validate_config(\u0026mut cfg, \"\"));\n    }\n    #[test]\n    fn test_val_cfg_bad_name() {\n        let _ = tracing::subscriber::set_default(\n            tracing_subscriber::fmt()\n                .with_max_level(tracing::Level::WARN)\n                .finish(),\n        );\n        let mut cfg = AppConfig {\n            groups: vec![KeyGroup {\n                name: \"\".into(),\n                api_keys: vec![\"k\".into()],\n                proxy_url: None,\n                target_url: default_target_url(),\n                top_p: None,\n            }],\n            ..Default::default()\n        };\n        assert!(!validate_config(\u0026mut cfg, \"\"));\n    }\n    #[test]\n    fn test_val_cfg_dupe_name() {\n        let _ = tracing::subscriber::set_default(\n            tracing_subscriber::fmt()\n                .with_max_level(tracing::Level::WARN)\n                .finish(),\n        );\n        let mut cfg = AppConfig {\n            groups: vec![\n                KeyGroup {\n                    name: \"N\".into(),\n                    api_keys: vec![\"k\".into()],\n                    proxy_url: None,\n                    target_url: default_target_url(),\n                    top_p: None,\n                },\n                KeyGroup {\n                    name: \"n\".into(),\n                    api_keys: vec![\"k\".into()],\n                    proxy_url: None,\n                    target_url: default_target_url(),\n                    top_p: None,\n                },\n            ],\n            ..Default::default()\n        };\n        assert!(!validate_config(\u0026mut cfg, \"\"));\n    }\n    #[test]\n    fn test_val_cfg_empty_keys_ok() {\n        let mut cfg = AppConfig {\n            groups: vec![KeyGroup {\n                name: \"G\".into(),\n                api_keys: vec![\"k1\".to_string(), \"k3\".to_string()],\n                proxy_url: None,\n                target_url: default_target_url(),\n                top_p: None,\n            }],\n            ..Default::default()\n        };\n        assert!(validate_config(\u0026mut cfg, \"\"));\n    }\n    #[test]\n    fn test_val_cfg_no_keys() {\n        let _ = tracing::subscriber::set_default(\n            tracing_subscriber::fmt()\n                .with_max_level(tracing::Level::WARN)\n                .finish(),\n        );\n        let mut cfg = AppConfig {\n            groups: vec![KeyGroup {\n                name: \"G\".into(),\n                api_keys: vec![],\n                proxy_url: None,\n                target_url: default_target_url(),\n                top_p: None,\n            }],\n            ..Default::default()\n        };\n        assert!(!validate_config(\u0026mut cfg, \"\"));\n    } // Should fail validation as total keys = 0\n    #[test]\n    fn test_val_cfg_no_groups() {\n        let _ = tracing::subscriber::set_default(\n            tracing_subscriber::fmt()\n                .with_max_level(tracing::Level::WARN)\n                .finish(),\n        );\n        let mut cfg = AppConfig {\n            groups: vec![],\n            ..Default::default()\n        };\n        assert!(!validate_config(\u0026mut cfg, \"\"));\n    }\n\n    #[test]\n    fn test_load_no_groups_from_file() {\n        let d = tempdir().unwrap();\n        let p = create_temp_config_file(\u0026d, \"server:\\n  port: 1\\n\");\n        let r = load_config(\u0026p);\n        assert!(\n            r.is_err()\n                \u0026\u0026 matches!(r.err(), Some(AppError::Config(m)) if m.contains(\"Validation failed\"))\n        );\n    }\n\n    #[test]\n    fn test_load_config_from_file_ok() {\n        let yaml_content = r#\"\nserver:\n  port: 8081\ngroups:\n  - name: \"Group1\"\n    api_keys: [\"key1\", \"key2\"]\n    target_url: \"https://api.example.com/\"\n    proxy_url: \"http://proxy.example.com\"\n    top_p: 0.9\n\"#;\n        let d = tempdir().unwrap();\n        let p = create_temp_config_file(\u0026d, yaml_content);\n        let cfg = load_config(\u0026p).expect(\"Should load config successfully\");\n\n        assert_eq!(cfg.server.port, 8081);\n        assert_eq!(cfg.groups.len(), 1);\n        let group = \u0026cfg.groups[0];\n        assert_eq!(group.name, \"Group1\");\n        assert_eq!(group.api_keys, vec![\"key1\", \"key2\"]);\n        assert_eq!(group.target_url, \"https://api.example.com\"); // Note trailing slash is removed\n        assert_eq!(\n            group.proxy_url,\n            Some(\"http://proxy.example.com\".to_string())\n        );\n        assert_eq!(group.top_p, Some(0.9));\n    }\n\n    #[test]\n    fn test_load_config_file_not_found() {\n        let d = tempdir().unwrap();\n        let p = d.path().join(\"non_existent_config.yaml\");\n        let r = load_config(\u0026p);\n        assert!(\n            r.is_err()\n                \u0026\u0026 matches!(r.err(), Some(AppError::Config(m)) if m.contains(\"Config file not found\"))\n        );\n    }\n\n    #[test]\n    fn test_load_empty_config_file() {\n        let d = tempdir().unwrap();\n        let p = create_temp_config_file(\u0026d, \"\");\n        let r = load_config(\u0026p);\n        assert!(\n            r.is_err()\n                \u0026\u0026 matches!(r.err(), Some(AppError::Config(m)) if m.contains(\"Config file is empty\"))\n        );\n    }\n\n    #[test]\n    fn test_load_bad_yaml() {\n        let d = tempdir().unwrap();\n        let p = create_temp_config_file(\u0026d, \"server: { port: 123,\");\n        let r = load_config(\u0026p);\n        assert!(\n            r.is_err()\n                \u0026\u0026 matches!(r.err(), Some(AppError::Config(m)) if m.contains(\"Failed to parse config file\"))\n        );\n    }\n} // end tests module\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":34}},{"line":29,"address":[],"length":0,"stats":{"Line":68}},{"line":30,"address":[],"length":0,"stats":{"Line":68}},{"line":32,"address":[],"length":0,"stats":{"Line":34}},{"line":66,"address":[],"length":0,"stats":{"Line":41}},{"line":68,"address":[],"length":0,"stats":{"Line":82}},{"line":74,"address":[],"length":0,"stats":{"Line":41}},{"line":75,"address":[],"length":0,"stats":{"Line":41}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":42}},{"line":87,"address":[],"length":0,"stats":{"Line":84}},{"line":92,"address":[],"length":0,"stats":{"Line":39}},{"line":93,"address":[],"length":0,"stats":{"Line":156}},{"line":97,"address":[],"length":0,"stats":{"Line":38}},{"line":98,"address":[],"length":0,"stats":{"Line":76}},{"line":100,"address":[],"length":0,"stats":{"Line":75}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":38}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":38}},{"line":111,"address":[],"length":0,"stats":{"Line":43}},{"line":112,"address":[],"length":0,"stats":{"Line":43}},{"line":113,"address":[],"length":0,"stats":{"Line":38}},{"line":114,"address":[],"length":0,"stats":{"Line":152}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":38}},{"line":121,"address":[],"length":0,"stats":{"Line":5}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":128,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":5}},{"line":130,"address":[],"length":0,"stats":{"Line":12}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":36}},{"line":151,"address":[],"length":0,"stats":{"Line":72}},{"line":152,"address":[],"length":0,"stats":{"Line":36}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":72}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":34}},{"line":162,"address":[],"length":0,"stats":{"Line":108}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":36}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":36}},{"line":211,"address":[],"length":0,"stats":{"Line":5}},{"line":212,"address":[],"length":0,"stats":{"Line":5}},{"line":214,"address":[],"length":0,"stats":{"Line":31}},{"line":231,"address":[],"length":0,"stats":{"Line":29}},{"line":232,"address":[],"length":0,"stats":{"Line":87}},{"line":233,"address":[],"length":0,"stats":{"Line":84}},{"line":235,"address":[],"length":0,"stats":{"Line":9}},{"line":236,"address":[],"length":0,"stats":{"Line":3}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":257,"address":[],"length":0,"stats":{"Line":22}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":21}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":36}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":21}},{"line":297,"address":[],"length":0,"stats":{"Line":30}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}}],"covered":81,"coverable":107},{"path":["/","app","src","config_watcher.rs"],"content":"// src/config_watcher.rs\n\nuse crate::config::{load_config, AppConfig};\nuse crate::error::{AppError, Result};\nuse notify::{Config, Event, RecommendedWatcher, RecursiveMode, Watcher};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse tokio::sync::{mpsc, RwLock};\nuse tracing::{debug, error, info, warn};\n\n/// Configuration watcher that monitors config file changes\npub struct ConfigWatcher {\n    config_path: PathBuf,\n    current_config: Arc\u003cRwLock\u003cAppConfig\u003e\u003e,\n    _watcher: RecommendedWatcher,\n    receiver: mpsc::Receiver\u003cResult\u003cAppConfig\u003e\u003e,\n}\n\nimpl ConfigWatcher {\n    /// Create a new config watcher\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the initial configuration cannot be loaded or if the\n    /// file watcher cannot be created.\n    pub fn new(config_path: PathBuf) -\u003e Result\u003cSelf\u003e {\n        let (tx, receiver) = mpsc::channel(10);\n        let config_path_clone = config_path.clone();\n\n        let mut watcher = RecommendedWatcher::new(\n            #[allow(clippy::cognitive_complexity)]\n            move |res: notify::Result\u003cEvent\u003e| {\n                if let Ok(event) = res {\n                    debug!(\"Config file event: {event:?}\");\n\n                    // Only react to write events\n                    if matches!(event.kind, notify::EventKind::Modify(_)) {\n                        info!(\"Config file modified, reloading...\");\n\n                        match load_config(\u0026config_path_clone) {\n                            Ok(new_config) =\u003e {\n                                if let Err(e) = tx.try_send(Ok(new_config)) {\n                                    warn!(\"Failed to send config update: {e}\");\n                                }\n                            }\n                            Err(e) =\u003e {\n                                error!(\"Failed to reload config: {e:?}\");\n                                if let Err(send_err) = tx.try_send(Err(e)) {\n                                    warn!(\"Failed to send config error: {send_err}\");\n                                }\n                            }\n                        }\n                    }\n                } else if let Err(e) = res {\n                    error!(\"Config watcher error: {e:?}\");\n                }\n            },\n            Config::default(),\n        )\n        .map_err(|e| AppError::Internal(format!(\"Failed to create file watcher: {e}\")))?;\n\n        // Watch the config file\n        watcher\n            .watch(\u0026config_path, RecursiveMode::NonRecursive)\n            .map_err(|e| AppError::Internal(format!(\"Failed to watch config file: {e}\")))?;\n\n        // Load initial config\n        let initial_config = load_config(\u0026config_path)?;\n        let current_config = Arc::new(RwLock::new(initial_config));\n\n        info!(\"Config watcher initialized for: {}\", config_path.display());\n\n        Ok(Self {\n            config_path,\n            current_config,\n            _watcher: watcher,\n            receiver,\n        })\n    }\n\n    /// Get the current configuration\n    pub async fn get_config(\u0026self) -\u003e AppConfig {\n        self.current_config.read().await.clone()\n    }\n\n    /// Wait for the next configuration change\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the configuration cannot be reloaded or if the\n    /// watcher channel has been closed.\n    pub async fn wait_for_change(\u0026mut self) -\u003e Result\u003cAppConfig\u003e {\n        if let Some(config_result) = self.receiver.recv().await {\n            match config_result {\n                Ok(new_config) =\u003e {\n                    info!(\"Configuration reloaded successfully\");\n                    *self.current_config.write().await = new_config.clone();\n                    Ok(new_config)\n                }\n                Err(e) =\u003e {\n                    warn!(\"Configuration reload failed, keeping current config: {e:?}\");\n                    Err(e)\n                }\n            }\n        } else {\n            error!(\"Config watcher channel closed\");\n            Err(AppError::Internal(\n                \"Config watcher channel closed\".to_string(),\n            ))\n        }\n    }\n\n    /// Force reload the configuration\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the configuration file cannot be read or parsed.\n    pub async fn force_reload(\u0026self) -\u003e Result\u003cAppConfig\u003e {\n        info!(\"Force reloading configuration from: {}\", self.config_path.display());\n        \n        match load_config(\u0026self.config_path) {\n            Ok(new_config) =\u003e {\n                *self.current_config.write().await = new_config.clone();\n                info!(\"Configuration force reloaded successfully\");\n                Ok(new_config)\n            }\n            Err(e) =\u003e {\n                error!(\"Failed to force reload config: {e:?}\");\n                Err(e)\n            }\n        }\n    }\n\n    /// Get configuration file path\n    #[must_use]\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn config_path(\u0026self) -\u003e \u0026Path {\n        \u0026self.config_path\n    }\n}\n\n/// Configuration change notification\n#[derive(Debug, Clone)]\npub struct ConfigChange {\n    pub old_config: AppConfig,\n    pub new_config: AppConfig,\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n}\n\nimpl ConfigChange {\n    #[must_use]\n    pub fn new(old_config: AppConfig, new_config: AppConfig) -\u003e Self {\n        Self {\n            old_config,\n            new_config,\n            timestamp: chrono::Utc::now(),\n        }\n    }\n\n    /// Check if API keys have changed\n    #[must_use]\n    pub fn keys_changed(\u0026self) -\u003e bool {\n        self.old_config.groups != self.new_config.groups\n    }\n\n    /// Check if server configuration has changed\n    #[must_use]\n    pub fn server_changed(\u0026self) -\u003e bool {\n        self.old_config.server != self.new_config.server\n    }\n\n    /// Get summary of changes\n    #[must_use]\n    pub fn change_summary(\u0026self) -\u003e String {\n        let mut changes = Vec::new();\n        \n        if self.server_changed() {\n            changes.push(\"server configuration\");\n        }\n        \n        if self.keys_changed() {\n            changes.push(\"API key groups\");\n        }\n\n        if changes.is_empty() {\n            \"no significant changes detected\".to_string()\n        } else {\n            format!(\"changed: {}\", changes.join(\", \"))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{KeyGroup, ServerConfig};\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[tokio::test]\n    async fn test_config_watcher_creation() {\n        let temp_dir = tempdir().unwrap();\n        let config_path = temp_dir.path().join(\"test_config.yaml\");\n        use std::io::Write;\n\n        // Create an empty config file to ensure the watcher can be created.\n        // The watcher needs to be able to read the file on initialization.\n        let initial_config = AppConfig {\n            server: ServerConfig {\n                host: \"127.0.0.1\".to_string(),\n                port: 8080,\n            },\n            groups: vec![KeyGroup {\n                name: \"test-group\".to_string(),\n                api_keys: vec![\"test-key\".to_string()],\n                target_url: \"http://localhost:1234\".to_string(),\n                proxy_url: None,\n            }],\n        };\n        let yaml = serde_yaml::to_string(\u0026initial_config).unwrap();\n        \n        // Use File::create and sync_all to ensure the file is written to disk\n        let mut temp_file = fs::File::create(\u0026config_path).unwrap();\n        temp_file.write_all(yaml.as_bytes()).unwrap();\n        temp_file.sync_all().unwrap(); // This is the fix\n\n        // Give the filesystem and notify crate a moment to catch up.\n        // This is the definitive fix for the race condition.\n        std::thread::sleep(std::time::Duration::from_millis(50));\n\n        let watcher_result = ConfigWatcher::new(config_path);\n        assert!(watcher_result.is_ok(), \"Watcher creation failed: {:?}\", watcher_result.err());\n    }\n\n    #[tokio::test]\n    async fn test_config_change_detection() {\n        let change = ConfigChange::new(\n            AppConfig {\n                server: ServerConfig {\n                    host: \"127.0.0.1\".to_string(),\n                    port: 8080,\n                },\n                groups: vec![],\n            },\n            AppConfig {\n                server: ServerConfig {\n                    host: \"0.0.0.0\".to_string(),\n                    port: 8081,\n                },\n                groups: vec![KeyGroup {\n                    name: \"test\".to_string(),\n                    api_keys: vec![\"key1\".to_string()],\n                    proxy_url: None,\n                    target_url: \"http://test.com\".to_string(),\n                }],\n            },\n        );\n\n        assert!(change.server_changed());\n        assert!(change.keys_changed());\n        assert!(change.change_summary().contains(\"server configuration\"));\n        assert!(change.change_summary().contains(\"API key groups\"));\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","src","error.rs"],"content":"// src/error.rs\nuse axum::{\n    Json,\n    body::Bytes,\n    http::{HeaderMap, StatusCode},\n    response::{IntoResponse, Response},\n};\nuse serde::Serialize;\nuse thiserror::Error;\nuse tracing::error; // Import error for logging\n\n/// Represents the structured error response body.\n#[derive(Serialize, Debug)]\nstruct ErrorResponse {\n    error: ErrorDetails,\n}\n\n/// Contains the details of an error for the response body.\n#[derive(Serialize, Debug)]\nstruct ErrorDetails {\n    #[serde(rename = \"type\")]\n    error_type: String,\n    message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    details: Option\u003cString\u003e,\n}\n\n/// Specific kinds of proxy configuration errors.\n#[derive(Error, Debug)]\npub enum ProxyConfigErrorKind {\n    #[error(\"Invalid URL format: {0}\")]\n    UrlParse(#[from] url::ParseError),\n    #[error(\"Unsupported scheme: {0}\")]\n    UnsupportedScheme(String),\n    #[error(\"Invalid proxy definition: {0}\")]\n    InvalidDefinition(String), // For errors from reqwest::Proxy constructors\n}\n\n/// Detailed error information for proxy configuration issues.\n#[derive(Error, Debug)]\n#[error(\"Proxy configuration error for URL '{url}': {kind}\")]\n// Make struct and fields public\npub struct ProxyConfigErrorData {\n    pub url: String,\n    pub kind: ProxyConfigErrorKind,\n}\n\n/// Represents the possible errors that can occur within the application.\n///\n/// Implements `IntoResponse` to automatically convert errors into appropriate\n/// HTTP error responses with a standardized JSON body.\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"Configuration error: {0}\")]\n    Config(String), // Keep as String for general config issues, be specific elsewhere\n\n    #[error(\"Reqwest HTTP client error: {0}\")]\n    Reqwest(#[from] reqwest::Error), // RESTORED #[from] here\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"YAML parsing error: {0}\")]\n    YamlParsing(#[from] serde_yaml::Error),\n\n    // UrlParse error is now typically wrapped in ProxyConfigError or handled elsewhere\n    // #[error(\"URL parsing error: {0}\")]\n    // UrlParse(#[from] url::ParseError),\n    #[error(\"No available API keys\")]\n    NoAvailableKeys,\n\n    #[error(\"Upstream service error: {status} - {body}\")]\n    UpstreamServiceError { status: StatusCode, body: String },\n\n    #[error(\"Request body processing error: {0}\")]\n    RequestBodyError(String), // Keep as String for diverse sources\n\n    #[error(\"JSON processing error: {0}\")]\n    JsonProcessing(String, #[source] serde_json::Error),\n\n    #[error(\"Response body processing error: {0}\")]\n    ResponseBodyError(String), // Keep as String for diverse sources\n\n    #[error(\"Invalid API key provided by client\")]\n    InvalidClientApiKey, // If client-side key validation is added\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Not Found: {0}\")]\n    NotFound(String),\n\n    #[error(\"Internal server error: {0}\")]\n    Internal(String), // Catch-all for unexpected errors\n\n    #[error(transparent)] // Use transparent to delegate display/source\n    ProxyConfigError(#[from] ProxyConfigErrorData),\n\n    #[error(\"HTTP client build error: {source}\")] // Reference source directly\n    HttpClientBuildError {\n        source: reqwest::Error,    // #[from] is definitely removed here\n        proxy_url: Option\u003cString\u003e, // Add context\n    },\n\n    #[error(\"Failed to join URL components: {0}\")]\n    UrlJoinError(String),\n\n    #[error(\"CSRF token invalid\")]\n    Csrf,\n\n    #[error(\"Rate limited by upstream\")]\n    RateLimited {\n        status: StatusCode,\n        headers: Box\u003cHeaderMap\u003e,\n        body: Box\u003cBytes\u003e,\n    },\n\n    #[error(\"Failed to read response body from upstream: {0}\")]\n    BodyReadError(String),\n\n    #[error(\"Axum error: {0}\")]\n    Axum(#[from] axum::Error),\n\n    #[error(\"URL parsing error: {0}\")]\n    UrlParse(#[from] url::ParseError),\n\n    #[error(\"HTTP response builder error: {0}\")]\n    HttpResponseBuilder(#[from] http::Error),\n\n    #[error(\"Internal retry mechanism exhausted without a final response\")]\n    InternalRetryExhausted,\n}\n\n// Removed manual `impl From\u003creqwest::Error\u003e for AppError` to resolve conflict\n// with the restored `#[from]` on `AppError::Reqwest`.\n// HttpClientBuildError MUST be constructed explicitly where it occurs.\n\n// Implement IntoResponse for AppError to automatically convert errors into HTTP responses\nimpl IntoResponse for AppError {\n    fn into_response(self) -\u003e Response {\n        let (status, error_details) = match self {\n            Self::InternalRetryExhausted =\u003e (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                ErrorDetails {\n                    error_type: \"INTERNAL_RETRY_EXHAUSTED\".to_string(),\n                    message: \"Internal retry mechanism failed to produce a final response\"\n                        .to_string(),\n                    details: None,\n                },\n            ),\n            Self::RateLimited {\n                status,\n                headers,\n                body,\n            } =\u003e {\n                // The fields are now Boxed, so we need to dereference them.\n                let mut resp = Response::new(axum::body::Body::from(*body));\n                *resp.status_mut() = status;\n                *resp.headers_mut() = *headers;\n                return resp;\n            }\n            // --- 5xx Server Errors (Internal details logged, generic message to client) ---\n            Self::Config(msg) =\u003e {\n                error!(\"Configuration error: {}\", msg); // Log the specific error\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"CONFIG_ERROR\".to_string(),\n                        message: \"Internal server configuration error\".to_string(),\n                        details: None, // Don't expose details\n                    },\n                )\n            }\n            Self::Io(e) =\u003e {\n                error!(\"IO error: {}\", e);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"IO_ERROR\".to_string(),\n                        message: \"Internal server error during IO operation\".to_string(),\n                        details: None,\n                    },\n                )\n            }\n            Self::YamlParsing(e) =\u003e {\n                error!(\"YAML parsing error: {}\", e);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"CONFIG_PARSE_ERROR\".to_string(),\n                        message: \"Failed to parse configuration file\".to_string(),\n                        details: None,\n                    },\n                )\n            }\n            Self::ProxyConfigError(data) =\u003e {\n                error!(\"Proxy configuration error: {}\", data); // Log detailed error\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR, // Config issue is internal\n                    ErrorDetails {\n                        error_type: \"PROXY_CONFIG_ERROR\".to_string(),\n                        message: \"Internal server error related to proxy configuration\".to_string(),\n                        // Optionally expose the problematic URL, but not the internal kind\n                        details: Some(format!(\"Affected proxy URL: {}\", data.url)),\n                        // details: None, // Stricter approach: hide URL too\n                    },\n                )\n            }\n            Self::HttpClientBuildError { source, proxy_url } =\u003e {\n                error!(proxy_url = ?proxy_url, \"HTTP client build error: {}\", source);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"HTTP_CLIENT_BUILD_ERROR\".to_string(),\n                        message: \"Internal server error building HTTP client\".to_string(),\n                        details: proxy_url.map(|u| format!(\"Related proxy: {u}\")),\n                    },\n                )\n            }\n            Self::Internal(msg) =\u003e {\n                error!(\"Internal server error: {}\", msg);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"INTERNAL_SERVER_ERROR\".to_string(),\n                        message: \"An unexpected internal server error occurred\".to_string(),\n                        details: None,\n                    },\n                )\n            }\n            Self::UrlJoinError(msg) =\u003e {\n                error!(\"URL join error: {}\", msg);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"URL_CONSTRUCTION_ERROR\".to_string(),\n                        message: \"Internal error during URL construction\".to_string(),\n                        details: None, // Do not expose internal path details\n                    },\n                )\n            }\n\n            // --- 5xx Errors related to upstream/proxying ---\n            Self::Reqwest(e) =\u003e {\n                error!(\"Upstream reqwest error: {}\", e);\n                // More robust error classification\n                let (status_code, msg_key) = if e.is_timeout() {\n                    (StatusCode::GATEWAY_TIMEOUT, \"timeout\")\n                } else if e.is_connect() {\n                    (StatusCode::BAD_GATEWAY, \"connect\")\n                } else if e.is_request() {\n                    (StatusCode::BAD_GATEWAY, \"request_setup\") // Error building the request itself (e.g., DNS issue)\n                } else if e.is_body() || e.is_decode() {\n                    (StatusCode::BAD_GATEWAY, \"body_or_decode\") // Error processing response body\n                } else {\n                    (StatusCode::BAD_GATEWAY, \"generic\") // Other communication errors\n                };\n\n                let message = match msg_key {\n                    \"timeout\" =\u003e \"Upstream request timed out\".to_string(),\n                    \"connect\" =\u003e \"Could not connect to upstream service\".to_string(),\n                    \"request_setup\" =\u003e \"Internal error setting up upstream request\".to_string(),\n                    \"body_or_decode\" =\u003e {\n                        \"Error processing response body from upstream service\".to_string()\n                    }\n                    _ =\u003e \"Error communicating with upstream service\".to_string(),\n                };\n\n                (\n                    status_code,\n                    ErrorDetails {\n                        error_type: \"UPSTREAM_ERROR\".to_string(),\n                        message,\n                        details: Some(e.to_string()), // Provide reqwest error string as detail\n                    },\n                )\n            }\n            Self::UpstreamServiceError { status, body } =\u003e {\n                error!(\n                    \"Upstream service returned error: Status={}, Body='{}'\",\n                    status, body\n                );\n                (\n                    status, // Use the status code from the upstream service\n                    ErrorDetails {\n                        error_type: \"UPSTREAM_SERVICE_ERROR\".to_string(),\n                        message: \"Upstream service returned an error\".to_string(),\n                        details: Some(body), // Include upstream body if needed\n                    },\n                )\n            }\n            Self::ResponseBodyError(msg) =\u003e {\n                error!(\"Response body processing error: {}\", msg);\n                (\n                    StatusCode::BAD_GATEWAY, // Error processing upstream response\n                    ErrorDetails {\n                        error_type: \"RESPONSE_PROCESSING_ERROR\".to_string(),\n                        message: \"Failed to process response from upstream service\".to_string(),\n                        details: Some(msg),\n                    },\n                )\n            }\n            Self::NoAvailableKeys =\u003e (\n                StatusCode::SERVICE_UNAVAILABLE,\n                ErrorDetails {\n                    error_type: \"NO_AVAILABLE_KEYS\".to_string(),\n                    message: \"No available API keys to process the request at this time\"\n                        .to_string(),\n                    details: None,\n                },\n            ),\n\n            Self::BodyReadError(msg) =\u003e {\n                error!(\"Failed to read upstream response body: {}\", msg);\n                (\n                    StatusCode::BAD_GATEWAY,\n                    ErrorDetails {\n                        error_type: \"UPSTREAM_RESPONSE_READ_ERROR\".to_string(),\n                        message: \"Failed to read response from upstream service\".to_string(),\n                        details: Some(msg),\n                    },\n                )\n            }\n\n            // --- 4xx Client Errors ---\n            Self::RequestBodyError(msg) =\u003e (\n                StatusCode::BAD_REQUEST,\n                ErrorDetails {\n                    error_type: \"REQUEST_BODY_ERROR\".to_string(),\n                    message: \"Failed to process request body\".to_string(),\n                    details: Some(msg),\n                },\n            ),\n            Self::JsonProcessing(msg, source) =\u003e {\n                error!(\"JSON processing error: {} - Source: {}\", msg, source);\n                (\n                    StatusCode::BAD_REQUEST, // JSON error is a client-side malformed request\n                    ErrorDetails {\n                        error_type: \"JSON_PROCESSING_ERROR\".to_string(),\n                        message: msg,\n                        details: Some(source.to_string()),\n                    },\n                )\n            }\n            Self::InvalidClientApiKey =\u003e (\n                StatusCode::UNAUTHORIZED, // Or FORBIDDEN depending on semantics\n                ErrorDetails {\n                    error_type: \"INVALID_API_KEY\".to_string(),\n                    message: \"Invalid or unauthorized API key provided\".to_string(),\n                    details: None,\n                },\n            ),\n            Self::Unauthorized =\u003e (\n                StatusCode::UNAUTHORIZED,\n                ErrorDetails {\n                    error_type: \"UNAUTHORIZED\".to_string(),\n                    message: \"Authentication token is missing or invalid\".to_string(),\n                    details: None,\n                },\n            ),\n            Self::NotFound(resource) =\u003e (\n                StatusCode::NOT_FOUND,\n                ErrorDetails {\n                    error_type: \"NOT_FOUND\".to_string(),\n                    message: format!(\"Resource not found: {resource}\"),\n                    details: None,\n                },\n            ),\n            Self::Csrf =\u003e (\n                StatusCode::FORBIDDEN,\n                ErrorDetails {\n                    error_type: \"CSRF_TOKEN_INVALID\".to_string(),\n                    message: \"CSRF token is missing or invalid.\".to_string(),\n                    details: None,\n                },\n            ),\n            Self::Axum(e) =\u003e {\n                error!(\"Internal Axum error: {}\", e);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"AXUM_INTERNAL_ERROR\".to_string(),\n                        message: \"An internal server error occurred\".to_string(),\n                        details: Some(e.to_string()),\n                    },\n                )\n            }\n            Self::UrlParse(e) =\u003e {\n                error!(\"Internal URL parsing error: {}\", e);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"URL_PARSE_ERROR\".to_string(),\n                        message: \"An internal error occurred while parsing a URL\".to_string(),\n                        details: Some(e.to_string()),\n                    },\n                )\n            }\n            Self::HttpResponseBuilder(e) =\u003e {\n                error!(\"HTTP response builder error: {}\", e);\n                (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    ErrorDetails {\n                        error_type: \"HTTP_RESPONSE_BUILD_ERROR\".to_string(),\n                        message: \"An internal error occurred while building an HTTP response\"\n                            .to_string(),\n                        details: Some(e.to_string()),\n                    },\n                )\n            }\n        };\n\n        let body = Json(ErrorResponse {\n            error: error_details,\n        });\n\n        (status, body).into_response()\n    }\n}\n\n// Optional: Define a type alias for Result using the AppError\npub type Result\u003cT\u003e = std::result::Result\u003cT, AppError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::body::to_bytes;\n    use serde_json::Value;\n    use std::io;\n\n    // Helper to check the structured response\n    async fn check_response(\n        error: AppError,\n        expected_status: StatusCode,\n        expected_type: \u0026str,\n        expected_message_substring: \u0026str,\n        expect_details: bool, // Whether to assert that details field exists (doesn't check content)\n    ) {\n        let response = error.into_response();\n        assert_eq!(response.status(), expected_status, \"Status code mismatch\");\n\n        let body = response.into_body();\n        let bytes = to_bytes(body, usize::MAX)\n            .await\n            .expect(\"Failed to read response body\");\n        let body_json: Value = serde_json::from_slice(\u0026bytes).unwrap_or_else(|e| {\n            panic!(\n                \"Response body is not valid JSON: {}. Body: {}\",\n                e,\n                String::from_utf8_lossy(\u0026bytes)\n            )\n        });\n\n        let error_obj = \u0026body_json[\"error\"];\n        assert!(!error_obj.is_null(), \"JSON 'error' field is missing\");\n\n        let error_type = error_obj[\"type\"]\n            .as_str()\n            .expect(\"JSON 'error.type' field is not a string or missing\");\n        assert_eq!(error_type, expected_type, \"Error type mismatch\");\n\n        let error_msg = error_obj[\"message\"]\n            .as_str()\n            .expect(\"JSON 'error.message' field is not a string or missing\");\n        assert!(\n            error_msg.contains(expected_message_substring),\n            \"Expected error message '{error_msg}' to contain '{expected_message_substring}'\"\n        );\n\n        if expect_details {\n            assert!(\n                !error_obj[\"details\"].is_null(),\n                \"Expected 'error.details' field to exist but it was null or missing\"\n            );\n            assert!(\n                error_obj[\"details\"].is_string(),\n                \"Expected 'error.details' field to be a string\"\n            );\n        } else {\n            assert!(\n                error_obj[\"details\"].is_null() || !error_obj[\"details\"].is_string(),\n                \"Expected 'error.details' field to be null or non-existent/non-string\"\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn test_into_response_config() {\n        check_response(\n            AppError::Config(\"Test config issue\".to_string()),\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"CONFIG_ERROR\",\n            \"Internal server configuration error\",\n            false,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_io() {\n        let io_error = io::Error::new(io::ErrorKind::NotFound, \"File not found\");\n        check_response(\n            AppError::Io(io_error),\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"IO_ERROR\",\n            \"Internal server error during IO operation\",\n            false,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_yaml() {\n        let yaml_error: serde_yaml::Error =\n            serde_yaml::from_str::\u003c()\u003e(\"invalid: yaml:\").unwrap_err();\n        check_response(\n            AppError::YamlParsing(yaml_error),\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"CONFIG_PARSE_ERROR\",\n            \"Failed to parse configuration file\",\n            false,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_proxy_config_url_parse() {\n        let url_error = url::Url::parse(\"::invalid url\").unwrap_err();\n        let proxy_error = ProxyConfigErrorData {\n            url: \"::invalid url\".to_string(),\n            kind: ProxyConfigErrorKind::UrlParse(url_error),\n        };\n        check_response(\n            AppError::ProxyConfigError(proxy_error),\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"PROXY_CONFIG_ERROR\",\n            \"Internal server error related to proxy configuration\",\n            true,\n        )\n        .await; // Expect details (URL)\n    }\n\n    #[tokio::test]\n    async fn test_into_response_proxy_config_unsupported_scheme() {\n        let proxy_error = ProxyConfigErrorData {\n            url: \"ftp://bad\".to_string(),\n            kind: ProxyConfigErrorKind::UnsupportedScheme(\"ftp\".to_string()),\n        };\n        check_response(\n            AppError::ProxyConfigError(proxy_error),\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"PROXY_CONFIG_ERROR\",\n            \"Internal server error related to proxy configuration\",\n            true,\n        )\n        .await; // Expect details (URL)\n    }\n\n    #[tokio::test]\n    async fn test_into_response_no_keys() {\n        check_response(\n            AppError::NoAvailableKeys,\n            StatusCode::SERVICE_UNAVAILABLE,\n            \"NO_AVAILABLE_KEYS\",\n            \"No available API keys\",\n            false,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_upstream_service_error() {\n        check_response(\n            AppError::UpstreamServiceError {\n                status: StatusCode::BAD_GATEWAY,\n                body: \"Upstream failed\".to_string(),\n            },\n            StatusCode::BAD_GATEWAY,\n            \"UPSTREAM_SERVICE_ERROR\",\n            \"Upstream service returned an error\",\n            true, // Expect details (body)\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_request_body_error() {\n        check_response(\n            AppError::RequestBodyError(\"Bad body\".to_string()),\n            StatusCode::BAD_REQUEST,\n            \"REQUEST_BODY_ERROR\",\n            \"Failed to process request body\",\n            true,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_response_body_error() {\n        check_response(\n            AppError::ResponseBodyError(\"Bad response body\".to_string()),\n            StatusCode::BAD_GATEWAY,\n            \"RESPONSE_PROCESSING_ERROR\",\n            \"Failed to process response\",\n            true,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    // Removed ignore from this test\n    async fn test_into_response_invalid_client_key() {\n        check_response(\n            AppError::InvalidClientApiKey,\n            StatusCode::UNAUTHORIZED,\n            \"INVALID_API_KEY\",\n            \"Invalid or unauthorized API key\",\n            false,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_internal() {\n        check_response(\n            AppError::Internal(\"Something went wrong\".to_string()),\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"INTERNAL_SERVER_ERROR\",\n            \"unexpected internal server error\",\n            false,\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_http_client_build_error() {\n        // Simulate a reqwest build error by providing an impossible TLS version range.\n        // This is a reliable way to make the client build fail.\n        let build_error = reqwest::Client::builder()\n            .min_tls_version(reqwest::tls::Version::TLS_1_3)\n            .max_tls_version(reqwest::tls::Version::TLS_1_2)\n            .build()\n            .expect_err(\"Client build should fail with an impossible TLS version range\");\n\n        check_response(\n            // Manually construct the error variant now\n            AppError::HttpClientBuildError {\n                source: build_error,\n                proxy_url: None, // No proxy was involved in this specific build failure\n            },\n            StatusCode::INTERNAL_SERVER_ERROR,\n            \"HTTP_CLIENT_BUILD_ERROR\",\n            \"Internal server error building HTTP client\",\n            false, // No details to expect in this case\n        )\n        .await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_reqwest_timeout() {\n        // Simulate a timeout error - need a way to create reqwest::Error directly or mock\n        // For now, test the logic path using a placeholder error that is_timeout() == true\n        // This requires mocking or a feature flag for testing, skipping for now.\n        // let e = create_mock_reqwest_timeout_error();\n        // check_response(AppError::Reqwest(e), StatusCode::GATEWAY_TIMEOUT, \"UPSTREAM_ERROR\", \"Upstream request timed out\", true).await;\n    }\n\n    #[tokio::test]\n    async fn test_into_response_reqwest_connect() {\n        // Simulate a connect error\n        // Skipping for now due to complexity of creating reqwest::Error\n    }\n\n    #[tokio::test]\n    async fn test_into_response_reqwest_generic() {\n        // Simulate a generic reqwest error\n        let e = reqwest::get(\"http://invalid-url-that-does-not-exist-and-causes-error\")\n            .await\n            .unwrap_err();\n        // Check based on the new logic: request setup errors (like DNS) are now BAD_GATEWAY\n        check_response(\n            AppError::Reqwest(e),\n            StatusCode::BAD_GATEWAY,\n            \"UPSTREAM_ERROR\",\n            \"Internal error setting up upstream request\", // This is the correct message for a DNS/request setup error\n            true,\n        )\n        .await;\n    }\n}\n","traces":[{"line":140,"address":[],"length":0,"stats":{"Line":22}},{"line":141,"address":[],"length":0,"stats":{"Line":44}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":4}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":3}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":3}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":292,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":3}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":3}},{"line":357,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":8}},{"line":370,"address":[],"length":0,"stats":{"Line":8}},{"line":371,"address":[],"length":0,"stats":{"Line":8}},{"line":372,"address":[],"length":0,"stats":{"Line":24}},{"line":373,"address":[],"length":0,"stats":{"Line":16}},{"line":374,"address":[],"length":0,"stats":{"Line":8}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}}],"covered":96,"coverable":169},{"path":["/","app","src","handler.rs"],"content":"// src/handler.rs\nuse crate::{\n    error::{AppError, Result},\n    key_manager::{FlattenedKeyInfo, KeyManager},\n    proxy,\n    state::AppState,\n};\nuse axum::{\n    body::{Body, Bytes, to_bytes},\n    extract::{Request, State},\n    http::{HeaderMap, Method, StatusCode, Uri},\n    response::Response,\n};\nuse chrono::Duration;\nuse std::sync::Arc;\nuse tracing::{error, info, instrument, warn};\nuse url::Url;\n\n/// Represents the outcome of a single key attempt.\nenum RetryOutcome {\n    /// The request was successful.\n    Success(Response),\n    /// The request failed in a way that warrants trying the next available key.\n    /// The associated data is the last error response received.\n    RetryNextKey((StatusCode, HeaderMap, Bytes)),\n    /// The request failed with a terminal error that should be returned to the client immediately.\n    Terminal(Response),\n}\n\n#[instrument(name = \"health_check\", skip_all)]\npub async fn health_check() -\u003e StatusCode {\n    StatusCode::OK\n}\n\n/* ---------- helpers ---------- */\n\n/// Extracts model name from request path and body\nfn extract_model_from_request(path: \u0026str, body: \u0026[u8]) -\u003e Option\u003cString\u003e {\n    // Try to extract from path first (for generateContent endpoints)\n    if let Some(captures) = regex::Regex::new(r\"/v1beta/models/([^/:]+)\")\n        .ok()?\n        .captures(path)\n    {\n        return Some(captures.get(1)?.as_str().to_string());\n    }\n\n    // Try to extract from OpenAI-style path\n    if path.contains(\"/chat/completions\") || path.contains(\"/embeddings\") {\n        // Try to parse JSON body to get model\n        if let Ok(body_str) = std::str::from_utf8(body) {\n            if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(body_str) {\n                if let Some(model) = json.get(\"model\").and_then(|m| m.as_str()) {\n                    return Some(model.to_string());\n                }\n            }\n        }\n    }\n\n    None\n}\n\nfn translate_path(path: \u0026str) -\u003e String {\n    if path == \"/health/detailed\" {\n        return \"/v1beta/models\".into();\n    }\n    if let Some(rest) = path.strip_prefix(\"/v1/\") {\n        return match rest {\n            r if r.starts_with(\"chat/completions\") =\u003e format!(\"/v1beta/openai/{r}\"),\n            r if r.starts_with(\"embeddings\") || r.starts_with(\"audio/speech\") =\u003e {\n                format!(\"/v1beta/{r}\")\n            }\n            r =\u003e format!(\"/v1beta/openai/{r}\"),\n        };\n    }\n    path.to_owned()\n}\n\nfn build_target_url(original_uri: \u0026Uri, key_info: \u0026FlattenedKeyInfo) -\u003e Result\u003cUrl\u003e {\n    let mut url = Url::parse(\u0026key_info.target_url)?.join(\u0026translate_path(original_uri.path()))?;\n    url.set_query(original_uri.query());\n    url.query_pairs_mut().append_pair(\"key\", \u0026key_info.key);\n    Ok(url)\n}\n\nasync fn mutate_key\u003cF\u003e(state: \u0026Arc\u003cAppState\u003e, key: \u0026str, f: F) -\u003e Result\u003c()\u003e\nwhere\n    F: FnOnce(\u0026mut KeyManager, \u0026str),\n{\n    let mut km = state.key_manager.write().await;\n    f(\u0026mut km, key);\n    km.save_states().await?;\n    Ok(())\n}\n\nstruct RequestContext\u003c'a\u003e {\n    method: \u0026'a Method,\n    uri: \u0026'a Uri,\n    headers: \u0026'a HeaderMap,\n    body: \u0026'a Bytes,\n}\n\nasync fn retry_with_key(\n    state: \u0026Arc\u003cAppState\u003e,\n    key_info: \u0026FlattenedKeyInfo,\n    req_context: \u0026RequestContext\u003c'_\u003e,\n    internal_retries: u32,\n    model: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cRetryOutcome\u003e {\n    for attempt in 1..=internal_retries + 1 {\n        let url = build_target_url(req_context.uri, key_info)?;\n\n        let response_result = proxy::forward_request(\n            state,\n            key_info,\n            req_context.method.clone(),\n            url,\n            req_context.headers.clone(),\n            req_context.body.clone(),\n        )\n        .await;\n\n        let response = match response_result {\n            Ok(r) =\u003e r,\n            Err(e) =\u003e {\n                error!(error = ?e, key = %key_info.key, \"Forwarding request failed\");\n                let block_duration =\n                    Duration::minutes(state.config.read().await.temporary_block_minutes);\n                mutate_key(state, \u0026key_info.key, |km, k| {\n                    km.mark_key_as_temporarily_unavailable(k, block_duration);\n                })\n                .await?;\n                // This is a network-level error with our proxy or the target.\n                // It's a retryable offense (try next key).\n                // We don't have a response to store, so we fabricate a 502 error.\n                let body = Bytes::from(format!(\"Proxy error: {e}\"));\n                return Ok(RetryOutcome::RetryNextKey((\n                    StatusCode::BAD_GATEWAY,\n                    HeaderMap::new(),\n                    body,\n                )));\n            }\n        };\n\n        let status = response.status();\n        let (parts, body) = response.into_parts();\n        let bytes = to_bytes(body, usize::MAX)\n            .await\n            .map_err(|e| AppError::BodyReadError(e.to_string()))?;\n\n        match status {\n            s if s.is_success() =\u003e {\n                info!(key = %key_info.key, \"Request successful\");\n                return Ok(RetryOutcome::Success(Response::from_parts(\n                    parts,\n                    Body::from(bytes),\n                )));\n            }\n            StatusCode::NOT_FOUND | StatusCode::GATEWAY_TIMEOUT =\u003e {\n                warn!(%status, key = %key_info.key, \"Received terminal error, not retrying with another key.\");\n                return Ok(RetryOutcome::Terminal(Response::from_parts(\n                    parts,\n                    Body::from(bytes),\n                )));\n            }\n            StatusCode::TOO_MANY_REQUESTS =\u003e {\n                if let Some(model_name) = model {\n                    warn!(\n                        key = %key_info.key,\n                        model = %model_name,\n                        \"Received 429 Too Many Requests. Blocking key for specific model and trying next.\"\n                    );\n                    mutate_key(state, \u0026key_info.key, |km, k| {\n                        km.mark_key_as_limited_for_model(k, model_name);\n                    })\n                    .await?;\n                } else {\n                    warn!(key = %key_info.key, \"Received 429 Too Many Requests. Marking key as generally limited and trying next.\");\n                    mutate_key(state, \u0026key_info.key, |km, k| {\n                        km.mark_key_as_limited(k);\n                    })\n                    .await?;\n                }\n                return Ok(RetryOutcome::RetryNextKey((status, parts.headers, bytes)));\n            }\n            s if s == StatusCode::BAD_REQUEST =\u003e {\n                if let Ok(body_str) = std::str::from_utf8(\u0026bytes) {\n                    if body_str.contains(\"API_KEY_INVALID\") {\n                        warn!(key = %key_info.key, \"Marking key as invalid due to API_KEY_INVALID reason in body.\");\n                        mutate_key(state, \u0026key_info.key, |km, k| {\n                            km.mark_key_as_invalid(k);\n                        })\n                        .await?;\n                        return Ok(RetryOutcome::RetryNextKey((s, parts.headers, bytes)));\n                    }\n                }\n                warn!(%s, key = %key_info.key, \"Received 400 Bad Request without API_KEY_INVALID. Returning error to client immediately.\");\n                return Ok(RetryOutcome::Terminal(Response::from_parts(\n                    parts,\n                    Body::from(bytes),\n                )));\n            }\n            s if s.is_client_error() =\u003e {\n                warn!(%s, key = %key_info.key, \"Received a terminal client error. Returning error to client immediately.\");\n                return Ok(RetryOutcome::Terminal(Response::from_parts(\n                    parts,\n                    Body::from(bytes),\n                )));\n            }\n            s if s.is_server_error() =\u003e {\n                warn!(%s, attempt, key = %key_info.key, \"Server error, will retry\");\n                if attempt \u003e internal_retries {\n                    error!(key=%key_info.key, \"Internal retries exhausted. Marking key as temporarily unavailable.\");\n                    let block_duration =\n                        Duration::minutes(state.config.read().await.temporary_block_minutes);\n                    mutate_key(state, \u0026key_info.key, |km, k| {\n                        km.mark_key_as_temporarily_unavailable(k, block_duration);\n                    })\n                    .await?;\n                    return Ok(RetryOutcome::RetryNextKey((s, parts.headers, bytes)));\n                }\n                tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n                continue;\n            }\n            _ =\u003e {\n                warn!(%status, \"Received unexpected status code, returning as is.\");\n                return Ok(RetryOutcome::Terminal(Response::from_parts(\n                    parts,\n                    Body::from(bytes),\n                )));\n            }\n        }\n    }\n    // This is only reached if the internal retry loop for server errors finishes\n    // without returning. We need to return the last error encountered.\n    // This part of the logic is complex, for now we assume the loop always returns.\n    // A robust implementation would handle this case explicitly.\n    Err(AppError::InternalRetryExhausted)\n}\n\n/* ---------- main handler ---------- */\n\n#[instrument(skip(state, req), fields(uri = %req.uri(), method = %req.method()))]\npub async fn proxy_handler(State(state): State\u003cArc\u003cAppState\u003e\u003e, req: Request) -\u003e Result\u003cResponse\u003e {\n    let (parts, body) = req.into_parts();\n    let body_bytes = to_bytes(body, usize::MAX)\n        .await\n        .map_err(|e| AppError::RequestBodyError(e.to_string()))?;\n\n    let req_context = RequestContext {\n        method: \u0026parts.method,\n        uri: \u0026parts.uri,\n        headers: \u0026parts.headers,\n        body: \u0026body_bytes,\n    };\n\n    // Extract model from request for model-specific key management\n    let model = extract_model_from_request(req_context.uri.path(), \u0026body_bytes);\n\n    info!(\n        model = ?model,\n        path = %req_context.uri.path(),\n        \"Processing request with model-specific key management\"\n    );\n\n    let internal_retries = {\n        let config = state.config.read().await;\n        config.internal_retries\n    };\n\n    let mut last_error: Option\u003c(StatusCode, HeaderMap, Bytes)\u003e = None;\n\n    // Clean up expired model blocks before processing\n    {\n        let mut km = state.key_manager.write().await;\n        km.cleanup_expired_model_blocks();\n    }\n\n    loop {\n        let key_info = {\n            let km = state.key_manager.read().await;\n            km.get_next_available_key_info_for_model(model.as_deref())\n        };\n\n        let key_info = match key_info {\n            Some(ki) =\u003e ki,\n            None =\u003e break, // No more keys, break the loop\n        };\n\n        let result = retry_with_key(\n            \u0026state,\n            \u0026key_info,\n            \u0026req_context,\n            internal_retries,\n            model.as_deref(),\n        )\n        .await?;\n\n        match result {\n            RetryOutcome::Success(resp) =\u003e return Ok(resp),\n            RetryOutcome::Terminal(resp) =\u003e return Ok(resp),\n            RetryOutcome::RetryNextKey(err) =\u003e {\n                last_error = Some(err);\n                continue;\n            }\n        }\n    }\n\n    // After the loop, if we've broken out due to no keys\n    if let Some(model_name) = \u0026model {\n        warn!(model = %model_name, \"No available API keys remaining for model.\");\n    } else {\n        warn!(\"No available API keys remaining.\");\n    }\n\n    if let Some((status, headers, body)) = last_error {\n        let mut resp = Response::new(Body::from(body));\n        *resp.status_mut() = status;\n        *resp.headers_mut() = headers;\n        Ok(resp)\n    } else {\n        // This case should ideally not be hit if there was at least one key attempt that failed\n        Err(AppError::NoAvailableKeys)\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":66}},{"line":40,"address":[],"length":0,"stats":{"Line":132}},{"line":42,"address":[],"length":0,"stats":{"Line":66}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":188}},{"line":50,"address":[],"length":0,"stats":{"Line":20}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":62}},{"line":62,"address":[],"length":0,"stats":{"Line":88}},{"line":63,"address":[],"length":0,"stats":{"Line":88}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":84}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":36}},{"line":69,"address":[],"length":0,"stats":{"Line":144}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":72}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":88}},{"line":79,"address":[],"length":0,"stats":{"Line":352}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":14}},{"line":89,"address":[],"length":0,"stats":{"Line":28}},{"line":90,"address":[],"length":0,"stats":{"Line":28}},{"line":91,"address":[],"length":0,"stats":{"Line":14}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":102,"address":[],"length":0,"stats":{"Line":76}},{"line":109,"address":[],"length":0,"stats":{"Line":164}},{"line":110,"address":[],"length":0,"stats":{"Line":352}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":176}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":88}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":88}},{"line":150,"address":[],"length":0,"stats":{"Line":16}},{"line":151,"address":[],"length":0,"stats":{"Line":120}},{"line":152,"address":[],"length":0,"stats":{"Line":60}},{"line":153,"address":[],"length":0,"stats":{"Line":120}},{"line":154,"address":[],"length":0,"stats":{"Line":120}},{"line":155,"address":[],"length":0,"stats":{"Line":60}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":8}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":32}},{"line":179,"address":[],"length":0,"stats":{"Line":24}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":183,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":28}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":8}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":16}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":32}},{"line":210,"address":[],"length":0,"stats":{"Line":16}},{"line":211,"address":[],"length":0,"stats":{"Line":16}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":12}},{"line":215,"address":[],"length":0,"stats":{"Line":16}},{"line":216,"address":[],"length":0,"stats":{"Line":16}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":12}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":132}},{"line":247,"address":[],"length":0,"stats":{"Line":0}}],"covered":62,"coverable":117},{"path":["/","app","src","key_manager.rs"],"content":"// src/key_manager.rs\n\nuse crate::config::AppConfig;\nuse crate::error::{AppError, Result as AppResult}; // Use AppResult alias where appropriate\nuse axum::http::StatusCode;\nuse chrono::{DateTime, Duration as ChronoDuration, NaiveDateTime, TimeZone, Utc}; // ENSURED TimeZone is imported\nuse chrono_tz::America::Los_Angeles; // Use Los_Angeles timezone (PST/PDT)\nuse chrono_tz::Tz; // Import Tz trait\nuse reqwest::{Client, header::CONTENT_TYPE};\nuse serde::{Deserialize, Serialize};\nuse std::{\n    collections::HashMap,\n    io as std_io, // Import standard io for Error kind\n    path::{Path, PathBuf},\n    sync::{\n        Arc,\n        atomic::{AtomicUsize, Ordering},\n    }, // Added Arc for mutex cloning\n};\nuse tokio::fs::{self as async_fs};\nuse tokio::sync::Mutex;\nuse tracing::{debug, error, info, warn};\nuse uuid::Uuid; // For unique temporary file names\n\n// --- Structures ---\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]\npub enum KeyStatus {\n    #[default]\n    Available,\n    RateLimited,\n    Invalid,\n    TemporarilyUnavailable,\n}\n\n// Model-specific key blocking state\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ModelBlockState {\n    pub blocked_until: DateTime\u003cUtc\u003e,\n    pub reason: String,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]\npub struct KeyState {\n    pub status: KeyStatus,\n    pub reset_time: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    // Map of model name to blocking state\n    #[serde(default)]\n    pub model_blocks: HashMap\u003cString, ModelBlockState\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct FlattenedKeyInfo {\n    pub key: String,\n    pub proxy_url: Option\u003cString\u003e,\n    pub target_url: String,\n    pub group_name: String,\n    pub top_p: Option\u003cf32\u003e,\n}\n// --- KeyManager ---\n\n#[derive(Debug)]\npub struct KeyManager {\n    // Store keys grouped by their original group name.\n    // The outer Vec represents groups, the tuple holds (group_name, keys_in_group).\n    // Order of groups is preserved based on config processing order.\n    grouped_keys: Vec\u003c(String, Vec\u003cFlattenedKeyInfo\u003e)\u003e,\n    // Map for O(1) lookup of key info by its MD5 hash ID.\n    key_id_map: HashMap\u003cString, FlattenedKeyInfo\u003e,\n    // Index of the group to try next.\n    current_group_index: AtomicUsize,\n    // Index of the key to try next *within each group*. The order matches `grouped_keys`.\n    key_indices_per_group: Vec\u003cAtomicUsize\u003e,\n    // REMOVED Arc\u003cRwLock\u003c...\u003e\u003e. State is now managed directly here.\n    // The entire KeyManager will be wrapped in an RwLock in AppState.\n    key_states: HashMap\u003cString, KeyState\u003e,\n    state_file_path: PathBuf,\n    // This mutex is for controlling writes to the state *file*, not in-memory state.\n    save_mutex: Arc\u003cMutex\u003c()\u003e\u003e,\n}\n\nimpl KeyManager {\n    #[tracing::instrument(level = \"info\", skip(config, config_path))]\n    pub async fn new(config: \u0026AppConfig, config_path: \u0026Path) -\u003e Self {\n        info!(\"Initializing KeyManager...\");\n        let state_file_path = config_path\n            .parent()\n            .unwrap_or_else(|| Path::new(\".\"))\n            .join(\"key_states.json\");\n        let state_file_path_display = state_file_path.display().to_string(); // Capture for logs\n        info!(key_state.path = %state_file_path_display, \"Key state persistence file\");\n\n        let persisted_states = load_key_states_from_file(\u0026state_file_path).await;\n        let mut grouped_keys_map: HashMap\u003cString, Vec\u003cFlattenedKeyInfo\u003e\u003e = HashMap::new();\n        // This HashMap now correctly implements Улика №2\n        let mut key_id_map: HashMap\u003cString, FlattenedKeyInfo\u003e = HashMap::new();\n        let mut initial_key_states = HashMap::new();\n        let mut processed_keys_count = 0;\n        let now = Utc::now();\n\n        // First pass: Collect keys into a map grouped by name to preserve group structure\n        for group in \u0026config.groups {\n            if group.api_keys.is_empty() {\n                warn!(group.name = %group.name, \"Skipping group with no API keys.\");\n                continue;\n            }\n            info!(\n               group.name = %group.name,\n               group.key_count = group.api_keys.len(),\n               group.proxy_url = group.proxy_url.as_deref().unwrap_or(\"None\"),\n               group.target_url = %group.target_url,\n               \"Processing group for KeyManager\"\n            );\n            let group_entry = grouped_keys_map.entry(group.name.clone()).or_default();\n            for key in \u0026group.api_keys {\n                if key.trim().is_empty() {\n                    warn!(group.name = %group.name, \"Skipping empty API key string in group.\");\n                    continue;\n                }\n                let key_info = FlattenedKeyInfo {\n                    key: key.clone(),\n                    proxy_url: group.proxy_url.clone(),\n                    target_url: group.target_url.clone(),\n                    group_name: group.name.clone(),\n                    top_p: group.top_p,\n                };\n                group_entry.push(key_info.clone()); // Add key to its group in the map\n\n                // Calculate MD5 hash for O(1) lookup\n                let key_id = format!(\"{:x}\", md5::compute(key.as_bytes()));\n                key_id_map.insert(key_id, key_info.clone()); // Add to the ID map\n\n                // Process state (this part remains largely the same)\n                let state_to_insert =\n                    persisted_states\n                        .get(key)\n                        .map_or_else(KeyState::default, |persisted| {\n                            let is_expired = persisted.reset_time.is_some_and(|rt| now \u003e= rt);\n                            match persisted.status {\n                                KeyStatus::RateLimited | KeyStatus::TemporarilyUnavailable\n                                    if is_expired =\u003e\n                                {\n                                    info!(api_key.preview = %Self::preview(key), group.name = %group.name, \"Persisted limit for key has expired. Initializing as available.\");\n                                    KeyState::default()\n                                }\n                                KeyStatus::Invalid =\u003e {\n                                    info!(api_key.preview = %Self::preview(key), group.name = %group.name, \"Loaded persisted invalid state for key.\");\n                                    persisted.clone()\n                                }\n                                KeyStatus::RateLimited | KeyStatus::TemporarilyUnavailable =\u003e {\n                                    info!(api_key.preview = %Self::preview(key), group.name = %group.name, key.status = ?persisted.status, key.reset_time = ?persisted.reset_time, \"Loaded persisted limited state for key.\");\n                                    persisted.clone()\n                                }\n                                KeyStatus::Available =\u003e persisted.clone(),\n                            }\n                        });\n                initial_key_states\n                    .entry(key.clone())\n                    .or_insert(state_to_insert);\n                processed_keys_count += 1;\n            }\n        }\n\n        let mut grouped_keys: Vec\u003c(String, Vec\u003cFlattenedKeyInfo\u003e)\u003e =\n            Vec::with_capacity(config.groups.len());\n        let mut key_indices_per_group: Vec\u003cAtomicUsize\u003e = Vec::with_capacity(config.groups.len());\n\n        // Iterate through config.groups again to maintain the original order\n        let mut active_group_count = 0;\n        for group_config in \u0026config.groups {\n            if let Some(keys) = grouped_keys_map.remove(\u0026group_config.name) {\n                if !keys.is_empty() {\n                    grouped_keys.push((group_config.name.clone(), keys));\n                    key_indices_per_group.push(AtomicUsize::new(0));\n                    active_group_count += 1;\n                }\n            }\n        }\n\n        let all_keys_in_config: std::collections::HashSet\u003cString\u003e = grouped_keys\n            .iter()\n            .flat_map(|(_, keys)| keys.iter().map(|ki| ki.key.clone()))\n            .collect();\n\n        initial_key_states.retain(|key, _| {\n            let key_in_config = all_keys_in_config.contains(key);\n            if !key_in_config {\n                warn!(api_key.preview = %Self::preview(key), \"Removing state for key no longer present in configuration.\");\n            }\n            key_in_config\n        });\n\n        if processed_keys_count == 0 {\n            error!(\n                \"KeyManager Initialization Error: No usable API keys found after processing configuration. Application might not function correctly.\"\n            );\n        } else if active_group_count == 0 {\n            error!(\n                \"KeyManager Initialization Error: Keys were processed, but no active groups were formed. Check group definitions.\"\n            );\n        }\n\n        info!(\n            key_manager.total_keys = processed_keys_count,\n            key_manager.total_groups = active_group_count,\n            \"KeyManager: Grouped keys into rotation list.\"\n        );\n        info!(\n            key_manager.state_count = initial_key_states.len(),\n            key_manager.persisted_count = persisted_states.len(),\n            \"KeyManager: Initialized key states.\"\n        );\n\n        let manager = Self {\n            grouped_keys,\n            key_id_map,\n            current_group_index: AtomicUsize::new(0),\n            key_indices_per_group,\n            key_states: initial_key_states,\n            state_file_path: state_file_path.clone(),\n            save_mutex: Arc::new(Mutex::new(())),\n        };\n\n        debug!(key_state.path = %state_file_path_display, \"Performing initial state save/sync after KeyManager initialization.\");\n        if let Err(e) = manager.save_states().await {\n            error!(key_state.path = %state_file_path_display, error = ?e, \"Failed to perform initial save of key states. The state file might be outdated or missing.\");\n        } else {\n            debug!(key_state.path = %state_file_path_display, \"Initial state save completed successfully.\");\n        }\n        manager\n    }\n\n    /// Checks if a key is available for a specific model\n    pub fn is_key_available_for_model(\u0026self, api_key: \u0026str, model: Option\u003c\u0026str\u003e) -\u003e bool {\n        let Some(key_state) = self.key_states.get(api_key) else {\n            return false;\n        };\n\n        let now = Utc::now();\n\n        // Check general key status first\n        let is_generally_available = match key_state.status {\n            KeyStatus::Available =\u003e true,\n            KeyStatus::RateLimited | KeyStatus::TemporarilyUnavailable =\u003e {\n                key_state.reset_time.is_some_and(|rt| now \u003e= rt)\n            }\n            KeyStatus::Invalid =\u003e false,\n        };\n\n        if !is_generally_available {\n            return false;\n        }\n\n        // Check model-specific blocks\n        if let Some(model_name) = model {\n            if let Some(block_state) = key_state.model_blocks.get(model_name) {\n                return now \u003e= block_state.blocked_until;\n            }\n        }\n\n        true\n    }\n\n    /// Gets the next available key for a specific model\n    #[tracing::instrument(level = \"debug\", skip(self), fields(model = ?model))]\n    pub fn get_next_available_key_info_for_model(\n        \u0026self,\n        model: Option\u003c\u0026str\u003e,\n    ) -\u003e Option\u003cFlattenedKeyInfo\u003e {\n        if self.grouped_keys.is_empty() {\n            warn!(\n                key_manager.status = \"empty\",\n                \"No key groups configured or available. Cannot provide a key.\"\n            );\n            return None;\n        }\n\n        let num_groups = self.grouped_keys.len();\n        let initial_group_index = self.current_group_index.load(Ordering::Relaxed);\n\n        for group_offset in 0..num_groups {\n            let current_group_idx = (initial_group_index + group_offset) % num_groups;\n            let Some((group_name, keys_in_group)) = self.grouped_keys.get(current_group_idx) else {\n                error!(\n                    group.index = current_group_idx,\n                    \"Internal inconsistency: Group index out of bounds. Skipping.\"\n                );\n                continue;\n            };\n\n            if keys_in_group.is_empty() {\n                debug!(group.index = current_group_idx, group.name = %group_name, \"Skipping empty group\");\n                continue;\n            }\n\n            let num_keys_in_group = keys_in_group.len();\n            let Some(group_key_index_atomic) = self.key_indices_per_group.get(current_group_idx)\n            else {\n                error!(group.index = current_group_idx, group.name=%group_name, \"Internal inconsistency: Missing key index for group. Skipping.\");\n                continue;\n            };\n            let initial_key_index_in_group = group_key_index_atomic.load(Ordering::Relaxed);\n\n            debug!(group.index = current_group_idx, group.name = %group_name, group.key_count = num_keys_in_group, group.start_key_index = initial_key_index_in_group, \"Searching within group for model\");\n\n            for key_offset in 0..num_keys_in_group {\n                let current_key_idx_in_group =\n                    (initial_key_index_in_group + key_offset) % num_keys_in_group;\n                let Some(key_info) = keys_in_group.get(current_key_idx_in_group) else {\n                    error!(group.index = current_group_idx, group.name=%group_name, key.index=current_key_idx_in_group, \"Internal inconsistency: Key index out of bounds within group. Skipping key.\");\n                    continue;\n                };\n\n                if self.is_key_available_for_model(\u0026key_info.key, model) {\n                    let next_key_idx_in_group = (current_key_idx_in_group + 1) % num_keys_in_group;\n                    group_key_index_atomic.store(next_key_idx_in_group, Ordering::Relaxed);\n                    let next_group_idx = (current_group_idx + 1) % num_groups;\n                    self.current_group_index\n                        .store(next_group_idx, Ordering::Relaxed);\n\n                    debug!(\n                       api_key.preview = %Self::preview(\u0026key_info.key),\n                       group.name = %group_name,\n                       model = ?model,\n                       \"Selected available API key for model using group round-robin\"\n                    );\n                    return Some(key_info.clone());\n                }\n            }\n            group_key_index_atomic.store(0, Ordering::Relaxed);\n        }\n\n        if let Some(model_name) = model {\n            warn!(\n                key_manager.status = \"all_limited_for_model\",\n                model = %model_name,\n                \"All API keys are currently blocked for the requested model.\"\n            );\n        } else {\n            warn!(\n                key_manager.status = \"all_limited\",\n                \"All API keys checked are currently rate-limited or unavailable.\"\n            );\n        }\n        None\n    }\n\n    #[tracing::instrument(level = \"debug\", skip(self))]\n    pub fn get_next_available_key_info(\u0026self) -\u003e Option\u003cFlattenedKeyInfo\u003e {\n        self.get_next_available_key_info_for_model(None)\n    }\n\n    /// Blocks a key for a specific model until quota reset time (00:00 PST / 10:00 MSK)\n    #[tracing::instrument(level = \"warn\", skip(self, api_key), fields(api_key.preview = %Self::preview(api_key), model = %model))]\n    pub fn mark_key_as_limited_for_model(\u0026mut self, api_key: \u0026str, model: \u0026str) -\u003e bool {\n        let mut group_name_for_log = \"unknown\".to_string();\n\n        if let Some(key_state) = self.key_states.get_mut(api_key) {\n            if let Some(found_key_info) = self\n                .grouped_keys\n                .iter()\n                .flat_map(|(_, keys)| keys.iter())\n                .find(|k| k.key == api_key)\n            {\n                group_name_for_log.clone_from(\u0026found_key_info.group_name);\n            }\n\n            let now_utc = Utc::now();\n\n            // Check if already blocked for this model and not expired\n            if let Some(existing_block) = key_state.model_blocks.get(model) {\n                if now_utc \u003c existing_block.blocked_until {\n                    debug!(model = %model, \"Key already blocked for this model. Ignoring.\");\n                    return false;\n                }\n            }\n\n            // Calculate reset time (00:00 PST / 10:00 MSK)\n            let target_tz: Tz = Los_Angeles;\n            let now_in_target_tz = now_utc.with_timezone(\u0026target_tz);\n            let tomorrow_naive_target = (now_in_target_tz + ChronoDuration::days(1)).date_naive();\n            let reset_time_naive_target: NaiveDateTime = tomorrow_naive_target\n                .and_hms_opt(0, 0, 0)\n                .expect(\"Failed to calculate next midnight\");\n            let reset_time_utc = target_tz\n                .from_local_datetime(\u0026reset_time_naive_target)\n                .single()\n                .expect(\"Timezone conversion failed\")\n                .with_timezone(\u0026Utc);\n\n            warn!(\n                group.name = %group_name_for_log,\n                model = %model,\n                reset_time = %reset_time_utc,\n                \"Blocking key for specific model due to 429 quota exceeded\"\n            );\n\n            key_state.model_blocks.insert(\n                model.to_string(),\n                ModelBlockState {\n                    blocked_until: reset_time_utc,\n                    reason: \"429 quota exceeded\".to_string(),\n                },\n            );\n\n            true\n        } else {\n            error!(\"Attempted to mark an unknown API key as limited for model!\");\n            false\n        }\n    }\n\n    #[tracing::instrument(level = \"warn\", skip(self, api_key), fields(api_key.preview = %Self::preview(api_key)))]\n    pub fn mark_key_as_limited(\u0026mut self, api_key: \u0026str) -\u003e bool {\n        let mut group_name_for_log = \"unknown\".to_string();\n\n        if let Some(key_state) = self.key_states.get_mut(api_key) {\n            if let Some(found_key_info) = self\n                .grouped_keys\n                .iter()\n                .flat_map(|(_, keys)| keys.iter())\n                .find(|k| k.key == api_key)\n            {\n                group_name_for_log.clone_from(\u0026found_key_info.group_name);\n            }\n\n            let now_utc = Utc::now();\n            let is_expired = key_state.reset_time.is_some_and(|rt| now_utc \u003e= rt);\n            if key_state.status != KeyStatus::Available \u0026\u0026 !is_expired {\n                debug!(key.status = ?key_state.status, \"Key already marked as limited. Ignoring.\");\n                return false;\n            }\n\n            warn!(group.name=%group_name_for_log, \"Marking key as rate-limited until midnight PST\");\n\n            // Always block until midnight PST (00:00 PST / 10:00 MSK)\n            let target_tz: Tz = Los_Angeles;\n            let now_in_target_tz = now_utc.with_timezone(\u0026target_tz);\n            let tomorrow_naive_target = (now_in_target_tz + ChronoDuration::days(1)).date_naive();\n            let reset_time_naive_target: NaiveDateTime = tomorrow_naive_target\n                .and_hms_opt(0, 0, 0)\n                .expect(\"Failed to calculate next midnight\");\n            let reset_time_utc = target_tz\n                .from_local_datetime(\u0026reset_time_naive_target)\n                .single()\n                .expect(\"Timezone conversion failed\")\n                .with_timezone(\u0026Utc);\n            key_state.status = KeyStatus::RateLimited;\n            key_state.reset_time = Some(reset_time_utc);\n            true\n        } else {\n            error!(\"Attempted to mark an unknown API key as limited!\");\n            false\n        }\n    }\n\n    #[tracing::instrument(level = \"warn\", skip(self, api_key), fields(api_key.preview = %Self::preview(api_key)))]\n    pub fn mark_key_as_invalid(\u0026mut self, api_key: \u0026str) -\u003e bool {\n        if let Some(key_state) = self.key_states.get_mut(api_key) {\n            if key_state.status != KeyStatus::Invalid {\n                warn!(\"Marking key as permanently invalid\");\n                key_state.status = KeyStatus::Invalid;\n                key_state.reset_time = None;\n                return true;\n            }\n        } else {\n            error!(\"Attempted to mark an unknown API key as invalid!\");\n        }\n        false\n    }\n\n    #[tracing::instrument(level = \"warn\", skip(self, api_key), fields(api_key.preview = %Self::preview(api_key)))]\n    pub fn mark_key_as_temporarily_unavailable(\n        \u0026mut self,\n        api_key: \u0026str,\n        duration: ChronoDuration,\n    ) -\u003e bool {\n        if let Some(key_state) = self.key_states.get_mut(api_key) {\n            let reset_time = Utc::now() + duration;\n            warn!(?duration, %reset_time, \"Marking key as temporarily unavailable\");\n            key_state.status = KeyStatus::TemporarilyUnavailable;\n            key_state.reset_time = Some(reset_time);\n            true\n        } else {\n            error!(\"Attempted to mark an unknown API key as temporarily unavailable!\");\n            false\n        }\n    }\n\n    /// Asynchronously saves the current state of the KeyManager.\n    #[tracing::instrument(level = \"debug\", skip(self))]\n    pub async fn save_states(\u0026self) -\u003e AppResult\u003c()\u003e {\n        let _save_guard = self.save_mutex.lock().await;\n        debug!(key_state.path = %self.state_file_path.display(), \"Acquired save mutex lock for save\");\n\n        Self::save_states_to_file_impl(\u0026self.state_file_path, \u0026self.key_states)\n            .await\n            .map_err(|io_err| {\n                error!(key_state.path = %self.state_file_path.display(), error = ?io_err, \"Save states failed\");\n                AppError::Io(io_err)\n            })\n    }\n\n    /// Implementation detail: Performs the atomic save operation.\n    #[tracing::instrument(level = \"debug\", skip(final_path, states), fields(key_state.path = %final_path.display(), state.count = states.len()))]\n    async fn save_states_to_file_impl(\n        final_path: \u0026Path,\n        states: \u0026HashMap\u003cString, KeyState\u003e,\n    ) -\u003e std_io::Result\u003c()\u003e {\n        debug!(\"Attempting atomic save\");\n        let parent_dir = final_path.parent().ok_or_else(|| {\n            std_io::Error::new(\n                std_io::ErrorKind::InvalidInput,\n                \"State file path has no parent directory\",\n            )\n        })?;\n        async_fs::create_dir_all(parent_dir).await?;\n\n        let base_filename = final_path.file_name().unwrap_or_default().to_string_lossy();\n        let temp_filename = format!(\".{}.{}.tmp\", base_filename, Uuid::new_v4());\n        let temp_path = parent_dir.join(\u0026temp_filename);\n\n        let json_data = serde_json::to_string_pretty(states).map_err(|e| {\n            std_io::Error::new(\n                std_io::ErrorKind::InvalidData,\n                format!(\"Failed to serialize key states: {e}\"),\n            )\n        })?;\n\n        async_fs::write(\u0026temp_path, json_data.as_bytes()).await?;\n        async_fs::copy(\u0026temp_path, final_path).await?;\n        async_fs::remove_file(\u0026temp_path).await?;\n\n        info!(\"Successfully saved key states atomically\");\n        Ok(())\n    }\n\n    /// Generates a shortened preview of an API key for logging.\n    #[inline]\n    fn preview(key: \u0026str) -\u003e String {\n        let len = key.chars().count();\n        let end = std::cmp::min(6, len);\n        let start = if len \u003e 10 { len - 4 } else { len };\n        if len \u003e 10 {\n            format!(\n                \"{}...{}\",\n                key.chars().take(end).collect::\u003cString\u003e(),\n                key.chars().skip(start).collect::\u003cString\u003e()\n            )\n        } else {\n            format!(\"{}...\", key.chars().take(end).collect::\u003cString\u003e())\n        }\n    }\n\n    pub fn get_key_states(\u0026self) -\u003e \u0026HashMap\u003cString, KeyState\u003e {\n        \u0026self.key_states\n    }\n\n    /// Get mutable access to key states (for testing)\n    pub fn get_key_states_mut(\u0026mut self) -\u003e \u0026mut HashMap\u003cString, KeyState\u003e {\n        \u0026mut self.key_states\n    }\n\n    /// Provides a flattened list of all key info for admin/debug purposes.\n    pub fn get_all_key_info(\u0026self) -\u003e Vec\u003cFlattenedKeyInfo\u003e {\n        self.key_id_map.values().cloned().collect()\n    }\n\n    pub fn is_key_invalid(\u0026self, api_key: \u0026str) -\u003e bool {\n        self.key_states\n            .get(api_key)\n            .is_some_and(|s| s.status == KeyStatus::Invalid)\n    }\n\n    /// Cleans up expired model blocks for all keys\n    #[tracing::instrument(level = \"debug\", skip(self))]\n    pub fn cleanup_expired_model_blocks(\u0026mut self) -\u003e usize {\n        let now = Utc::now();\n        let mut cleaned_count = 0;\n\n        for (api_key, key_state) in self.key_states.iter_mut() {\n            let mut models_to_remove = Vec::new();\n\n            for (model, block_state) in \u0026key_state.model_blocks {\n                if now \u003e= block_state.blocked_until {\n                    models_to_remove.push(model.clone());\n                }\n            }\n\n            for model in models_to_remove {\n                key_state.model_blocks.remove(\u0026model);\n                cleaned_count += 1;\n                info!(\n                    api_key.preview = %Self::preview(api_key),\n                    model = %model,\n                    \"Unblocked key for model - quota reset time reached\"\n                );\n            }\n        }\n\n        if cleaned_count \u003e 0 {\n            info!(\n                cleaned_blocks = cleaned_count,\n                \"Cleaned up expired model blocks\"\n            );\n        }\n\n        cleaned_count\n    }\n\n    pub(crate) fn reset_key_state_to_available(\u0026mut self, api_key: \u0026str) -\u003e bool {\n        if let Some(key_state) = self.key_states.get_mut(api_key) {\n            let mut changed = false;\n\n            if key_state.status != KeyStatus::Available || key_state.reset_time.is_some() {\n                info!(api_key.preview = %Self::preview(api_key), \"Resetting key status to Available\");\n                key_state.status = KeyStatus::Available;\n                key_state.reset_time = None;\n                changed = true;\n            }\n\n            // Also clear all model blocks\n            if !key_state.model_blocks.is_empty() {\n                info!(\n                    api_key.preview = %Self::preview(api_key),\n                    blocked_models = key_state.model_blocks.len(),\n                    \"Clearing all model blocks for key\"\n                );\n                key_state.model_blocks.clear();\n                changed = true;\n            }\n\n            changed\n        } else {\n            false\n        }\n    }\n\n    #[tracing::instrument(level = \"info\", skip(self), fields(key.id = %key_id))]\n    pub fn reset_key_status(\u0026mut self, key_id: \u0026str) -\u003e bool {\n        if let Some(key_info) = self.key_id_map.get(key_id) {\n            let key_to_reset = key_info.key.clone();\n            self.reset_key_state_to_available(\u0026key_to_reset)\n        } else {\n            warn!(\"Could not find key with ID '{}' to reset\", key_id);\n            false\n        }\n    }\n\n    /// Finds key info by its MD5 hash ID. Used to fetch data under a read lock.\n    pub fn get_key_info_by_id(\u0026self, key_id: \u0026str) -\u003e Option\u003c\u0026FlattenedKeyInfo\u003e {\n        self.key_id_map.get(key_id)\n    }\n\n    /// Gets statistics about model-specific blocks\n    pub fn get_model_block_stats(\u0026self) -\u003e HashMap\u003cString, usize\u003e {\n        let mut stats = HashMap::new();\n        let now = Utc::now();\n\n        for key_state in self.key_states.values() {\n            for (model, block_state) in \u0026key_state.model_blocks {\n                if now \u003c block_state.blocked_until {\n                    *stats.entry(model.clone()).or_insert(0) += 1;\n                }\n            }\n        }\n\n        stats\n    }\n\n    /// Gets all currently blocked models with their block counts\n    pub fn get_blocked_models_info(\u0026self) -\u003e Vec\u003c(String, usize, DateTime\u003cUtc\u003e)\u003e {\n        let mut model_info = HashMap::new();\n        let now = Utc::now();\n\n        for key_state in self.key_states.values() {\n            for (model, block_state) in \u0026key_state.model_blocks {\n                if now \u003c block_state.blocked_until {\n                    let entry = model_info\n                        .entry(model.clone())\n                        .or_insert((0, block_state.blocked_until));\n                    entry.0 += 1;\n                    // Keep the earliest reset time\n                    if block_state.blocked_until \u003c entry.1 {\n                        entry.1 = block_state.blocked_until;\n                    }\n                }\n            }\n        }\n\n        model_info\n            .into_iter()\n            .map(|(model, (count, reset_time))| (model, count, reset_time))\n            .collect()\n    }\n\n    #[tracing::instrument(level = \"info\", skip(self, client, api_key), fields(api_key.preview = %Self::preview(api_key)))]\n    pub async fn perform_key_verification(\n        \u0026self,\n        api_key: \u0026str,\n        target_url_base: \u0026str,\n        client: \u0026Client,\n    ) -\u003e std::result::Result\u003cString, (StatusCode, String)\u003e {\n        info!(\"Verifying key with Gemini API\");\n\n        // Construct the full URL for verification\n        let target_url =\n            format!(\"{target_url_base}/v1beta/models/gemini-pro:generateContent?key={api_key}\");\n\n        let request_body = serde_json::json!({\n            \"contents\": [{\"parts\":[ {\"text\": \"Hi\"}]}]\n        });\n\n        match client\n            .post(\u0026target_url)\n            .header(CONTENT_TYPE, \"application/json\")\n            .json(\u0026request_body)\n            .send()\n            .await\n        {\n            Ok(response) =\u003e {\n                let status = response.status();\n                let text = response\n                    .text()\n                    .await\n                    .unwrap_or_else(|_| \"Could not read response body\".to_string());\n                if status.is_success() {\n                    info!(api_key.preview = %Self::preview(api_key), \"Key verification successful\");\n                    Ok(text)\n                } else {\n                    warn!(\n                        api_key.preview = %Self::preview(api_key),\n                        %status,\n                        error.body = %text,\n                        \"Key verification failed with non-success status\"\n                    );\n                    Err((status, text))\n                }\n            }\n            Err(e) =\u003e {\n                error!(api_key.preview = %Self::preview(api_key), error = ?e, \"Network or other error during key verification\");\n                Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))\n            }\n        }\n    }\n\n    #[tracing::instrument(level = \"info\", skip(self, verification_result), fields(api_key.preview = %Self::preview(api_key)))]\n    pub fn update_key_status_from_verification(\n        \u0026mut self,\n        api_key: \u0026str,\n        verification_result: std::result::Result\u003cString, (StatusCode, String)\u003e,\n    ) -\u003e bool {\n        match verification_result {\n            Ok(_) =\u003e self.reset_key_state_to_available(api_key),\n            Err((status, _)) =\u003e {\n                if status.is_server_error() || status == StatusCode::REQUEST_TIMEOUT {\n                    self.mark_key_as_temporarily_unavailable(api_key, ChronoDuration::minutes(5))\n                } else {\n                    self.mark_key_as_invalid(api_key)\n                }\n            }\n        }\n    }\n}\n/// Helper function to load key states from the JSON file, with recovery attempt from temp file.\n#[tracing::instrument(level = \"info\", skip(path), fields(key_state.path = %path.display()))]\nasync fn load_key_states_from_file(path: \u0026Path) -\u003e HashMap\u003cString, KeyState\u003e {\n    let base_filename = path.file_name().unwrap_or_default().to_string_lossy();\n    let parent_dir = path.parent().unwrap_or_else(|| Path::new(\".\"));\n    let path_display = path.display().to_string(); // Capture display string\n\n    let mut recovered_from_temp = false;\n    let mut recovered_states = HashMap::new();\n\n    match async_fs::read_to_string(path).await {\n        Ok(json_data) =\u003e {\n            // Attempt to clean up any old temp files on successful load\n            cleanup_temp_files(parent_dir, \u0026base_filename).await;\n            match serde_json::from_str::\u003cHashMap\u003cString, KeyState\u003e\u003e(\u0026json_data) {\n                Ok(states) =\u003e {\n                    info!(state.count = states.len(), \"Successfully loaded key states\");\n                    return states;\n                }\n                Err(e) =\u003e {\n                    error!(error = %e, \"Failed to parse key state file (JSON invalid). Attempting recovery.\");\n                }\n            }\n        }\n        Err(ref e) if e.kind() == std_io::ErrorKind::NotFound =\u003e {\n            // This is not an error, just information\n            info!(\"Key state file not found. Checking for temporary recovery file.\");\n        }\n        Err(e) =\u003e {\n            // Log actual IO errors\n            error!(error = %e, \"Failed to read key state file due to IO error. Attempting recovery.\");\n        }\n    }\n\n    // Attempt recovery from temp file if main file failed or not found\n    if let Some(temp_path) = find_latest_temp_file(parent_dir, \u0026base_filename).await {\n        let temp_path_display = temp_path.display().to_string(); // Capture display string\n        warn!(temp_file.path = %temp_path_display, \"Attempting recovery from temporary state file.\");\n        match async_fs::read_to_string(\u0026temp_path).await {\n            Ok(temp_json_data) =\u003e {\n                match serde_json::from_str::\u003cHashMap\u003cString, KeyState\u003e\u003e(\u0026temp_json_data) {\n                    Ok(states) =\u003e {\n                        info!(state.count = states.len(), temp_file.path = %temp_path_display, \"Successfully recovered key states from temporary file\");\n                        // Attempt to copy recovered file to main path\n                        if let Err(copy_err) = async_fs::copy(\u0026temp_path, path).await {\n                            error!(\n                                temp_file.path = %temp_path_display,\n                                final_file.path = %path_display,\n                                error = ?copy_err,\n                                \"Failed to copy recovered temp state file to main path. State recovered in memory, but file system may be inconsistent.\"\n                            );\n                        } else {\n                            info!(final_file.path = %path_display, \"Successfully copied recovered temp state file to main path.\");\n                            if let Err(rm_err) = async_fs::remove_file(\u0026temp_path).await {\n                                warn!(temp_file.path = %temp_path_display, error = ?rm_err, \"Failed to remove temporary file after successful recovery.\");\n                            }\n                            // Clean up potentially other old temp files after successful copy\n                            cleanup_temp_files(parent_dir, \u0026base_filename).await;\n                        }\n                        recovered_from_temp = true;\n                        recovered_states = states; // Store recovered states\n                    }\n                    Err(parse_e) =\u003e {\n                        error!(temp_file.path = %temp_path_display, error = %parse_e, \"Failed to parse temporary key state file (JSON invalid). Recovery failed.\");\n                        // Attempt to remove corrupt temp file\n                        if let Err(rm_err) = async_fs::remove_file(\u0026temp_path).await {\n                            warn!(temp_file.path = %temp_path_display, error = ?rm_err, \"Failed to remove corrupt temporary file after parse failure\");\n                        }\n                        recovered_states = HashMap::new(); // Ensure empty map on parse failure\n                    }\n                }\n            }\n            Err(read_e) =\u003e {\n                error!(temp_file.path = %temp_path_display, error = %read_e, \"Failed to read temporary key state file. Recovery failed.\");\n                // Attempt to remove unreadable temp file\n                if let Err(rm_err) = async_fs::remove_file(\u0026temp_path).await {\n                    warn!(temp_file.path = %temp_path_display, error = ?rm_err, \"Failed to remove unreadable temporary file\");\n                }\n                recovered_states = HashMap::new(); // Ensure empty map on read failure\n            }\n        }\n    } else {\n        info!(\"No temporary state file found for recovery.\");\n    }\n\n    // Return recovered states if successful, otherwise empty map\n    if recovered_from_temp {\n        recovered_states\n    } else {\n        warn!(\"Recovery failed or no file found. Starting with empty key states.\");\n        HashMap::new()\n    }\n}\n\n/// Finds the most recently modified temporary state file matching the pattern.\n#[tracing::instrument(level = \"debug\", skip(temp_dir, base_filename))]\nasync fn find_latest_temp_file(temp_dir: \u0026Path, base_filename: \u0026str) -\u003e Option\u003cPathBuf\u003e {\n    let mut latest_mod_time: Option\u003cstd::time::SystemTime\u003e = None;\n    let mut latest_temp_file: Option\u003cPathBuf\u003e = None;\n    let temp_prefix = format!(\".{base_filename}.\");\n    let temp_suffix = \".tmp\";\n    debug!(temp_file.prefix = %temp_prefix, temp_file.suffix = %temp_suffix, directory = %temp_dir.display(), \"Searching for latest temporary file\");\n\n    if let Ok(mut read_dir) = async_fs::read_dir(temp_dir).await {\n        while let Ok(Some(entry)) = read_dir.next_entry().await {\n            let path = entry.path();\n            if path.is_file() {\n                if let Some(filename) = path.file_name().map(|n| n.to_string_lossy()) {\n                    if filename.starts_with(\u0026temp_prefix) \u0026\u0026 filename.ends_with(temp_suffix) {\n                        debug!(temp_file.path = %path.display(), \"Found potential temporary file\");\n                        if let Ok(metadata) = entry.metadata().await {\n                            if let Ok(modified) = metadata.modified() {\n                                if latest_mod_time.is_none() || modified \u003e latest_mod_time.unwrap()\n                                {\n                                    debug!(temp_file.path = %path.display(), ?modified, \"Updating latest temporary file\");\n                                    latest_mod_time = Some(modified);\n                                    latest_temp_file = Some(path.clone());\n                                }\n                            } else {\n                                warn!(temp_file.path = %path.display(), \"Could not get modified time for temp file\");\n                            }\n                        } else {\n                            warn!(temp_file.path = %path.display(), \"Could not get metadata for temp file\");\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        warn!(directory = %temp_dir.display(), \"Could not read directory to find temp files\");\n    }\n\n    if let Some(ref p) = latest_temp_file {\n        debug!(temp_file.path = %p.display(), \"Found latest temporary file\");\n    } else {\n        debug!(\"No suitable temporary file found\");\n    }\n    latest_temp_file\n}\n\n/// Cleans up all temporary state files matching the pattern in a directory.\n#[tracing::instrument(level = \"debug\", skip(temp_dir, base_filename))]\nasync fn cleanup_temp_files(temp_dir: \u0026Path, base_filename: \u0026str) {\n    let temp_prefix = format!(\".{base_filename}.\");\n    let temp_suffix = \".tmp\";\n\n    debug!(temp_file.prefix = %temp_prefix, temp_file.suffix = %temp_suffix, directory = %temp_dir.display(), \"Cleaning up temporary files\");\n    let mut cleaned_count = 0;\n\n    if let Ok(mut read_dir) = async_fs::read_dir(temp_dir).await {\n        while let Ok(Some(entry)) = read_dir.next_entry().await {\n            let path = entry.path();\n            if path.is_file() {\n                if let Some(filename) = path.file_name().map(|n| n.to_string_lossy()) {\n                    if filename.starts_with(\u0026temp_prefix) \u0026\u0026 filename.ends_with(temp_suffix) {\n                        warn!(temp_file.path = %path.display(), \"Cleaning up leftover temporary state file.\");\n                        if let Err(e) = async_fs::remove_file(\u0026path).await {\n                            error!(temp_file.path = %path.display(), error = ?e, \"Failed during cleanup of temporary state file.\");\n                        } else {\n                            cleaned_count += 1;\n                            debug!(temp_file.path = %path.display(), \"Successfully cleaned up temporary file.\");\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        warn!(directory = %temp_dir.display(), \"Could not read directory to clean temp files\");\n    }\n    debug!(cleaned_count, \"Temporary file cleanup finished\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{KeyGroup, ServerConfig};\n    use std::fs::{self as sync_fs, File};\n    use std::io::Write;\n    use std::path::PathBuf;\n    use std::time::Duration;\n    use tempfile::tempdir;\n    use tokio::time::sleep;\n\n    fn create_test_config(groups: Vec\u003cKeyGroup\u003e) -\u003e AppConfig {\n        AppConfig {\n            server: ServerConfig {\n                port: 8080,\n                top_p: None,\n                admin_token: None,\n            },\n            groups,\n\n            internal_retries: 2,\n            temporary_block_minutes: 5,\n        }\n    }\n\n    fn create_temp_yaml_config(dir: \u0026tempfile::TempDir) -\u003e PathBuf {\n        let file_path = dir.path().join(\"test_config.yaml\");\n        let content = r#\"\n server:\n   port: 8080\n # No groups needed here, KeyManager uses AppConfig directly\n \"#;\n        let mut file = File::create(\u0026file_path).unwrap();\n        writeln!(file, \"{content}\").unwrap();\n        file_path\n    }\n\n    // Helper to get the internal state for verification\n    // async fn get_manager_indices(manager: \u0026KeyManager) -\u003e (usize, Vec\u003cusize\u003e) {\n    //    let group_idx = manager.current_group_index.load(Ordering::Relaxed);\n    //    let key_indices = manager.key_indices_per_group.iter().map(|a| a.load(Ordering::Relaxed)).collect();\n    //    (group_idx, key_indices)\n    // }\n\n    #[tokio::test]\n    async fn test_key_manager_initialization_loads_persisted_state() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let state_path = dir.path().join(\"key_states.json\");\n\n        let future_reset = Utc::now() + ChronoDuration::hours(1);\n        let past_reset = Utc::now() - ChronoDuration::hours(1);\n        let persisted_states: HashMap\u003cString, KeyState\u003e = [\n            (\n                \"key_limited\".to_string(),\n                KeyState {\n                    status: KeyStatus::RateLimited,\n                    reset_time: Some(future_reset),\n                    model_blocks: HashMap::new(),\n                },\n            ),\n            (\n                \"key_expired\".to_string(),\n                KeyState {\n                    status: KeyStatus::RateLimited,\n                    reset_time: Some(past_reset),\n                    model_blocks: HashMap::new(),\n                },\n            ),\n            (\n                \"key_nolimit\".to_string(),\n                KeyState {\n                    status: KeyStatus::Available,\n                    reset_time: None,\n                    model_blocks: HashMap::new(),\n                },\n            ),\n            (\n                \"key_not_in_config\".to_string(),\n                KeyState {\n                    status: KeyStatus::Invalid,\n                    reset_time: None,\n                    model_blocks: HashMap::new(),\n                },\n            ),\n        ]\n        .iter()\n        .cloned()\n        .collect();\n        let json_data = serde_json::to_string(\u0026persisted_states).unwrap();\n        sync_fs::write(\u0026state_path, json_data).unwrap();\n\n        let groups = vec![KeyGroup {\n            name: \"g1\".to_string(),\n            api_keys: vec![\n                \"key_limited\".to_string(),\n                \"key_expired\".to_string(),\n                \"key_nolimit\".to_string(),\n                \"key_new\".to_string(),\n            ],\n            proxy_url: None,\n            target_url: \"t1\".to_string(),\n            top_p: None,\n        }];\n        let config = create_test_config(groups);\n        let manager = KeyManager::new(\u0026config, \u0026config_path).await;\n        let final_states = \u0026manager.key_states;\n\n        assert_eq!(final_states.len(), 4);\n        assert_eq!(final_states[\"key_limited\"].status, KeyStatus::RateLimited);\n        assert_eq!(final_states[\"key_limited\"].reset_time, Some(future_reset));\n        assert_eq!(final_states[\"key_expired\"].status, KeyStatus::Available);\n        assert!(final_states[\"key_expired\"].reset_time.is_none());\n        assert_eq!(final_states[\"key_nolimit\"].status, KeyStatus::Available);\n        assert!(final_states[\"key_nolimit\"].reset_time.is_none());\n        assert!(final_states.contains_key(\"key_new\"));\n        assert_eq!(final_states[\"key_new\"].status, KeyStatus::Available);\n        assert!(final_states[\"key_new\"].reset_time.is_none());\n        assert!(!final_states.contains_key(\"key_not_in_config\"));\n        assert_eq!(manager.state_file_path, state_path);\n    }\n\n    #[tokio::test]\n    async fn test_mark_key_as_limited_saves_state_atomically() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let state_path = dir.path().join(\"key_states.json\");\n        File::create(\u0026state_path)\n            .unwrap()\n            .write_all(b\"initial_content\")\n            .unwrap();\n        let groups = vec![KeyGroup {\n            name: \"g1\".to_string(),\n            api_keys: vec![\"k1\".to_string(), \"k2\".to_string()],\n            proxy_url: None,\n            target_url: \"t1\".to_string(),\n            top_p: None,\n        }];\n        let config = create_test_config(groups);\n        let mut manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n        sleep(Duration::from_millis(50)).await;\n        let initial_saved_json =\n            sync_fs::read_to_string(\u0026state_path).expect(\"State file should exist after init\");\n        let initial_saved_states: HashMap\u003cString, KeyState\u003e =\n            serde_json::from_str(\u0026initial_saved_json).expect(\"Should parse initial JSON\");\n        assert_eq!(initial_saved_states.len(), 2);\n\n        manager.mark_key_as_limited(\"k1\");\n        manager.save_states().await.unwrap(); // Explicitly save for test\n\n        let saved_json =\n            sync_fs::read_to_string(\u0026state_path).expect(\"State file should exist after save\");\n        let saved_states: HashMap\u003cString, KeyState\u003e =\n            serde_json::from_str(\u0026saved_json).expect(\"Should parse saved JSON\");\n\n        assert_eq!(saved_states.len(), 2);\n        assert_eq!(saved_states[\"k1\"].status, KeyStatus::RateLimited);\n        assert!(saved_states[\"k1\"].reset_time.is_some());\n        assert!(saved_states[\"k1\"].reset_time.unwrap() \u003e Utc::now() - ChronoDuration::seconds(1)); // Check it's recent\n        assert_eq!(saved_states[\"k2\"].status, KeyStatus::Available);\n\n        let base_filename = state_path.file_name().unwrap().to_string_lossy();\n        let mut found_temp = false;\n        for entry in sync_fs::read_dir(dir.path()).unwrap() {\n            let path = entry.unwrap().path();\n            if path.is_file() {\n                if let Some(filename) = path.file_name().map(|n| n.to_string_lossy()) {\n                    if filename.starts_with(\u0026format!(\".{base_filename}.\"))\n                        \u0026\u0026 filename.ends_with(\".tmp\")\n                    {\n                        error!(\"Found unexpected temp file: {}\", path.display());\n                        found_temp = true;\n                    }\n                }\n            }\n        }\n        assert!(\n            !found_temp,\n            \"Temporary state file should not exist after successful save\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_get_next_key_skips_persisted_limited_key() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let state_path = dir.path().join(\"key_states.json\");\n        let future_reset = Utc::now() + ChronoDuration::hours(1);\n        let persisted: HashMap\u003cString, KeyState\u003e = [(\n            \"k1\".to_string(),\n            KeyState {\n                status: KeyStatus::RateLimited,\n                reset_time: Some(future_reset),\n                model_blocks: HashMap::new(),\n            },\n        )]\n        .iter()\n        .cloned()\n        .collect();\n        sync_fs::write(\u0026state_path, serde_json::to_string(\u0026persisted).unwrap()).unwrap();\n\n        let groups = vec![KeyGroup {\n            name: \"g1\".to_string(),\n            api_keys: vec![\"k1\".to_string(), \"k2\".to_string()],\n            proxy_url: None,\n            target_url: \"t1\".to_string(),\n            top_p: None,\n        }];\n        let config = create_test_config(groups);\n        let manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n        let key_info1 = manager.get_next_available_key_info().unwrap();\n        assert_eq!(key_info1.key, \"k2\"); // Should skip k1\n        let key_info2 = manager.get_next_available_key_info().unwrap();\n        assert_eq!(key_info2.key, \"k2\"); // Should loop back to k2 as k1 is still limited\n    }\n\n    #[tokio::test]\n    async fn test_initial_save_syncs_state_after_loading() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let state_path = dir.path().join(\"key_states.json\");\n\n        // State file with an expired key and a key not in the new config\n        let past_reset = Utc::now() - ChronoDuration::hours(1);\n        let persisted: HashMap\u003cString, KeyState\u003e = [\n            (\n                \"k1_expired\".to_string(),\n                KeyState {\n                    status: KeyStatus::RateLimited,\n                    reset_time: Some(past_reset),\n                    model_blocks: HashMap::new(),\n                },\n            ),\n            (\n                \"k2_stale\".to_string(),\n                KeyState {\n                    status: KeyStatus::Available,\n                    reset_time: None,\n                    model_blocks: HashMap::new(),\n                },\n            ),\n        ]\n        .iter()\n        .cloned()\n        .collect();\n        sync_fs::write(\u0026state_path, serde_json::to_string(\u0026persisted).unwrap()).unwrap();\n\n        // New config only has k1_expired and a new key k3\n        let groups = vec![KeyGroup {\n            name: \"g1\".to_string(),\n            api_keys: vec![\"k1_expired\".to_string(), \"k3_new\".to_string()],\n            proxy_url: None,\n            target_url: \"t1\".to_string(),\n            top_p: None,\n        }];\n        let config = create_test_config(groups);\n\n        // Init manager - this should trigger an initial save\n        let _manager = KeyManager::new(\u0026config, \u0026config_path).await;\n        sleep(Duration::from_millis(250)).await; // Wait for async save\n\n        // Read the file back and check its contents\n        let final_json = sync_fs::read_to_string(\u0026state_path).unwrap();\n        let final_states: HashMap\u003cString, KeyState\u003e = serde_json::from_str(\u0026final_json).unwrap();\n\n        // The final saved state should reflect the cleanup:\n        // - k1_expired should be Available because its timer expired on load.\n        // - k2_stale should be removed because it's not in the new config.\n        // - k3_new should be added as Available.\n        assert_eq!(final_states.len(), 2);\n        assert!(final_states.contains_key(\"k1_expired\"));\n        assert!(final_states.contains_key(\"k3_new\"));\n        assert!(!final_states.contains_key(\"k2_stale\"));\n        assert_eq!(final_states[\"k1_expired\"].status, KeyStatus::Available);\n        assert!(final_states[\"k1_expired\"].reset_time.is_none());\n        assert_eq!(final_states[\"k3_new\"].status, KeyStatus::Available);\n    }\n\n    #[tokio::test]\n    async fn test_get_next_key_group_round_robin() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let groups = vec![\n            KeyGroup {\n                name: \"g1\".to_string(),\n                api_keys: vec![\"g1k1\".to_string(), \"g1k2\".to_string()],\n                proxy_url: None,\n                target_url: \"t1\".to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g2\".to_string(),\n                api_keys: vec![\"g2k1\".to_string()],\n                proxy_url: None,\n                target_url: \"t2\".to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g3\".to_string(),\n                api_keys: vec![\"g3k1\".to_string(), \"g3k2\".to_string(), \"g3k3\".to_string()],\n                proxy_url: None,\n                target_url: \"t3\".to_string(),\n                top_p: None,\n            },\n        ];\n        let config = create_test_config(groups);\n        let manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n        // Expected sequence: g1k1, g2k1, g3k1, g1k2, g2k1 (loops), g3k2, g1k1 (loops), ...\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g1k1\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g2k1\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g3k1\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g1k2\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g2k1\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g3k2\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g1k1\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g2k1\");\n        assert_eq!(manager.get_next_available_key_info().unwrap().key, \"g3k3\");\n    }\n\n    #[tokio::test]\n    async fn test_get_next_key_skips_limited_keys_and_groups() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let groups = vec![\n            KeyGroup {\n                name: \"g1\".to_string(),\n                api_keys: vec![\"g1k1\".to_string(), \"g1k2\".to_string()],\n                proxy_url: None,\n                target_url: \"t1\".to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g2\".to_string(),\n                api_keys: vec![\"g2k1\".to_string()],\n                proxy_url: None,\n                target_url: \"t2\".to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g3\".to_string(),\n                api_keys: vec![\"g3k1\".to_string()],\n                proxy_url: None,\n                target_url: \"t3\".to_string(),\n                top_p: None,\n            },\n        ];\n        let config = create_test_config(groups);\n        // Behavior is now always block until midnight PST\n        let mut manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n        // Limit g1k1 and all of g2\n        manager.mark_key_as_limited(\"g1k1\");\n        manager.mark_key_as_limited(\"g2k1\");\n        sleep(Duration::from_millis(50)).await; // allow state to be saved\n\n        // Expected sequence: g1k2 (starts at g1, skips g1k1), g3k1 (skips g2), g1k2 (wraps around)\n        assert_eq!(\n            manager.get_next_available_key_info().unwrap().key,\n            \"g1k2\",\n            \"Should select g1k2 first\"\n        );\n        assert_eq!(\n            manager.get_next_available_key_info().unwrap().key,\n            \"g3k1\",\n            \"Should select g3k1 after skipping g2\"\n        );\n        assert_eq!(\n            manager.get_next_available_key_info().unwrap().key,\n            \"g1k2\",\n            \"Should wrap around and select g1k2 again\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_get_next_key_returns_none_when_all_limited() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let groups = vec![\n            KeyGroup {\n                name: \"g1\".to_string(),\n                api_keys: vec![\"g1k1\".to_string()],\n                proxy_url: None,\n                target_url: \"t1\".to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g2\".to_string(),\n                api_keys: vec![\"g2k1\".to_string()],\n                proxy_url: None,\n                target_url: \"t2\".to_string(),\n                top_p: None,\n            },\n        ];\n        let config = create_test_config(groups);\n        // Behavior is now always block until midnight PST\n        let mut manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n        manager.mark_key_as_limited(\"g1k1\");\n        manager.mark_key_as_limited(\"g2k1\");\n        sleep(Duration::from_millis(250)).await;\n\n        assert!(\n            manager.get_next_available_key_info().is_none(),\n            \"Should return None when all keys are limited\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_load_recovers_from_temp_file() {\n        let dir = tempdir().unwrap();\n        let final_path = dir.path().join(\"key_states.json\");\n        let base_filename = final_path.file_name().unwrap().to_string_lossy();\n        let temp_filename = format!(\".{}.{}.tmp\", base_filename, Uuid::new_v4());\n        let temp_path = dir.path().join(temp_filename);\n\n        let expected_states: HashMap\u003cString, KeyState\u003e =\n            [(\"recovered_key\".to_string(), KeyState::default())]\n                .iter()\n                .cloned()\n                .collect();\n        let json_data = serde_json::to_string(\u0026expected_states).unwrap();\n        sync_fs::write(\u0026temp_path, json_data).unwrap();\n\n        // Ensure final file does not exist\n        let _ = sync_fs::remove_file(\u0026final_path);\n\n        let loaded_states = load_key_states_from_file(\u0026final_path).await;\n\n        assert_eq!(loaded_states, expected_states);\n        assert!(\n            final_path.exists(),\n            \"Final file should be created from temp file\"\n        );\n        assert!(\n            !temp_path.exists(),\n            \"Temp file should be removed after successful recovery\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_load_does_not_recover_from_corrupted_temp_file() {\n        let dir = tempdir().unwrap();\n        let final_path = dir.path().join(\"key_states.json\");\n        let base_filename = final_path.file_name().unwrap().to_string_lossy();\n        let temp_filename = format!(\".{}.{}.tmp\", base_filename, Uuid::new_v4());\n        let temp_path = dir.path().join(temp_filename);\n\n        // Write corrupted JSON\n        sync_fs::write(\u0026temp_path, \"{ not json }\").unwrap();\n\n        // Ensure final file does not exist\n        let _ = sync_fs::remove_file(\u0026final_path);\n\n        let loaded_states = load_key_states_from_file(\u0026final_path).await;\n\n        assert!(\n            loaded_states.is_empty(),\n            \"Should return empty map on recovery failure\"\n        );\n        assert!(\n            !final_path.exists(),\n            \"Final file should not be created on recovery failure\"\n        );\n        assert!(\n            !temp_path.exists(),\n            \"Corrupted temp file should be removed after failed recovery attempt\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_mark_key_as_limited_block_until_midnight() {\n        let dir = tempdir().unwrap();\n        let config_path = create_temp_yaml_config(\u0026dir);\n        let groups = vec![KeyGroup {\n            name: \"g1\".to_string(),\n            api_keys: vec![\"k1\".to_string()],\n            proxy_url: None,\n            target_url: \"t1\".to_string(),\n            top_p: None,\n        }];\n        let config = create_test_config(groups);\n        let mut manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n        manager.mark_key_as_limited(\"k1\");\n\n        let states = \u0026manager.key_states;\n        let key_state = states.get(\"k1\").unwrap();\n\n        assert_eq!(key_state.status, KeyStatus::RateLimited);\n        assert!(key_state.reset_time.is_some());\n        let reset_time = key_state.reset_time.unwrap();\n        assert!(reset_time \u003e Utc::now());\n        // Check that it's roughly 24h from now (could be less depending on time of day)\n        assert!(reset_time \u003c Utc::now() + ChronoDuration::hours(25));\n    }\n\n    // Test removed - behavior is now always block until midnight PST\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":168}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":138,"address":[],"length":0,"stats":{"Line":56}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":12}},{"line":182,"address":[],"length":0,"stats":{"Line":524}},{"line":185,"address":[],"length":0,"stats":{"Line":156}},{"line":186,"address":[],"length":0,"stats":{"Line":624}},{"line":187,"address":[],"length":0,"stats":{"Line":156}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":156}},{"line":234,"address":[],"length":0,"stats":{"Line":129}},{"line":235,"address":[],"length":0,"stats":{"Line":387}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":112}},{"line":245,"address":[],"length":0,"stats":{"Line":68}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":17}},{"line":255,"address":[],"length":0,"stats":{"Line":138}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":108}},{"line":266,"address":[],"length":0,"stats":{"Line":99}},{"line":270,"address":[],"length":0,"stats":{"Line":198}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":103}},{"line":282,"address":[],"length":0,"stats":{"Line":206}},{"line":283,"address":[],"length":0,"stats":{"Line":309}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":103}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":113}},{"line":309,"address":[],"length":0,"stats":{"Line":113}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":94}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":9}},{"line":333,"address":[],"length":0,"stats":{"Line":5}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":5}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":15}},{"line":350,"address":[],"length":0,"stats":{"Line":45}},{"line":355,"address":[],"length":0,"stats":{"Line":8}},{"line":356,"address":[],"length":0,"stats":{"Line":24}},{"line":358,"address":[],"length":0,"stats":{"Line":24}},{"line":359,"address":[],"length":0,"stats":{"Line":8}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":16}},{"line":363,"address":[],"length":0,"stats":{"Line":20}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":15}},{"line":415,"address":[],"length":0,"stats":{"Line":45}},{"line":417,"address":[],"length":0,"stats":{"Line":45}},{"line":418,"address":[],"length":0,"stats":{"Line":15}},{"line":421,"address":[],"length":0,"stats":{"Line":38}},{"line":422,"address":[],"length":0,"stats":{"Line":50}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":5}},{"line":459,"address":[],"length":0,"stats":{"Line":15}},{"line":461,"address":[],"length":0,"stats":{"Line":5}},{"line":462,"address":[],"length":0,"stats":{"Line":5}},{"line":463,"address":[],"length":0,"stats":{"Line":5}},{"line":464,"address":[],"length":0,"stats":{"Line":5}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":4}},{"line":478,"address":[],"length":0,"stats":{"Line":12}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":206}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":103}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":40}},{"line":541,"address":[],"length":0,"stats":{"Line":160}},{"line":542,"address":[],"length":0,"stats":{"Line":120}},{"line":543,"address":[],"length":0,"stats":{"Line":120}},{"line":544,"address":[],"length":0,"stats":{"Line":40}},{"line":545,"address":[],"length":0,"stats":{"Line":8}},{"line":547,"address":[],"length":0,"stats":{"Line":40}},{"line":548,"address":[],"length":0,"stats":{"Line":40}},{"line":551,"address":[],"length":0,"stats":{"Line":32}},{"line":555,"address":[],"length":0,"stats":{"Line":12}},{"line":556,"address":[],"length":0,"stats":{"Line":12}},{"line":560,"address":[],"length":0,"stats":{"Line":2}},{"line":561,"address":[],"length":0,"stats":{"Line":2}},{"line":565,"address":[],"length":0,"stats":{"Line":10}},{"line":566,"address":[],"length":0,"stats":{"Line":40}},{"line":569,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[],"length":0,"stats":{"Line":4}},{"line":571,"address":[],"length":0,"stats":{"Line":8}},{"line":572,"address":[],"length":0,"stats":{"Line":12}},{"line":577,"address":[],"length":0,"stats":{"Line":68}},{"line":578,"address":[],"length":0,"stats":{"Line":136}},{"line":579,"address":[],"length":0,"stats":{"Line":136}},{"line":581,"address":[],"length":0,"stats":{"Line":298}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":166}},{"line":585,"address":[],"length":0,"stats":{"Line":2}},{"line":586,"address":[],"length":0,"stats":{"Line":6}},{"line":590,"address":[],"length":0,"stats":{"Line":166}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":68}},{"line":602,"address":[],"length":0,"stats":{"Line":2}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":68}},{"line":611,"address":[],"length":0,"stats":{"Line":5}},{"line":612,"address":[],"length":0,"stats":{"Line":15}},{"line":615,"address":[],"length":0,"stats":{"Line":3}},{"line":616,"address":[],"length":0,"stats":{"Line":2}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":2}},{"line":641,"address":[],"length":0,"stats":{"Line":6}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":4}},{"line":652,"address":[],"length":0,"stats":{"Line":12}},{"line":656,"address":[],"length":0,"stats":{"Line":2}},{"line":657,"address":[],"length":0,"stats":{"Line":4}},{"line":658,"address":[],"length":0,"stats":{"Line":4}},{"line":660,"address":[],"length":0,"stats":{"Line":8}},{"line":661,"address":[],"length":0,"stats":{"Line":16}},{"line":662,"address":[],"length":0,"stats":{"Line":6}},{"line":663,"address":[],"length":0,"stats":{"Line":24}},{"line":668,"address":[],"length":0,"stats":{"Line":2}},{"line":672,"address":[],"length":0,"stats":{"Line":2}},{"line":673,"address":[],"length":0,"stats":{"Line":4}},{"line":674,"address":[],"length":0,"stats":{"Line":4}},{"line":676,"address":[],"length":0,"stats":{"Line":8}},{"line":677,"address":[],"length":0,"stats":{"Line":16}},{"line":679,"address":[],"length":0,"stats":{"Line":12}},{"line":680,"address":[],"length":0,"stats":{"Line":18}},{"line":681,"address":[],"length":0,"stats":{"Line":12}},{"line":682,"address":[],"length":0,"stats":{"Line":6}},{"line":684,"address":[],"length":0,"stats":{"Line":6}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":2}},{"line":693,"address":[],"length":0,"stats":{"Line":14}},{"line":698,"address":[],"length":0,"stats":{"Line":4}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":4}},{"line":754,"address":[],"length":0,"stats":{"Line":2}},{"line":755,"address":[],"length":0,"stats":{"Line":2}},{"line":756,"address":[],"length":0,"stats":{"Line":6}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":2}},{"line":767,"address":[],"length":0,"stats":{"Line":172}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":114}},{"line":872,"address":[],"length":0,"stats":{"Line":104}},{"line":907,"address":[],"length":0,"stats":{"Line":62}},{"line":918,"address":[],"length":0,"stats":{"Line":122}}],"covered":128,"coverable":214},{"path":["/","app","src","lib.rs"],"content":"// src/lib.rs\n\n// Declare modules that constitute the library's public API or internal structure\npub mod admin;\npub mod config;\npub mod error;\npub mod handler;\npub mod key_manager;\npub mod proxy;\npub mod state;\n\n// Re-export key types for easier use by the binary or tests\nuse axum::{\n    Router,\n    body::Body,\n    http::Request as AxumRequest,\n    middleware::{self, Next},\n    response::Response as AxumResponse,\n    routing::{any, get},\n};\nuse std::{path::PathBuf, sync::Arc, time::Instant};\nuse tower_cookies::CookieManagerLayer;\nuse tracing::{Instrument, Level, error, info, span};\nuse uuid::Uuid;\n\npub use config::AppConfig;\npub use error::{AppError, Result};\npub use state::AppState;\n\n/// Creates the main Axum router for the application.\npub fn create_router(state: Arc\u003cAppState\u003e) -\u003e Router {\n    Router::new()\n        .route(\"/health\", get(handler::health_check))\n        .merge(admin::admin_routes())\n        .route(\"/v1/*path\", any(handler::proxy_handler))\n        .route(\"/v1beta/*path\", any(handler::proxy_handler))\n        .route(\"/chat/*path\", any(handler::proxy_handler))\n        .route(\"/embeddings\", any(handler::proxy_handler))\n        .route(\"/models\", any(handler::proxy_handler))\n        .layer(CookieManagerLayer::new())\n        .with_state(state)\n}\n\n/// Middleware to add Request ID and trace requests.\nasync fn trace_requests(req: AxumRequest\u003cBody\u003e, next: Next) -\u003e AxumResponse {\n    let request_id = Uuid::new_v4();\n    let start_time = Instant::now();\n    let method = req.method().clone();\n    let path = req.uri().path().to_string();\n\n    let span = span!(\n        Level::INFO,\n        \"request\",\n        request_id = %request_id,\n        http.method = %method,\n        url.path = %path,\n    );\n\n    let response = next.run(req).instrument(span).await;\n    let elapsed = start_time.elapsed();\n\n    info!(\n        http.response.duration = ?elapsed,\n        http.status_code = response.status().as_u16(),\n        \"Finished processing request\"\n    );\n\n    response\n}\n\n/// The main application setup function, responsible for configuration, state initialization,\n/// and router creation.\n///\n/// # Errors\n///\n/// This function will return an error if:\n/// - Configuration loading or validation fails.\n/// - The application state (e.g., HTTP clients) cannot be initialized.\npub async fn run(\n    config_path_override: Option\u003cPathBuf\u003e,\n) -\u003e std::result::Result\u003c(Router, AppConfig), AppError\u003e {\n    // --- Configuration Path ---\n    let config_path = config_path_override.unwrap_or_else(|| {\n        std::env::var(\"CONFIG_PATH\").map_or_else(|_| PathBuf::from(\"config.yaml\"), PathBuf::from)\n    });\n\n    info!(\"Starting Gemini API Key Rotation Proxy...\");\n\n    let config_path_display = config_path.display().to_string();\n    if config_path.exists() {\n        info!(config.path = %config_path_display, \"Using configuration file\");\n    } else {\n        info!(config.path = %config_path_display, \"Optional configuration file not found. Using defaults and environment variables.\");\n    }\n\n    // --- Configuration Loading \u0026 Validation ---\n    let app_config = config::load_config(\u0026config_path).map_err(|e| {\n        error!(\n            config.path = %config_path_display,\n            error = ?e,\n            \"Failed to load or validate configuration. Exiting.\"\n        );\n        e\n    })?;\n\n    let total_keys: usize = app_config.groups.iter().map(|g| g.api_keys.len()).sum();\n    let group_names: Vec\u003cString\u003e = app_config.groups.iter().map(|g| g.name.clone()).collect();\n    info!(\n         config.groups.count = app_config.groups.len(),\n         config.groups.names = ?group_names,\n         config.total_keys = total_keys,\n         server.port = app_config.server.port,\n         \"Configuration loaded and validated successfully.\"\n    );\n\n    // --- Application State Initialization ---\n    let app_state = AppState::new(\u0026app_config, \u0026config_path)\n        .await\n        .map_err(|e| {\n            error!(\n                error = ?e,\n                \"Failed to initialize application state. Exiting.\"\n            );\n            e\n        })?;\n    let app_state = Arc::new(app_state);\n    // --- Router Setup ---\n    let app = create_router(app_state.clone()).layer(middleware::from_fn(trace_requests));\n\n    Ok((app, app_config))\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":20}},{"line":32,"address":[],"length":0,"stats":{"Line":20}},{"line":33,"address":[],"length":0,"stats":{"Line":60}},{"line":34,"address":[],"length":0,"stats":{"Line":40}},{"line":35,"address":[],"length":0,"stats":{"Line":60}},{"line":36,"address":[],"length":0,"stats":{"Line":60}},{"line":37,"address":[],"length":0,"stats":{"Line":60}},{"line":38,"address":[],"length":0,"stats":{"Line":60}},{"line":39,"address":[],"length":0,"stats":{"Line":60}},{"line":40,"address":[],"length":0,"stats":{"Line":40}},{"line":41,"address":[],"length":0,"stats":{"Line":40}},{"line":45,"address":[],"length":0,"stats":{"Line":81}},{"line":46,"address":[],"length":0,"stats":{"Line":54}},{"line":47,"address":[],"length":0,"stats":{"Line":54}},{"line":48,"address":[],"length":0,"stats":{"Line":81}},{"line":49,"address":[],"length":0,"stats":{"Line":81}},{"line":51,"address":[],"length":0,"stats":{"Line":54}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":162}},{"line":60,"address":[],"length":0,"stats":{"Line":81}},{"line":62,"address":[],"length":0,"stats":{"Line":27}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":27}},{"line":79,"address":[],"length":0,"stats":{"Line":24}},{"line":83,"address":[],"length":0,"stats":{"Line":36}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":36}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":91,"address":[],"length":0,"stats":{"Line":11}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":48}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":20}},{"line":107,"address":[],"length":0,"stats":{"Line":20}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":50},{"path":["/","app","src","main.rs"],"content":"// src/main.rs\n\nuse axum::serve;\nuse gemini_proxy_key_rotation_rust::{AppError, run};\nuse std::net::SocketAddr;\nuse tokio::net::TcpListener;\nuse tokio::signal;\nuse tracing::{error, info};\n\nasync fn shutdown_signal() {\n    let ctrl_c = async {\n        signal::ctrl_c()\n            .await\n            .expect(\"Failed to install Ctrl+C handler\");\n    };\n\n    #[cfg(unix)]\n    let terminate = async {\n        signal::unix::signal(signal::unix::SignalKind::terminate())\n            .expect(\"Failed to install signal handler\")\n            .recv()\n            .await;\n    };\n\n    #[cfg(not(unix))]\n    let terminate = std::future::pending::\u003c()\u003e();\n\n    tokio::select! {\n        () = ctrl_c =\u003e { info!(signal = \"Ctrl+C\", \"Received signal. Initiating graceful shutdown...\") },\n        () = terminate =\u003e { info!(signal = \"Terminate\", \"Received signal. Initiating graceful shutdown...\") },\n    }\n}\n\nuse tracing_subscriber::{EnvFilter, fmt, layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), AppError\u003e {\n    // --- Initialize Tracing (JSON format) ---\n    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n    let json_layer = fmt::layer()\n        .json()\n        .with_current_span(true)\n        .with_span_list(true);\n    tracing_subscriber::registry()\n        .with(env_filter)\n        .with(json_layer)\n        .init();\n\n    // The `run` function now configures the app and returns both the router and the config.\n    let (app, config) = run(None).await.map_err(|e| {\n        eprintln!(\"Application setup error: {e:?}\");\n        e\n    })?;\n\n    let addr = SocketAddr::from(([0, 0, 0, 0], config.server.port));\n    let listener = TcpListener::bind(addr).await.map_err(|e| {\n        error!(server.address = %addr, error = ?e, \"Failed to bind to address. Exiting.\");\n        AppError::from(e)\n    })?;\n    info!(server.address = %addr, \"Server listening\");\n\n    // --- Run with Graceful Shutdown ---\n    info!(\"Starting server run loop...\");\n    serve(listener, app.into_make_service())\n        .with_graceful_shutdown(shutdown_signal())\n        .await\n        .map_err(|e| {\n            error!(error = ?e, \"Server run loop encountered an error. Exiting.\");\n            AppError::from(e)\n        })?;\n\n    info!(\"Server shut down gracefully.\");\n    Ok(())\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","app","src","metrics.rs"],"content":"// src/metrics.rs\n\nuse metrics::{counter, gauge, histogram};\nuse metrics_exporter_prometheus::{PrometheusBuilder, PrometheusHandle};\nuse std::time::Instant;\n\npub fn initialize_metrics() -\u003e PrometheusHandle {\n    let builder = PrometheusBuilder::new();\n    builder\n        .install_recorder()\n        .expect(\"failed to install Prometheus recorder\")\n}\n\npub fn record_request_start() {\n    gauge!(\"proxy_requests_in_flight\").increment(1.0);\n}\n\npub fn record_request_end(start_time: Instant, status_code: u16, group_name: \u0026str) {\n    let duration = start_time.elapsed().as_secs_f64();\n    gauge!(\"proxy_requests_in_flight\").decrement(1.0);\n    counter!(\"proxy_requests_total\", \"status\" =\u003e status_code.to_string(), \"group\" =\u003e group_name.to_string()).increment(1);\n    histogram!(\"proxy_request_duration_seconds\", \"status\" =\u003e status_code.to_string(), \"group\" =\u003e group_name.to_string()).record(duration);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","src","proxy.rs"],"content":"// src/proxy.rs\n\nuse crate::{\n    error::{AppError, Result},\n    key_manager::FlattenedKeyInfo,\n    state::AppState, // Import AppState\n};\nuse axum::{\n    body::{Body, Bytes},\n    http::{HeaderMap, HeaderValue, Method, header}, // Removed unused StatusCode\n    response::Response,\n};\n\nuse futures_util::TryStreamExt;\nuse std::error::Error; // Import Error trait for source()\nuse std::time::Instant; // Added Instant\nuse tracing::{debug, error, info, trace, warn};\nuse url::Url; // Keep Url\n\n// Hop-by-hop headers that should not be forwarded\nconst HOP_BY_HOP_HEADERS: \u0026[\u0026str] = \u0026[\n    \"connection\",\n    \"keep-alive\",\n    \"proxy-authenticate\",\n    \"proxy-authorization\",\n    \"te\",\n    \"trailers\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"host\",           // Explicitly include host as it's often added by clients\n    \"authorization\",  // Original authorization should be replaced\n    \"x-goog-api-key\", // Original key (if any) should be replaced\n];\n/// Takes incoming request components and forwards them to the appropriate upstream target.\n///\n/// Orchestrates the core proxying logic. Rate limit handling (429) is delegated to the calling handler.\n/// Assumes this function is called within a tracing span that includes `request_id`.\n///\n/// # Errors\n///\n/// This function will return an error if:\n/// - The base URL from configuration is invalid.\n/// - The final target URL cannot be constructed.\n/// - The HTTP client for the required proxy cannot be retrieved.\n/// - The request to the target fails (e.g., network error, timeout).\n/// - The response body stream from the target has an error.\n/// - The final response to the client cannot be constructed.\npub async fn forward_request(\n    state: \u0026AppState,\n    key_info: \u0026FlattenedKeyInfo,\n    method: Method,\n    target_url: Url,\n    headers: HeaderMap,\n    body_bytes: Bytes,\n) -\u003e Result\u003cResponse\u003e {\n    let api_key = \u0026key_info.key;\n    let proxy_url_option = key_info.proxy_url.as_deref();\n    let group_name = \u0026key_info.group_name;\n    let request_key_preview = format!(\"{}...\", api_key.chars().take(4).collect::\u003cString\u003e());\n\n    let final_target_url = target_url;\n    let outgoing_method = method;\n    let mut outgoing_headers = build_forward_headers(\u0026headers, api_key)?;\n\n    // --- Body Modification ---\n    let body_to_send = {\n        let config_guard = state.config.read().await;\n        if let Some(top_p_value) = config_guard.server.top_p {\n            // Drop the read lock as soon as we have the value\n            drop(config_guard);\n            // The logic is wrapped in a closure to easily return the original bytes on any failure.\n            let modified_body_bytes = (|| {\n                if let Ok(mut json_body) = serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026body_bytes)\n                {\n                    if let Some(obj) = json_body.as_object_mut() {\n                        obj.insert(\"top_p\".to_string(), serde_json::json!(top_p_value));\n                        if let Ok(modified_bytes) = serde_json::to_vec(\u0026json_body) {\n                            info!(\n                                top_p = top_p_value,\n                                \"Successfully injected top_p into request body\"\n                            );\n                            return Bytes::from(modified_bytes);\n                        } else {\n                            warn!(\n                                \"Failed to re-serialize JSON body after injecting top_p, forwarding original body.\"\n                            );\n                        }\n                    } else {\n                        debug!(\n                            \"Request body is valid JSON but not an object, cannot inject top_p.\"\n                        );\n                    }\n                } else {\n                    debug!(\"Request body is not valid JSON, cannot inject top_p.\");\n                }\n                body_bytes.clone() // Return original on any failure\n            })();\n\n            // If the body was modified, update the Content-Length header.\n            if modified_body_bytes.len() != body_bytes.len() {\n                let new_length = modified_body_bytes.len();\n                debug!(\n                    old_len = body_bytes.len(),\n                    new_len = new_length,\n                    \"Updating Content-Length due to body modification\"\n                );\n                outgoing_headers.insert(header::CONTENT_LENGTH, HeaderValue::from(new_length));\n            }\n            modified_body_bytes\n        } else {\n            body_bytes\n        }\n    };\n    // Log the body at debug level for diagnostics, converting to lossy string\n    // in case of non-UTF8 content, BEFORE it's moved.\n    debug!(\n        http.request.body = %String::from_utf8_lossy(\u0026body_to_send),\n        \"Full request body\"\n    );\n\n    let outgoing_reqwest_body = reqwest::Body::from(body_to_send);\n    // --- End Body Modification ---\n    // --- Get Client ---\n    let http_client = state.get_client(proxy_url_option).await?; // Error handled within\n    // ---\n\n    // Log before sending the request\n    info!(\n        http.method = %outgoing_method,\n        target.url = %final_target_url,\n        http.headers = ?outgoing_headers,\n        api_key.preview = %request_key_preview,\n        group.name = %group_name,\n        proxy.url = ?proxy_url_option, // Use debug formatting for Option\u003c\u0026str\u003e\n        \"Forwarding raw request to target\"\n    );\n\n    // --- Send request ---\n    let start_time = Instant::now();\n\n    let target_response_result = http_client\n        .request(outgoing_method.clone(), final_target_url.clone()) // Clone Url for request\n        .headers(outgoing_headers)\n        .body(outgoing_reqwest_body)\n        .send()\n        .await;\n\n    let elapsed_time = start_time.elapsed(); // Calculate duration immediately after await\n\n    let target_response = match target_response_result {\n        Ok(resp) =\u003e {\n            let status = resp.status();\n            // Structured success log\n            info!(\n                // Use standard semantic convention fields where possible\n                http.status_code = status.as_u16(),\n                http.response.duration = ?elapsed_time, // Use standard field name if available in log aggregator\n                target.url = %final_target_url,\n                api_key.preview = %request_key_preview,\n                group.name = %group_name,\n                proxy.url = ?proxy_url_option,\n                \"Received response from target\"\n            );\n            resp // Return the response\n        }\n        Err(e) =\u003e {\n            // Structured error log, trying to extract more detail from reqwest::Error\n            let error_kind = if e.is_timeout() {\n                \"timeout\"\n            } else if e.is_connect() {\n                \"connect\"\n            } else if e.is_redirect() {\n                \"redirect_policy\"\n            } else if e.is_request() {\n                \"request_error\"\n            } else if e.is_body() || e.is_decode() {\n                \"body/decode\"\n            } else if e.is_builder() {\n                \"builder\"\n            } else {\n                \"unknown\"\n            };\n            // Use the imported Error trait to call source()\n            let underlying_source = e.source().map(ToString::to_string); // Get underlying error if available\n\n            error!(\n                error = %e, // Display format for top-level error\n                error.kind = error_kind,\n                error.source = ?underlying_source, // Debug format for underlying source\n                http.response.duration = ?elapsed_time,\n                target.url = %final_target_url, // Log target URL on error too\n                api_key.preview = %request_key_preview,\n                group.name = %group_name,\n                proxy.url = ?proxy_url_option,\n                \"Error received while sending request to target\"\n            );\n            // Return the error wrapped in AppError\n            return Err(AppError::Reqwest(e));\n        }\n    };\n    // --- End Send Request ---\n\n    let response_status = target_response.status();\n    let response_headers = build_response_headers(target_response.headers());\n\n    // Stream response body back\n    let captured_response_status = response_status; // Capture status for closure\n    let response_body_stream = target_response.bytes_stream().map_err(move |e| {\n        // Log error during stream reading\n        warn!(\n            status = captured_response_status.as_u16(),\n            error = %e,\n            \"Error reading upstream response body stream\"\n        );\n        AppError::ResponseBodyError(format!(\n            \"Upstream body stream error (status {captured_response_status}): {e}\"\n        ))\n    });\n    let axum_response_body = Body::from_stream(response_body_stream);\n\n    // Build final response to client\n    let mut client_response = Response::builder()\n        .status(response_status)\n        .body(axum_response_body)\n        .map_err(|e| {\n            error!(error = %e, \"Failed to build final client response\");\n            AppError::Internal(format!(\"Failed to construct client response: {e}\"))\n        })?;\n\n    *client_response.headers_mut() = response_headers;\n\n    Ok(client_response)\n}\n\n/// Creates the `HeaderMap` for the outgoing request to the target service.\n/// Now returns a Result to handle potential errors from add_auth_headers.\n#[tracing::instrument(level=\"debug\", skip(original_headers, api_key), fields(header_count = original_headers.len()))]\nfn build_forward_headers(original_headers: \u0026HeaderMap, api_key: \u0026str) -\u003e Result\u003cHeaderMap\u003e {\n    let mut filtered = HeaderMap::with_capacity(original_headers.len() + 3);\n    copy_non_hop_by_hop_headers(original_headers, \u0026mut filtered, true);\n    add_auth_headers(\u0026mut filtered, api_key)?;\n    Ok(filtered)\n}\n\n/// Creates the `HeaderMap` for the response sent back to the original client.\n#[tracing::instrument(level=\"debug\", skip(original_headers), fields(header_count = original_headers.len()))]\nfn build_response_headers(original_headers: \u0026HeaderMap) -\u003e HeaderMap {\n    let mut filtered = HeaderMap::with_capacity(original_headers.len());\n    copy_non_hop_by_hop_headers(original_headers, \u0026mut filtered, false);\n    filtered\n}\n\n/// Copies headers from `source` to `dest`, excluding hop-by-hop headers.\nfn copy_non_hop_by_hop_headers(source: \u0026HeaderMap, dest: \u0026mut HeaderMap, is_request: bool) {\n    for (name, value) in source {\n        let name_str = name.as_str().to_lowercase();\n        // Check against the HOP_BY_HOP_HEADERS list using lowercase comparison\n        if HOP_BY_HOP_HEADERS.contains(\u0026name_str.as_str()) {\n            trace!(header.name=%name, header.action=\"skip\", context=if is_request {\"request\"} else {\"response\"}, \"Skipping hop-by-hop or auth header\");\n        } else {\n            dest.insert(name.clone(), value.clone());\n            trace!(header.name=%name, header.action=\"forward\", context=if is_request {\"request\"} else {\"response\"}, \"Forwarding header\");\n        }\n    }\n}\n\n/// Adds the necessary authentication headers (`x-goog-api-key` and `Authorization: Bearer`).\n/// Returns a Result to indicate potential failures.\n#[tracing::instrument(level = \"debug\")] // Removed skip attribute\n// Now takes api_key to add the Bearer token\nfn add_auth_headers(headers: \u0026mut HeaderMap, api_key: \u0026str) -\u003e Result\u003c()\u003e {\n    let auth_value_str = format!(\"Bearer {api_key}\");\n    match HeaderValue::from_str(\u0026auth_value_str) {\n        Ok(auth_value) =\u003e {\n            headers.insert(header::AUTHORIZATION, auth_value);\n            trace!(\n                header.name = \"Authorization\",\n                header.action = \"add\",\n                \"Added Bearer token\"\n            );\n            Ok(())\n        }\n        Err(e) =\u003e {\n            error!(error = %e, \"Failed to create Authorization header value\");\n            Err(AppError::Internal(\n                \"Failed to construct Authorization header\".to_string(),\n            ))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::http::{HeaderName, HeaderValue, header};\n    // Import Error trait for source()\n\n    #[test]\n    fn test_build_forward_headers_basic() {\n        let mut original_headers = HeaderMap::new();\n        original_headers.insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n        original_headers.insert(\"x-custom-header\", HeaderValue::from_static(\"value1\"));\n        original_headers.insert(\"host\", HeaderValue::from_static(\"original.host.com\")); // Hop-by-hop\n        original_headers.insert(\"connection\", HeaderValue::from_static(\"keep-alive\")); // Hop-by-hop\n        original_headers.insert(\n            \"authorization\",\n            HeaderValue::from_static(\"Bearer old_token\"),\n        ); // Auth, should be removed\n        original_headers.insert(\"x-goog-api-key\", HeaderValue::from_static(\"old_key\")); // Auth, should be removed\n\n        // api_key is no longer passed as it's handled in URL construction\n        let result_headers = build_forward_headers(\u0026original_headers, \"test_key\").unwrap();\n\n        // Check standard headers are present\n        assert_eq!(\n            result_headers.get(\"content-type\").unwrap(),\n            \"application/json\"\n        );\n        assert_eq!(result_headers.get(\"x-custom-header\").unwrap(), \"value1\");\n\n        // Check hop-by-hop are absent\n        assert!(result_headers.get(\"host\").is_none());\n        assert!(result_headers.get(\"connection\").is_none());\n\n        // Check that x-goog-api-key is absent, but the new Authorization header is present.\n        assert!(result_headers.get(\"x-goog-api-key\").is_none());\n        let auth_header = result_headers.get(header::AUTHORIZATION).unwrap();\n        assert_eq!(auth_header, \"Bearer test_key\");\n    }\n\n    #[test]\n    fn test_build_forward_headers_removes_auth_headers() {\n        let mut original_headers = HeaderMap::new();\n        original_headers.insert(\n            header::AUTHORIZATION,\n            HeaderValue::from_static(\"Bearer client_token\"),\n        );\n        original_headers.insert(\"x-goog-api-key\", HeaderValue::from_static(\"client_key\"));\n        original_headers.insert(\"x-custom-header\", HeaderValue::from_static(\"custom_value\"));\n\n        let result_headers = build_forward_headers(\u0026original_headers, \"some_key\").unwrap();\n\n        assert!(result_headers.get(\"x-goog-api-key\").is_none());\n        assert_eq!(\n            result_headers.get(\"x-custom-header\").unwrap(),\n            \"custom_value\"\n        );\n        assert_eq!(result_headers.len(), 2);\n    }\n\n    // Removed test: test_build_forward_headers_invalid_key_chars\n\n    #[test]\n    fn test_build_response_headers_filters_hop_by_hop() {\n        let mut upstream_headers = HeaderMap::new();\n        upstream_headers.insert(\"content-type\", HeaderValue::from_static(\"text/plain\"));\n        upstream_headers.insert(\"x-upstream-specific\", HeaderValue::from_static(\"value2\"));\n        upstream_headers.insert(\"transfer-encoding\", HeaderValue::from_static(\"chunked\")); // Hop-by-hop\n        upstream_headers.insert(\"connection\", HeaderValue::from_static(\"close\")); // Hop-by-hop\n        upstream_headers.insert(\n            HeaderName::from_static(\"keep-alive\"),\n            HeaderValue::from_static(\"timeout=15\"),\n        ); // Hop-by-hop (case insensitive check needed)\n\n        let result_headers = build_response_headers(\u0026upstream_headers);\n\n        // Check standard headers are present\n        assert_eq!(result_headers.get(\"content-type\").unwrap(), \"text/plain\");\n        assert_eq!(result_headers.get(\"x-upstream-specific\").unwrap(), \"value2\");\n\n        // Check hop-by-hop are absent\n        assert!(result_headers.get(\"transfer-encoding\").is_none());\n        assert!(result_headers.get(\"connection\").is_none());\n        assert!(result_headers.get(\"keep-alive\").is_none());\n    }\n\n    #[test]\n    fn test_copy_non_hop_by_hop_headers_request() {\n        let mut source = HeaderMap::new();\n        source.insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n        source.insert(\"host\", HeaderValue::from_static(\"example.com\")); // Hop-by-hop\n        source.insert(\"authorization\", HeaderValue::from_static(\"Bearer old\")); // Hop-by-hop (for request)\n        source.insert(\"x-custom\", HeaderValue::from_static(\"custom\"));\n\n        let mut dest = HeaderMap::new();\n        copy_non_hop_by_hop_headers(\u0026source, \u0026mut dest, true); // is_request = true\n\n        assert!(dest.contains_key(\"content-type\"));\n        assert!(dest.contains_key(\"x-custom\"));\n        assert!(!dest.contains_key(\"host\"));\n        assert!(!dest.contains_key(\"authorization\")); // Should be filtered for request\n        assert_eq!(dest.len(), 2);\n    }\n\n    #[test]\n    fn test_copy_non_hop_by_hop_headers_response() {\n        let mut source = HeaderMap::new();\n        source.insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n        source.insert(\"transfer-encoding\", HeaderValue::from_static(\"chunked\")); // Hop-by-hop\n        source.insert(\"connection\", HeaderValue::from_static(\"close\")); // Hop-by-hop\n        source.insert(\"x-custom\", HeaderValue::from_static(\"custom\"));\n\n        let mut dest = HeaderMap::new();\n        copy_non_hop_by_hop_headers(\u0026source, \u0026mut dest, false); // is_request = false\n\n        assert!(dest.contains_key(\"content-type\"));\n        assert!(dest.contains_key(\"x-custom\"));\n        assert!(!dest.contains_key(\"transfer-encoding\"));\n        assert!(!dest.contains_key(\"connection\"));\n        assert_eq!(dest.len(), 2);\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":88}},{"line":56,"address":[],"length":0,"stats":{"Line":176}},{"line":57,"address":[],"length":0,"stats":{"Line":264}},{"line":58,"address":[],"length":0,"stats":{"Line":176}},{"line":59,"address":[],"length":0,"stats":{"Line":528}},{"line":61,"address":[],"length":0,"stats":{"Line":176}},{"line":62,"address":[],"length":0,"stats":{"Line":176}},{"line":63,"address":[],"length":0,"stats":{"Line":352}},{"line":66,"address":[],"length":0,"stats":{"Line":88}},{"line":67,"address":[],"length":0,"stats":{"Line":88}},{"line":68,"address":[],"length":0,"stats":{"Line":92}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":20}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":84}},{"line":116,"address":[],"length":0,"stats":{"Line":88}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":264}},{"line":124,"address":[],"length":0,"stats":{"Line":352}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":88}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":264}},{"line":150,"address":[],"length":0,"stats":{"Line":176}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":88}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":90}},{"line":239,"address":[],"length":0,"stats":{"Line":270}},{"line":240,"address":[],"length":0,"stats":{"Line":270}},{"line":241,"address":[],"length":0,"stats":{"Line":270}},{"line":242,"address":[],"length":0,"stats":{"Line":90}},{"line":247,"address":[],"length":0,"stats":{"Line":89}},{"line":248,"address":[],"length":0,"stats":{"Line":356}},{"line":249,"address":[],"length":0,"stats":{"Line":267}},{"line":250,"address":[],"length":0,"stats":{"Line":89}},{"line":254,"address":[],"length":0,"stats":{"Line":181}},{"line":255,"address":[],"length":0,"stats":{"Line":749}},{"line":259,"address":[],"length":0,"stats":{"Line":13}},{"line":261,"address":[],"length":0,"stats":{"Line":271}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":90}},{"line":272,"address":[],"length":0,"stats":{"Line":270}},{"line":273,"address":[],"length":0,"stats":{"Line":90}},{"line":274,"address":[],"length":0,"stats":{"Line":90}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}}],"covered":43,"coverable":114},{"path":["/","app","src","state.rs"],"content":"// src/state.rs\n\nuse crate::admin::SystemInfoCollector;\nuse crate::config::AppConfig;\nuse crate::error::{AppError, ProxyConfigErrorData, ProxyConfigErrorKind, Result};\nuse crate::key_manager::KeyManager;\nuse reqwest::{Client, ClientBuilder, Proxy};\nuse std::collections::{HashMap, HashSet};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse tracing::{Instrument, debug, error, info, instrument, warn};\nuse url::Url;\n\n/// Представляет общее состояние приложения, доступное для всех обработчиков Axum.\n#[derive(Debug)]\npub struct AppState {\n    pub key_manager: Arc\u003cRwLock\u003cKeyManager\u003e\u003e,\n    http_clients: Arc\u003cRwLock\u003cHashMap\u003cOption\u003cString\u003e, Arc\u003cClient\u003e\u003e\u003e\u003e,\n    pub start_time: Instant,\n    pub config: Arc\u003cRwLock\u003cAppConfig\u003e\u003e,\n    pub system_info: SystemInfoCollector,\n    pub config_path: PathBuf,\n}\n\n/// Создает `HashMap` HTTP-клиентов на основе предоставленной конфигурации.\n///\n/// Эта функция инкапсулирует логику для:\n/// 1. Создания базового клиента (без прокси).\n/// 2. Поиска уникальных URL-адресов прокси в конфигурации.\n/// 3. Создания отдельного клиента для каждого уникального прокси.\n///\n/// # Errors\n///\n/// Возвращает `Err`, если:\n/// - Не удается создать базовый HTTP-клиент (фатальная ошибка).\n/// - URL-адрес прокси имеет синтаксически неверный формат или неподдерживаемую схему.\n/// - Происходит другая непредвиденная ошибка во время сборки клиента.\n#[instrument(level = \"info\", skip_all, name = \"build_http_clients\")]\nasync fn build_http_clients(config: \u0026AppConfig) -\u003e Result\u003cHashMap\u003cOption\u003cString\u003e, Arc\u003cClient\u003e\u003e\u003e {\n    info!(\"Building HTTP clients based on configuration...\");\n    let mut http_clients = HashMap::new();\n\n    // Определяем размер пула соединений на основе количества ключей, с минимальным порогом\n    let total_key_count: usize = config\n        .groups\n        .iter()\n        .flat_map(|g| \u0026g.api_keys)\n        .filter(|k| !k.trim().is_empty())\n        .count()\n        .max(10); // Гарантируем не менее 10 возможных соединений даже при малом количестве ключей\n    debug!(\n        pool.max_idle_per_host = total_key_count,\n        \"Calculated max idle connections per host\"\n    );\n\n    // Централизованная функция конфигурации клиента\n    let configure_builder = |builder: ClientBuilder| -\u003e ClientBuilder {\n        builder\n            .connect_timeout(Duration::from_secs(10))\n            .timeout(Duration::from_secs(300)) // Общий таймаут запроса\n            .pool_idle_timeout(Duration::from_secs(90)) // Держать неактивные соединения открытыми 90с\n            .pool_max_idle_per_host(total_key_count) // Настроить размер пула на основе ключей\n            .tcp_keepalive(Some(Duration::from_secs(60))) // Включить TCP keepalive\n    };\n\n    // 1. Создаем базовый клиент (без прокси) - это ДОЛЖНО получиться\n    let base_client = configure_builder(Client::builder()).build().map_err(|e| {\n        // Структурированная ошибка для сбоя базового клиента - это фатально\n        error!(error = ?e, \"Failed to build base HTTP client (no proxy). This is required.\");\n        AppError::HttpClientBuildError {\n            source: e,\n            proxy_url: None,\n        }\n    })?;\n    http_clients.insert(None, Arc::new(base_client));\n    info!(client.type = \"base\", \"Base HTTP client (no proxy) created successfully.\");\n\n    // 2. Собираем уникальные URL-адреса прокси из конфигурации\n    let unique_proxy_urls: HashSet\u003cString\u003e = config\n        .groups\n        .iter()\n        .filter_map(|g| g.proxy_url.as_ref()) // Получаем Option\u003c\u0026String\u003e\n        .filter(|url_str| !url_str.trim().is_empty()) // Отфильтровываем пустые строки\n        .cloned() // Клонируем String\n        .collect();\n    debug!(\n        proxy.count = unique_proxy_urls.len(),\n        ?unique_proxy_urls,\n        \"Found unique proxy URLs for client creation\"\n    );\n\n    // 3. Создаем клиенты для каждого уникального URL-адреса прокси\n    for proxy_url_str in unique_proxy_urls {\n        let proxy_span = tracing::info_span!(\"create_proxy_client\", proxy.url = %proxy_url_str);\n        let client_result: Result\u003cClient\u003e = async {\n            // Сначала парсим URL, сопоставляем ошибку с конкретным ProxyConfigErrorKind\n            let parsed_proxy_url = Url::parse(\u0026proxy_url_str).map_err(|e| {\n                error!(error = %e, \"Failed to parse proxy URL string.\");\n                AppError::ProxyConfigError(ProxyConfigErrorData {\n                    url: proxy_url_str.clone(),\n                    kind: ProxyConfigErrorKind::UrlParse(e),\n                })\n            })?;\n\n            let scheme = parsed_proxy_url.scheme().to_lowercase();\n            debug!(proxy.scheme = %scheme, \"Parsed proxy scheme\");\n\n            // Создаем объект прокси, сопоставляем ошибки с конкретным ProxyConfigErrorKind\n            let proxy = match scheme.as_str() {\n                \"http\" =\u003e Proxy::http(\u0026proxy_url_str),\n                \"https\" =\u003e Proxy::https(\u0026proxy_url_str),\n                \"socks5\" =\u003e Proxy::all(\u0026proxy_url_str),\n                _ =\u003e {\n                    error!(proxy.scheme = %scheme, \"Unsupported proxy scheme\");\n                    return Err(AppError::ProxyConfigError(ProxyConfigErrorData {\n                        url: proxy_url_str.clone(),\n                        kind: ProxyConfigErrorKind::UnsupportedScheme(scheme.to_string()),\n                    }));\n                }\n            }\n            .map_err(|e| {\n                error!(error = %e, proxy.scheme = %scheme, \"Invalid proxy definition\");\n                AppError::ProxyConfigError(ProxyConfigErrorData {\n                    url: proxy_url_str.clone(),\n                    kind: ProxyConfigErrorKind::InvalidDefinition(e.to_string()),\n                })\n            })?;\n            debug!(\"Proxy object created successfully\");\n\n            // Собираем клиент с прокси\n            configure_builder(Client::builder())\n                .proxy(proxy)\n                .build()\n                .map_err(|e| {\n                    error!(proxy.scheme = %scheme, error = ?e, \"Failed to build reqwest client for proxy.\");\n                    AppError::HttpClientBuildError {\n                        source: e,\n                        proxy_url: Some(proxy_url_str.clone()),\n                    }\n                })\n        }\n        .instrument(proxy_span)\n        .await;\n\n        // Обрабатываем результат создания клиента\n        match client_result {\n            Ok(proxy_client) =\u003e {\n                info!(proxy.url = %proxy_url_str, \"HTTP client created successfully for proxy.\");\n                http_clients.insert(Some(proxy_url_str.clone()), Arc::new(proxy_client));\n            }\n            Err(e) =\u003e {\n                match e {\n                    AppError::ProxyConfigError(_) =\u003e {\n                        error!(proxy.url = %proxy_url_str, error = ?e, \"Critical proxy configuration error. Aborting client creation process.\");\n                        return Err(e); // Быстрый выход при ошибках конфигурации\n                    }\n                    AppError::HttpClientBuildError {\n                        ref source,\n                        proxy_url: Some(ref url),\n                    } =\u003e {\n                        warn!(proxy.url = %url, error = ?source, \"Skipping client creation for this proxy due to build error. Groups using this proxy might fail.\");\n                        // Логируем и продолжаем при ошибках сборки\n                    }\n                    _ =\u003e {\n                        error!(proxy.url = %proxy_url_str, error = ?e, \"Unexpected error during proxy client creation. Aborting.\");\n                        return Err(e); // Выход при других непредвиденных ошибках\n                    }\n                }\n            }\n        }\n    }\n\n    info!(\n        client.count = http_clients.len(),\n        \"Finished building HTTP clients.\"\n    );\n    Ok(http_clients)\n}\n\nimpl AppState {\n    /// Создает новый `AppState`. Инициализирует KeyManager и предварительно создает HTTP-клиенты.\n    ///\n    /// # Errors\n    ///\n    /// Возвращает `Err`, если не удается создать `KeyManager` или `http_clients`.\n    #[instrument(level = \"info\", skip(config, config_path), fields(config.path = %config_path.display()))]\n    pub async fn new(config: \u0026AppConfig, config_path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        info!(\"Creating shared AppState...\");\n\n        // Сначала инициализируем KeyManager\n        let key_manager = KeyManager::new(config, config_path).await;\n\n        // Создаем все HTTP-клиенты с помощью вспомогательной функции\n        let http_clients = build_http_clients(config).await?;\n\n        Ok(Self {\n            key_manager: Arc::new(RwLock::new(key_manager)),\n            http_clients: Arc::new(RwLock::new(http_clients)),\n            start_time: Instant::now(),\n            config: Arc::new(RwLock::new(config.clone())),\n            system_info: SystemInfoCollector::new(),\n            config_path: config_path.to_path_buf(),\n        })\n    }\n\n    /// Перезагружает `KeyManager` и `http_clients` из текущей конфигурации.\n    /// Это позволяет выполнять горячую перезагрузку API-ключей и конфигураций прокси без перезапуска сервера.\n    ///\n    /// # Errors\n    ///\n    /// Возвращает `Err`, если какая-либо часть реконструкции состояния завершается неудачно.\n    #[instrument(level = \"info\", skip(self))]\n    pub async fn reload_state_from_config(\u0026self) -\u003e Result\u003c()\u003e {\n        info!(\n            \"Attempting to reload full application state (KeyManager, HttpClients) from configuration...\"\n        );\n        let config_guard = self.config.read().await;\n\n        // --- Создаем новый KeyManager ---\n        let new_key_manager = KeyManager::new(\u0026config_guard, \u0026self.config_path).await;\n\n        // --- Создаем новые HttpClients с помощью вспомогательной функции ---\n        // Вспомогательная функция содержит надежную обработку ошибок, которую мы хотим использовать.\n        let new_http_clients = build_http_clients(\u0026config_guard).await?;\n\n        // Освобождаем блокировку чтения перед получением блокировок записи\n        drop(config_guard);\n\n        // --- Атомарно обновляем состояние ---\n        *self.key_manager.write().await = new_key_manager;\n        *self.http_clients.write().await = new_http_clients;\n\n        info!(\"Application state (KeyManager, HttpClients) reloaded successfully.\");\n        Ok(())\n    }\n\n    /// Возвращает ссылку на соответствующий HTTP-клиент.\n    ///\n    /// # Errors\n    ///\n    /// Возвращает `AppError::Internal`, если запрошенный клиент (определяемый `proxy_url` Option)\n    /// не был найден в предварительно созданном отображении клиентов. Это указывает на логическую ошибку,\n    /// так как все необходимые клиенты должны были быть инициализированы при запуске.\n    #[instrument(level = \"debug\", skip(self), fields(proxy.url = ?proxy_url))]\n    pub async fn get_client(\u0026self, proxy_url: Option\u003c\u0026str\u003e) -\u003e Result\u003cArc\u003cClient\u003e\u003e {\n        let clients_guard = self.http_clients.read().await;\n        let key = proxy_url.map(String::from);\n\n        clients_guard.get(\u0026key).cloned().ok_or_else(|| {\n            let msg = proxy_url.map_or_else(\n                || \"Requested base HTTP client (None proxy) was unexpectedly missing.\".to_string(),\n                |p_url| format!(\"Requested HTTP client for proxy '{p_url}' was not found/initialized in AppState.\"),\n            );\n            error!(proxy.url = ?proxy_url, error.message = %msg, \"HTTP client lookup failed\");\n            AppError::Internal(msg)\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::{KeyGroup, ServerConfig};\n    use crate::error::ProxyConfigErrorKind; // Import the kind enum for tests\n    use std::fs::File;\n    use tempfile::tempdir;\n    use tracing::warn; // Import warn for logging in tests specifically\n\n    const DEFAULT_TARGET_URL_STR: \u0026str = \"https://generativelanguage.googleapis.com\";\n\n    fn create_test_state_config(groups: Vec\u003cKeyGroup\u003e) -\u003e AppConfig {\n        AppConfig {\n            server: ServerConfig {\n                port: 8080,\n                top_p: None,\n                admin_token: None,\n            },\n            groups,\n            internal_retries: 2,\n            temporary_block_minutes: 5,\n        }\n    }\n\n    fn create_dummy_config_path(dir: \u0026tempfile::TempDir) -\u003e std::path::PathBuf {\n        let file_path = dir.path().join(\"dummy_config.yaml\");\n        File::create(\u0026file_path).expect(\"Failed to create dummy config file\");\n        file_path\n    }\n\n    #[tokio::test]\n    async fn test_appstate_new_no_proxies() {\n        let dir = tempdir().unwrap();\n        let dummy_path = create_dummy_config_path(\u0026dir);\n\n        let groups = vec![KeyGroup {\n            name: \"g1\".to_string(),\n            api_keys: vec![\"key1\".to_string()],\n            proxy_url: None,\n            target_url: DEFAULT_TARGET_URL_STR.to_string(),\n            top_p: None,\n        }];\n        let config = create_test_state_config(groups);\n        let state_result = AppState::new(\u0026config, \u0026dummy_path).await;\n\n        assert!(state_result.is_ok());\n        let state = state_result.unwrap();\n        let clients_guard = state.http_clients.read().await;\n        assert_eq!(clients_guard.len(), 1);\n        assert!(clients_guard.contains_key(\u0026None)); // Base client only\n        drop(clients_guard);\n\n        assert!(state.get_client(None).await.is_ok());\n        assert!(\n            state\n                .get_client(Some(\"http://nonexistent.proxy\"))\n                .await\n                .is_err()\n        );\n    }\n    #[tokio::test]\n    async fn test_appstate_new_with_valid_proxies() {\n        let dir = tempdir().unwrap();\n        let dummy_path = create_dummy_config_path(\u0026dir);\n\n        // Mock server or use potentially invalid ports to test resilience\n        let http_proxy_url = \"http://127.0.0.1:34567\"; // Use a likely free port\n        let socks_proxy_url = \"socks5://127.0.0.1:34568\"; // Use a likely free port\n\n        let groups = vec![\n            KeyGroup {\n                name: \"g_http\".to_string(),\n                api_keys: vec![\"key_http\".to_string()],\n                proxy_url: Some(http_proxy_url.to_string()),\n                target_url: DEFAULT_TARGET_URL_STR.to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g_socks\".to_string(),\n                api_keys: vec![\"key_socks\".to_string()],\n                proxy_url: Some(socks_proxy_url.to_string()),\n                target_url: DEFAULT_TARGET_URL_STR.to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                // Same HTTP proxy, should reuse client map entry\n                name: \"g_http_dup\".to_string(),\n                api_keys: vec![\"key_http2\".to_string()],\n                proxy_url: Some(http_proxy_url.to_string()),\n                target_url: DEFAULT_TARGET_URL_STR.to_string(),\n                top_p: None,\n            },\n            KeyGroup {\n                name: \"g_no_proxy\".to_string(),\n                api_keys: vec![\"key_none\".to_string()],\n                proxy_url: None,\n                target_url: DEFAULT_TARGET_URL_STR.to_string(),\n                top_p: None,\n            },\n        ];\n        let config = create_test_state_config(groups);\n        let state_result = AppState::new(\u0026config, \u0026dummy_path).await;\n\n        // AppState::new should succeed even if proxy servers aren't actually running\n        assert!(\n            state_result.is_ok(),\n            \"AppState::new failed unexpectedly: {:?}\",\n            state_result.err()\n        );\n        let state = state_result.unwrap();\n        let clients_guard = state.http_clients.read().await;\n\n        assert!(clients_guard.contains_key(\u0026None)); // Base client must exist\n\n        let http_key = Some(http_proxy_url.to_string());\n        let socks_key = Some(socks_proxy_url.to_string());\n\n        let http_created = clients_guard.contains_key(\u0026http_key);\n        let socks_created = clients_guard.contains_key(\u0026socks_key);\n\n        // We expect all clients to be created successfully if URLs are valid syntactically\n        assert!(http_created, \"HTTP proxy client was not created\");\n        assert!(socks_created, \"SOCKS5 proxy client was not created\");\n        assert_eq!(\n            clients_guard.len(),\n            3,\n            \"Expected Base + HTTP + SOCKS clients\"\n        ); // 1 base + 2 unique proxies\n        drop(clients_guard);\n\n        // Verify get_client behavior\n        assert!(\n            state.get_client(http_key.as_deref()).await.is_ok(),\n            \"get_client failed for created HTTP proxy\"\n        );\n        assert!(\n            state.get_client(socks_key.as_deref()).await.is_ok(),\n            \"get_client failed for created SOCKS5 proxy\"\n        );\n        assert!(state.get_client(None).await.is_ok()); // Check base client retrieval\n        assert!(state.get_client(Some(\"http://other.proxy\")).await.is_err()); // Check non-existent proxy\n    }\n\n    #[tokio::test]\n    async fn test_appstate_new_returns_err_on_invalid_url_syntax() {\n        let dir = tempdir().unwrap();\n        let dummy_path = create_dummy_config_path(\u0026dir);\n\n        let groups = vec![KeyGroup {\n            name: \"g_invalid_url\".to_string(),\n            api_keys: vec![\"key_invalid\".to_string()],\n            proxy_url: Some(\"::not a proxy url::\".to_string()), // Invalid syntax\n            target_url: DEFAULT_TARGET_URL_STR.to_string(),\n            top_p: None,\n        }];\n        let config = create_test_state_config(groups);\n        let state_result = AppState::new(\u0026config, \u0026dummy_path).await;\n\n        assert!(\n            state_result.is_err(),\n            \"AppState::new should return Err for invalid proxy URL syntax\"\n        );\n        // Check for the correct error variant and kind\n        assert!(\n            matches!(state_result.as_ref().err().unwrap(), AppError::ProxyConfigError(data) if matches!(data.kind, ProxyConfigErrorKind::UrlParse(_))),\n            \"Expected ProxyConfigError with UrlParse kind\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_appstate_new_returns_err_on_unsupported_scheme() {\n        let dir = tempdir().unwrap();\n        let dummy_path = create_dummy_config_path(\u0026dir);\n\n        let groups = vec![KeyGroup {\n            name: \"g_unsupported\".to_string(),\n            api_keys: vec![\"key_unsupported\".to_string()],\n            proxy_url: Some(\"ftp://unsupported.proxy\".to_string()), // Unsupported scheme\n            target_url: DEFAULT_TARGET_URL_STR.to_string(),\n            top_p: None,\n        }];\n        let config = create_test_state_config(groups);\n        let state_result = AppState::new(\u0026config, \u0026dummy_path).await;\n\n        assert!(\n            state_result.is_err(),\n            \"AppState::new should return Err for unsupported proxy scheme\"\n        );\n        // Check for the correct error variant and kind\n        assert!(\n            matches!(state_result.as_ref().err().unwrap(), AppError::ProxyConfigError(data) if matches!(data.kind, ProxyConfigErrorKind::UnsupportedScheme(_))),\n            \"Expected ProxyConfigError with UnsupportedScheme kind\"\n        );\n    }\n\n    // Test where Client::build() itself might fail (less common, requires specific setup or invalid proxy def)\n    // This test might be flaky depending on environment/reqwest version behavior\n    #[tokio::test]\n    async fn test_appstate_new_skips_client_on_build_error() {\n        // This test simulates a reqwest build failure for one proxy,\n        // but AppState creation should still succeed with other valid clients.\n        // We use a syntactically valid but likely non-functional SOCKS5 URL.\n        let dir = tempdir().unwrap();\n        let dummy_path = create_dummy_config_path(\u0026dir);\n\n        let groups = vec![\n            KeyGroup {\n                // Valid HTTP\n                name: \"g_http_ok\".to_string(),\n                api_keys: vec![\"k1\".to_string()],\n                proxy_url: Some(\"http://127.0.0.1:34569\".to_string()), // Likely free port\n                target_url: DEFAULT_TARGET_URL_STR.to_string(),\n                top_p: None,\n            },\n            // Use a socks URL that might cause build issues or is hard to resolve\n            KeyGroup {\n                name: \"g_socks_fail_build\".to_string(),\n                api_keys: vec![\"k2\".to_string()],\n                // Provide a URL that might fail build if socks feature isn't compiled correctly or has issues\n                proxy_url: Some(\"socks5://invalid-host-that-causes-build-error:1080\".to_string()),\n                target_url: DEFAULT_TARGET_URL_STR.to_string(),\n                top_p: None,\n            },\n        ];\n        let config = create_test_state_config(groups);\n        let state_result = AppState::new(\u0026config, \u0026dummy_path).await;\n\n        // Check the result: AppState::new should either succeed (skipping the build error)\n        // or return a ProxyConfigError if the test URL caused a definition error.\n        match state_result {\n            Ok(state) =\u003e {\n                let clients_guard = state.http_clients.read().await;\n                assert!(clients_guard.contains_key(\u0026None)); // Base client\n                let http_key = Some(\"http://127.0.0.1:34569\".to_string());\n                let socks_key =\n                    Some(\"socks5://invalid-host-that-causes-build-error:1080\".to_string());\n                let http_created = clients_guard.contains_key(\u0026http_key);\n                let socks_created = clients_guard.contains_key(\u0026socks_key);\n                assert!(http_created, \"Valid HTTP client should have been created\");\n\n                let expected_clients =\n                    1 + (if http_created { 1 } else { 0 }) + (if socks_created { 1 } else { 0 });\n                assert_eq!(\n                    clients_guard.len(),\n                    expected_clients,\n                    \"Unexpected number of clients created\"\n                );\n                drop(clients_guard);\n\n                assert!(state.get_client(http_key.as_deref()).await.is_ok());\n                if socks_created {\n                    assert!(state.get_client(socks_key.as_deref()).await.is_ok());\n                    warn!(\n                        \"SOCKS client build succeeded unexpectedly in test - test might not cover build failure path\"\n                    );\n                } else {\n                    assert!(state.get_client(socks_key.as_deref()).await.is_err());\n                }\n            }\n            Err(AppError::ProxyConfigError(data)) =\u003e {\n                // If the \"invalid\" URL actually caused a config error (likely InvalidDefinition), this is an acceptable outcome.\n                warn!(error = ?data, \"Test URL caused ProxyConfigError instead of HttpClientBuildError. Treating as acceptable test outcome.\");\n                assert_eq!(\n                    data.url,\n                    \"socks5://invalid-host-that-causes-build-error:1080\"\n                );\n            }\n            Err(e) =\u003e {\n                // Any other error type is unexpected and should fail the test\n                panic!(\"AppState::new failed with unexpected error type: {e:?}\");\n            }\n        }\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":140}},{"line":50,"address":[],"length":0,"stats":{"Line":242}},{"line":59,"address":[],"length":0,"stats":{"Line":74}},{"line":60,"address":[],"length":0,"stats":{"Line":74}},{"line":61,"address":[],"length":0,"stats":{"Line":148}},{"line":62,"address":[],"length":0,"stats":{"Line":148}},{"line":63,"address":[],"length":0,"stats":{"Line":148}},{"line":64,"address":[],"length":0,"stats":{"Line":148}},{"line":65,"address":[],"length":0,"stats":{"Line":148}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":174}},{"line":85,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":24}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":99}},{"line":215,"address":[],"length":0,"stats":{"Line":16}},{"line":247,"address":[],"length":0,"stats":{"Line":200}},{"line":251,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":2}}],"covered":31,"coverable":48},{"path":["/","app","tests","admin_integration_tests.rs"],"content":"// tests/admin_integration_tests.rs\n\nuse axum::{\n    body::Body,\n    http::{HeaderMap, Method, Request, StatusCode, header},\n};\nuse gemini_proxy_key_rotation_rust::{\n    admin::{AddKeysRequest, CsrfTokenResponse, DeleteKeysRequest},\n    config::{AppConfig, KeyGroup},\n    run,\n};\nuse http_body_util::BodyExt;\nuse serde_json::json;\nuse std::sync::Once;\nuse tempfile::TempDir;\nuse tower::util::ServiceExt;\nuse tracing_subscriber::{EnvFilter, fmt, layer::SubscriberExt, util::SubscriberInitExt};\nuse wiremock::{\n    Mock, MockServer, ResponseTemplate,\n    matchers::{method, path},\n};\n\nstatic TRACING_INIT: Once = Once::new();\n\n/// Initializes the tracing subscriber for tests, ensuring it only runs once.\nfn ensure_tracing_initialized() {\n    TRACING_INIT.call_once(|| {\n        let env_filter =\n            EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n        let json_layer = fmt::layer()\n            .json()\n            .with_current_span(true)\n            .with_span_list(true);\n        tracing_subscriber::registry()\n            .with(env_filter)\n            .with(json_layer)\n            .init();\n    });\n}\n\n// Helper structure to manage the test application state\nstruct TestApp {\n    router: axum::Router,\n    // _state: Arc\u003cAppState\u003e, // Keep state alive\n    _temp_dir: TempDir, // Keep temp dir alive\n    auth_cookie: Option\u003cString\u003e,\n    csrf_token: Option\u003cString\u003e,\n    csrf_cookie: Option\u003cString\u003e,\n}\n\nimpl TestApp {\n    async fn new(config: AppConfig) -\u003e Self {\n        ensure_tracing_initialized();\n        let temp_dir = tempfile::tempdir().unwrap();\n        // Define paths for config and state files within the temp directory\n        let config_file_path = temp_dir.path().join(\"config.yaml\");\n        let state_file_path = temp_dir.path().join(\"key_states.json\");\n\n        // Save the provided config to a temporary file\n        let config_str = serde_yaml::to_string(\u0026config).unwrap();\n        tokio::fs::write(\u0026config_file_path, \u0026config_str)\n            .await\n            .unwrap();\n\n        // Also create an empty key_states.json file\n        tokio::fs::write(state_file_path, \"{}\").await.unwrap();\n\n        // The `run` function now returns a router and config, which is ideal for testing.\n        let (router, _config) = run(Some(config_file_path.clone()))\n            .await\n            .expect(\"Failed to create test router\");\n\n        TestApp {\n            router,\n            // _state: state,\n            _temp_dir: temp_dir,\n            auth_cookie: None,\n            csrf_token: None,\n            csrf_cookie: None,\n        }\n    }\n\n    /// Logs in to the application and stores the auth cookie.\n    async fn login(\u0026mut self, token: \u0026str) {\n        let response = self\n            .router\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(\"POST\")\n                    .uri(\"/admin/login\")\n                    .header(\"Content-Type\", \"application/json\")\n                    .body(Body::from(format!(r#\"{{\"token\": \"{token}\"}}\"#)))\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n        let cookie = response\n            .headers()\n            .get(\"set-cookie\")\n            .unwrap()\n            .to_str()\n            .unwrap();\n        self.auth_cookie = Some(cookie.to_string());\n    }\n\n    /// Gets a CSRF token and stores it.\n    async fn get_csrf_token(\u0026mut self) {\n        let response = self\n            .router\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .uri(\"/admin/csrf-token\")\n                    .header(header::COOKIE, self.auth_cookie.as_ref().unwrap())\n                    .body(Body::empty())\n                    .unwrap(),\n            )\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n        let csrf_cookie = response\n            .headers()\n            .get(\"set-cookie\")\n            .unwrap()\n            .to_str()\n            .unwrap();\n        self.csrf_cookie = Some(csrf_cookie.to_string());\n\n        let body = response.into_body().collect().await.unwrap().to_bytes();\n        let csrf_response: CsrfTokenResponse = serde_json::from_slice(\u0026body).unwrap();\n        self.csrf_token = Some(csrf_response.csrf_token);\n    }\n\n    /// Sends a request with authentication and CSRF headers.\n    async fn authed_request(\n        \u0026self,\n        method: Method,\n        uri: \u0026str,\n        body: Body,\n    ) -\u003e axum::response::Response {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            header::COOKIE,\n            format!(\n                \"{}; {}\",\n                self.auth_cookie.as_ref().unwrap(),\n                self.csrf_cookie.as_ref().unwrap()\n            )\n            .parse()\n            .unwrap(),\n        );\n        headers.insert(\n            \"x-csrf-token\",\n            self.csrf_token.as_ref().unwrap().parse().unwrap(),\n        );\n        headers.insert(\"Content-Type\", \"application/json\".parse().unwrap());\n\n        self.router\n            .clone()\n            .oneshot(\n                Request::builder()\n                    .method(method)\n                    .uri(uri)\n                    .header(\"Content-Type\", \"application/json\")\n                    .header(\n                        header::COOKIE,\n                        format!(\n                            \"{}; {}\",\n                            self.auth_cookie.as_ref().unwrap(),\n                            self.csrf_cookie.as_ref().unwrap()\n                        ),\n                    )\n                    .header(\"x-csrf-token\", self.csrf_token.as_ref().unwrap())\n                    .body(body)\n                    .unwrap(),\n            )\n            .await\n            .unwrap()\n    }\n}\n\nfn get_default_config() -\u003e AppConfig {\n    let mut config = AppConfig::default();\n    config.server.admin_token = Some(\"secret_admin_token\".to_string());\n    config.groups = vec![KeyGroup {\n        name: \"default\".to_string(),\n        api_keys: vec![\"key1\".to_string()],\n        ..Default::default()\n    }];\n    config\n}\n\n#[tokio::test]\nasync fn test_detailed_health_ok() {\n    let config = get_default_config();\n    let app = TestApp::new(config).await;\n\n    let response = app\n        .router\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/health\")\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    assert_eq!(response.status(), StatusCode::OK);\n}\n\n#[tokio::test]\nasync fn test_login_and_get_config_success() {\n    let config = get_default_config();\n    let mut app = TestApp::new(config.clone()).await;\n\n    // 1. Login\n    app.login(\"secret_admin_token\").await;\n    assert!(app.auth_cookie.is_some());\n\n    // 2. Get config (doesn't require CSRF)\n    let response = app\n        .router\n        .clone()\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/config\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    assert_eq!(response.status(), StatusCode::OK);\n    let body = response.into_body().collect().await.unwrap().to_bytes();\n    let received_config: AppConfig = serde_json::from_slice(\u0026body).unwrap();\n\n    // Just check one field to confirm it's the right config\n    assert_eq!(\n        received_config.server.admin_token,\n        config.server.admin_token\n    );\n}\n\n#[tokio::test]\nasync fn test_add_keys_unauthorized() {\n    let config = get_default_config();\n    let app = TestApp::new(config).await;\n\n    let body = Body::from(\n        serde_json::to_string(\u0026AddKeysRequest {\n            group_name: \"default\".to_string(),\n            api_keys: vec![\"new_key\".to_string()],\n        })\n        .unwrap(),\n    );\n\n    let response = app\n        .router\n        .oneshot(\n            Request::builder()\n                .method(\"POST\")\n                .uri(\"/admin/keys\")\n                .header(\"Content-Type\", \"application/json\")\n                .body(body)\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    // Unauthorized because no auth cookie/token\n    // It's a CSRF failure, which results in FORBIDDEN\n    assert_eq!(response.status(), StatusCode::FORBIDDEN);\n}\n\n#[tokio::test]\nasync fn test_add_keys_no_csrf() {\n    let config = get_default_config();\n    let mut app = TestApp::new(config).await;\n    app.login(\"secret_admin_token\").await;\n\n    let body = Body::from(\n        serde_json::to_string(\u0026AddKeysRequest {\n            group_name: \"default\".to_string(),\n            api_keys: vec![\"new_key\".to_string()],\n        })\n        .unwrap(),\n    );\n\n    let response = app\n        .router\n        .oneshot(\n            Request::builder()\n                .method(\"POST\")\n                .uri(\"/admin/keys\")\n                .header(\"Content-Type\", \"application/json\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(body)\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    // Forbidden because no CSRF token in header\n    assert_eq!(response.status(), StatusCode::FORBIDDEN);\n}\n\n#[tokio::test]\nasync fn test_add_keys_success() {\n    let config = get_default_config();\n    let mut app = TestApp::new(config).await;\n\n    // 1. Login and get CSRF token\n    app.login(\"secret_admin_token\").await;\n    app.get_csrf_token().await;\n\n    // 2. Prepare and send request\n    let body = Body::from(\n        serde_json::to_string(\u0026AddKeysRequest {\n            group_name: \"default\".to_string(),\n            api_keys: vec![\"new_key_1\".to_string(), \"new_key_2\".to_string()],\n        })\n        .unwrap(),\n    );\n\n    let response = app.authed_request(Method::POST, \"/admin/keys\", body).await;\n    assert_eq!(response.status(), StatusCode::OK);\n\n    // 3. Verify the change by getting the config again\n    let get_config_response = app\n        .router\n        .clone()\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/config\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    let body = get_config_response\n        .into_body()\n        .collect()\n        .await\n        .unwrap()\n        .to_bytes();\n    let updated_config: AppConfig = serde_json::from_slice(\u0026body).unwrap();\n\n    let default_group = updated_config\n        .groups\n        .iter()\n        .find(|g| g.name == \"default\")\n        .unwrap();\n    assert_eq!(default_group.api_keys.len(), 3); // key1, new_key_1, new_key_2\n    assert!(default_group.api_keys.contains(\u0026\"key1\".to_string()));\n    assert!(default_group.api_keys.contains(\u0026\"new_key_1\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_verify_key_success() {\n    // 1. Setup Wiremock\n    let mock_server = MockServer::start().await;\n    Mock::given(method(\"POST\"))\n        .and(path(\"/v1beta/models/gemini-pro:generateContent\"))\n        .respond_with(ResponseTemplate::new(200).set_body_json(json!({\n            \"candidates\": [{\n                \"content\": {\n                    \"parts\": [{\"text\": \"OK\"}],\n                    \"role\": \"model\"\n                }\n            }]\n        })))\n        .mount(\u0026mock_server)\n        .await;\n\n    // 2. Setup TestApp with a key group pointing to the mock server\n    let mut config = get_default_config();\n    config.groups[0].target_url = mock_server.uri(); // Point to mock server\n    let api_key_to_verify = config.groups[0].api_keys[0].clone();\n    let key_id = format!(\"{:x}\", md5::compute(api_key_to_verify.as_bytes()));\n\n    let mut app = TestApp::new(config).await;\n    app.login(\"secret_admin_token\").await;\n    app.get_csrf_token().await;\n\n    // 3. Make the request to verify the key\n    let response = app\n        .authed_request(\n            Method::POST,\n            \u0026format!(\"/admin/keys/{key_id}/verify\"),\n            Body::empty(),\n        )\n        .await;\n\n    // 4. Assert the response\n    assert_eq!(response.status(), StatusCode::OK);\n\n    // Assert that the mock server received exactly one request,\n    // which confirms our handler called the verification logic.\n    mock_server.verify().await;\n}\n#[tokio::test]\nasync fn test_reset_key_success() {\n    // 1. Setup Wiremock to return a rate-limit error\n    let mock_server = MockServer::start().await;\n    Mock::given(method(\"POST\"))\n        .and(path(\"/v1beta/models/gemini-pro:generateContent\"))\n        .respond_with(ResponseTemplate::new(429).set_body_string(\"Rate limit exceeded\"))\n        .mount(\u0026mock_server)\n        .await;\n\n    // 2. Setup TestApp and get key info\n    let mut config = get_default_config();\n    config.groups[0].target_url = mock_server.uri();\n    let api_key_to_test = config.groups[0].api_keys[0].clone();\n    let key_id = format!(\"{:x}\", md5::compute(api_key_to_test.as_bytes()));\n\n    let mut app = TestApp::new(config).await;\n    app.login(\"secret_admin_token\").await;\n    app.get_csrf_token().await;\n\n    // 3. Call verify_key to get the key rate-limited\n    let verify_response = app\n        .authed_request(\n            Method::POST,\n            \u0026format!(\"/admin/keys/{key_id}/verify\"),\n            Body::empty(),\n        )\n        .await;\n    assert_eq!(verify_response.status(), StatusCode::OK);\n    mock_server.verify().await; // Ensure the mock was called\n\n    // 4. Verify the key is now limited\n    let list_keys_response = app\n        .router\n        .clone()\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/keys\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n    let body_bytes = list_keys_response\n        .into_body()\n        .collect()\n        .await\n        .unwrap()\n        .to_bytes();\n    let keys: Vec\u003cserde_json::Value\u003e = serde_json::from_slice(\u0026body_bytes).unwrap();\n    assert_eq!(keys[0][\"id\"], key_id);\n    assert_eq!(keys[0][\"status\"], \"invalid\"); // Note: 429 is currently treated as invalid, not limited. This is ok for the test.\n\n    // 5. Call reset_key to reset its status\n    let reset_response = app\n        .authed_request(\n            Method::POST,\n            \u0026format!(\"/admin/keys/{key_id}/reset\"),\n            Body::empty(),\n        )\n        .await;\n    assert_eq!(reset_response.status(), StatusCode::OK);\n\n    // 6. Verify the key is available again\n    let list_keys_response_after_reset = app\n        .router\n        .clone()\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/keys\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n    let body_bytes_after_reset = list_keys_response_after_reset\n        .into_body()\n        .collect()\n        .await\n        .unwrap()\n        .to_bytes();\n    let keys_after_reset: Vec\u003cserde_json::Value\u003e =\n        serde_json::from_slice(\u0026body_bytes_after_reset).unwrap();\n    assert_eq!(keys_after_reset[0][\"id\"], key_id);\n    assert_eq!(keys_after_reset[0][\"status\"], \"available\");\n}\n#[tokio::test]\nasync fn test_delete_keys_success() {\n    // 1. Setup app with a config containing multiple keys\n    let mut config = get_default_config();\n    config.groups[0].api_keys.push(\"key_to_delete\".to_string());\n    let mut app = TestApp::new(config).await;\n    app.login(\"secret_admin_token\").await;\n    app.get_csrf_token().await;\n\n    // 2. Send request to delete one of the keys\n    let body = Body::from(\n        serde_json::to_string(\u0026DeleteKeysRequest {\n            group_name: \"default\".to_string(),\n            api_keys: vec![\"key_to_delete\".to_string()],\n        })\n        .unwrap(),\n    );\n\n    let response = app\n        .authed_request(Method::DELETE, \"/admin/keys\", body)\n        .await;\n    assert_eq!(response.status(), StatusCode::OK);\n\n    // 3. Verify the change by getting the config again\n    let get_config_response = app\n        .router\n        .clone()\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/config\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    let body = get_config_response\n        .into_body()\n        .collect()\n        .await\n        .unwrap()\n        .to_bytes();\n    let updated_config: AppConfig = serde_json::from_slice(\u0026body).unwrap();\n\n    let default_group = updated_config\n        .groups\n        .iter()\n        .find(|g| g.name == \"default\")\n        .unwrap();\n    assert_eq!(default_group.api_keys.len(), 1);\n    assert!(default_group.api_keys.contains(\u0026\"key1\".to_string()));\n    assert!(\n        !default_group\n            .api_keys\n            .contains(\u0026\"key_to_delete\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn test_update_config_success() {\n    // 1. Setup app with initial config\n    let initial_config = get_default_config();\n    let mut app = TestApp::new(initial_config).await;\n    app.login(\"secret_admin_token\").await;\n    app.get_csrf_token().await;\n\n    // 2. Create a new, modified config\n    let mut new_config = get_default_config();\n    new_config.server.port = 9999; // Change a server setting\n    new_config.groups[0].name = \"renamed_group\".to_string(); // Change a group setting\n    new_config.groups[0]\n        .api_keys\n        .push(\"new_key_in_updated_config\".to_string());\n\n    // 3. Send request to update the config\n    let body = Body::from(serde_json::to_string(\u0026new_config).unwrap());\n    let response = app.authed_request(Method::PUT, \"/admin/config\", body).await;\n    assert_eq!(response.status(), StatusCode::OK);\n\n    // 4. Verify the change by getting the config again\n    let get_config_response = app\n        .router\n        .clone()\n        .oneshot(\n            Request::builder()\n                .uri(\"/admin/config\")\n                .header(header::COOKIE, app.auth_cookie.as_ref().unwrap())\n                .body(Body::empty())\n                .unwrap(),\n        )\n        .await\n        .unwrap();\n\n    let body = get_config_response\n        .into_body()\n        .collect()\n        .await\n        .unwrap()\n        .to_bytes();\n    let updated_config: AppConfig = serde_json::from_slice(\u0026body).unwrap();\n\n    // Assert that the fetched config matches the new config\n    assert_eq!(updated_config.server.port, 9999);\n    assert_eq!(updated_config.groups.len(), 1);\n    assert_eq!(updated_config.groups[0].name, \"renamed_group\");\n    assert_eq!(updated_config.groups[0].api_keys.len(), 2);\n    assert!(\n        updated_config.groups[0]\n            .api_keys\n            .contains(\u0026\"new_key_in_updated_config\".to_string())\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","tests","integration_tests.rs"],"content":"// tests/integration_tests.rs\n\nuse axum::{\n    // body::Bytes as _, // Removed unused import placeholder\n    extract::{Request, State},\n    http::{/* header, */ Method, StatusCode, Uri}, // Removed unused header\n    response::Response,\n};\nuse gemini_proxy_key_rotation_rust::{\n    config::{AppConfig, KeyGroup, ServerConfig},\n    handler, // Import the handler module\n    // key_manager::FlattenedKeyInfo, // Removed unused import\n    // proxy,\n    state::AppState,\n};\nuse std::{fs::File, path::PathBuf, sync::Arc};\nuse tempfile::tempdir;\nuse wiremock::{\n    Mock,\n    MockServer,\n    ResponseTemplate,\n    matchers::{method, path, path_regex, query_param}, // Use path and query_param\n};\n\n// Helper function to create a basic AppConfig for testing\nfn create_test_config(groups: Vec\u003cKeyGroup\u003e, server_port: u16) -\u003e AppConfig {\n    AppConfig {\n        server: ServerConfig {\n            port: server_port,\n            top_p: None,\n            admin_token: Some(\"test_token\".to_string()),\n        },\n        groups,\n        internal_retries: 3,\n        temporary_block_minutes: 1,\n    }\n}\n\n// Helper to create a dummy config file path within a temp dir\nfn create_dummy_config_path_for_test(dir: \u0026tempfile::TempDir) -\u003e PathBuf {\n    let file_path = dir.path().join(\"dummy_config_for_test.yaml\");\n    // Create the file, but content doesn't strictly matter for these handler tests\n    File::create(\u0026file_path).expect(\"Failed to create dummy config file\");\n    file_path\n}\n\n// Helper to make a request to the proxy handler\nasync fn call_proxy_handler(\n    state: Arc\u003cAppState\u003e,\n    method: Method,\n    path: \u0026str,\n    body: axum::body::Body,\n) -\u003e Response {\n    let uri: Uri = format!(\"http://test-proxy.com{path}\") // Base URL doesn't matter here\n        .parse()\n        .expect(\"Failed to parse test URI for handler\");\n    let request = Request::builder()\n        .method(method)\n        .uri(uri)\n        .body(body) // Use empty body for GET/POST tests for simplicity\n        .unwrap();\n\n    // Call the actual handler function\n    handler::proxy_handler(State(state), request)\n        .await\n        .expect(\"Proxy handler returned an error\") // Unwrap the Result\u003cResponse, AppError\u003e\n}\n\n#[tokio::test]\nasync fn test_forward_request_openai_compat_success_no_proxy() {\n    // This test now implicitly tests the handler as well for the success path.\n    // We can keep it or refactor it slightly to use call_proxy_handler.\n    // Let's keep it for now as it tests proxy::forward_request logic well.\n\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"test-key-123\";\n    let test_path = \"/v1/models\";\n    let expected_path = \"/v1beta/openai/models\";\n    // let _expected_bearer = format!(\"Bearer {}\", test_api_key); // Unused now\n\n    Mock::given(method(\"GET\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", test_api_key)) // Match key in query param\n        // Removed header matchers\n        .respond_with(\n            ResponseTemplate::new(200).set_body_string(\"{\\\"object\\\": \\\"list\\\", \\\"data\\\": []}\"),\n        )\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"test-group\".to_string(),\n        api_keys: vec![test_api_key.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9999);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    ); // Wrap in Arc\n\n    // 3. Call handler directly\n    let response =\n        call_proxy_handler(app_state, Method::GET, test_path, axum::body::Body::empty()).await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200)\"\n    );\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .expect(\"Failed to read response body\");\n    let body_str = String::from_utf8(body_bytes.to_vec()).expect(\"Body not UTF-8\");\n    assert!(body_str.contains(\"list\"), \"Response body mismatch\");\n}\n\n#[tokio::test]\nasync fn test_handler_retries_on_429_and_succeeds() {\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let key1 = \"key-limited\";\n    let key2 = \"key-working\";\n    let test_path = \"/v1/generateContent\";\n    let expected_path = \"/v1beta/openai/generateContent\";\n\n    // Mock for the first key (key1) - returns 429\n    Mock::given(method(\"POST\")) // Assuming POST for generateContent\n        .and(path(expected_path))\n        .and(query_param(\"key\", key1)) // Match key in query param\n        // Removed header matcher\n        .respond_with(ResponseTemplate::new(429).set_body_string(\"Rate limit exceeded\"))\n        .mount(\u0026server)\n        .await;\n\n    // Mock for the second key (key2) - returns 200\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key2)) // Match key in query param\n        // Removed header matcher\n        .respond_with(ResponseTemplate::new(200).set_body_string(\"{\\\"candidates\\\": []}\")) // Example success response\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    // Key order matters for the round-robin\n    let test_group = KeyGroup {\n        name: \"retry-group\".to_string(),\n        api_keys: vec![key1.to_string(), key2.to_string()], // key1 will be tried first\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9998); // Different port just in case\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler\n    // We expect the handler to try key1, get 429, mark it, try key2, get 200, and return 200.\n    let response = call_proxy_handler(\n        app_state,\n        Method::POST,\n        test_path,\n        axum::body::Body::empty(),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) after retry\"\n    );\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .expect(\"Failed to read success response body\");\n    let body_str = String::from_utf8(body_bytes.to_vec()).expect(\"Success body not UTF-8\");\n    assert!(\n        body_str.contains(\"candidates\"),\n        \"Success response body mismatch\"\n    );\n\n    // TODO: Optionally, check the persisted state file to ensure key1 is marked as limited.\n    // This requires reading the state file (`key_states.json`) from the temp_dir.\n}\n\n#[tokio::test]\nasync fn test_handler_returns_last_429_on_exhaustion() {\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let key1 = \"key-exhausted-1\";\n    let key2 = \"key-exhausted-2\";\n    let test_path = \"/v1/models\"; // Using GET for simplicity here\n    let expected_path = \"/v1beta/openai/models\";\n\n    // Mock for the first key (key1) - returns 429\n    Mock::given(method(\"GET\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key1)) // Match key in query param\n        // Removed header matcher\n        .respond_with(ResponseTemplate::new(429).set_body_string(\"Rate limit 1\"))\n        .mount(\u0026server)\n        .await;\n\n    // Mock for the second key (key2) - also returns 429\n    Mock::given(method(\"GET\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key2)) // Match key in query param\n        // Removed header matcher\n        .respond_with(ResponseTemplate::new(429).set_body_string(\"Rate limit 2\")) // Different body to check which 429 is returned\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"exhaust-group\".to_string(),\n        api_keys: vec![key1.to_string(), key2.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9997);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler\n    // We expect the handler to try key1 (429), try key2 (429), run out of keys, and return the *last* 429 response.\n    let response =\n        call_proxy_handler(app_state, Method::GET, test_path, axum::body::Body::empty()).await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::TOO_MANY_REQUESTS,\n        \"Expected status 429 when all keys are exhausted\"\n    );\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .expect(\"Failed to read 429 response body\");\n    let body_str = String::from_utf8(body_bytes.to_vec()).expect(\"429 body not UTF-8\");\n    // Check it returned the body from the *second* 429 response\n    assert!(\n        body_str.contains(\"Rate limit 2\"),\n        \"Expected body from the last 429 response, got: {body_str}\"\n    );\n}\n\n#[tokio::test]\nasync fn test_handler_group_round_robin() {\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_path = \"/v1/models\";\n    let expected_path = \"/v1beta/openai/models\";\n\n    let g1_key1 = \"g1-key-1\";\n    let g1_key2 = \"g1-key-2\";\n    let g2_key1 = \"g2-key-1\"; // Single key in this group\n    let g3_key1 = \"g3-key-1\";\n\n    // Mock successful responses for all keys initially\n    for key in [g1_key1, g1_key2, g2_key1, g3_key1] {\n        Mock::given(method(\"GET\"))\n            .and(path_regex(format!(\"^{expected_path}.*\"))) // Match any path starting with test_path\n            .and(query_param(\"key\", key))\n            .respond_with(\n                ResponseTemplate::new(200).set_body_string(format!(\"{{\\\"key_used\\\": \\\"{key}\\\"}}\")),\n            )\n            .mount(\u0026server)\n            .await;\n    }\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let groups = vec![\n        KeyGroup {\n            name: \"group1\".to_string(),\n            api_keys: vec![g1_key1.to_string(), g1_key2.to_string()],\n            target_url: server.uri(),\n            proxy_url: None,\n            top_p: None,\n        },\n        KeyGroup {\n            name: \"group2\".to_string(),\n            api_keys: vec![g2_key1.to_string()],\n            target_url: server.uri(),\n            proxy_url: None,\n            top_p: None,\n        },\n        KeyGroup {\n            name: \"group3\".to_string(),\n            api_keys: vec![g3_key1.to_string()],\n            target_url: server.uri(),\n            proxy_url: None,\n            top_p: None,\n        },\n    ];\n    let config = create_test_config(groups, 9996);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // Helper to extract key from response body\n    async fn get_key_from_response(response: Response) -\u003e String {\n        let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n            .await\n            .expect(\"Failed to read response body\");\n        let body_json: serde_json::Value =\n            serde_json::from_slice(\u0026body_bytes).expect(\"Invalid JSON\");\n        body_json[\"key_used\"].as_str().unwrap().to_string()\n    }\n\n    // 3. Call handler multiple times and check key rotation\n    // Expected sequence: g1k1, g2k1, g3k1, g1k2, g2k1, g3k1, g1k1, ...\n\n    let res1 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=1\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res1.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res1).await, g1_key1);\n\n    let res2 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=2\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res2.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res2).await, g2_key1);\n\n    let res3 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=3\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res3.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res3).await, g3_key1);\n\n    let res4 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=4\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res4.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res4).await, g1_key2); // Next key in group1\n\n    let res5 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=5\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res5.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res5).await, g2_key1); // Back to group2 (only one key)\n\n    let res6 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=6\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res6.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res6).await, g3_key1); // Back to group3 (only one key)\n\n    let res7 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=7\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res7.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res7).await, g1_key1); // Back to start of group1\n\n    // 4. Test skipping a rate-limited group\n    // Reset mocks and set g2_key1 to return 429, others to 200\n    server.reset().await;\n    Mock::given(method(\"GET\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", g2_key1))\n        .respond_with(ResponseTemplate::new(429))\n        .mount(\u0026server)\n        .await;\n    // Remount mocks for other keys to return 200\n    for key in [g1_key1, g1_key2, g3_key1] {\n        // Exclude g2_key1\n        Mock::given(method(\"GET\"))\n            .and(path(expected_path))\n            .and(query_param(\"key\", key))\n            .respond_with(\n                ResponseTemplate::new(200).set_body_string(format!(\"{{\\\"key_used\\\": \\\"{key}\\\"}}\")),\n            )\n            .mount(\u0026server)\n            .await;\n    }\n\n    // Make a request - should hit g2k1, get 429, mark key, retry\n    // Expected sequence now: g3k1 (skips g2), g1k2 (skips g2), ...\n\n    // Current state: next should be group2 (index 1) according to previous calls\n    // Try g2k1 -\u003e 429 -\u003e mark g2k1 limited -\u003e continue search\n    // Try group3 (index 2) -\u003e g3k1 -\u003e OK\n    let res_skip1 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=8\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res_skip1.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res_skip1).await, g3_key1); // Expect g3_key1 because g2 is skipped\n\n    // Current state: next should be group0 (index 0)\n    // Try g1k2 -\u003e OK\n    let res_skip2 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=9\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res_skip2.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res_skip2).await, g1_key2);\n\n    // Current state: next should be group1 (index 1)\n    // Try g2k1 -\u003e still 429 -\u003e continue search\n    // Try group3 (index 2) -\u003e g3k1 -\u003e OK\n    let res_skip3 = call_proxy_handler(\n        Arc::clone(\u0026app_state),\n        Method::GET,\n        \u0026format!(\"{test_path}?req=10\"),\n        axum::body::Body::empty(),\n    )\n    .await;\n    assert_eq!(res_skip3.status(), StatusCode::OK);\n    assert_eq!(get_key_from_response(res_skip3).await, g3_key1);\n}\n\n// TODO: Add more tests from the plan:\n// - Test with POST /v1/chat/completions and body forwarding (similar structure, just change method and add body to request/mocks)\n// - Test error scenarios (e.g., mock server returning 500) -\u003e Handler should return the corresponding error response immediately\n// - Test persistence logic explicitly by reading/writing state file.\n// - Test SOCKS5 proxy scenario (more complex setup needed)\n\n#[tokio::test]\nasync fn test_openai_top_p_injection_correctly() {\n    // Goal: Verify that top_p is injected at the top level for OpenAI compatibility.\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"openai-top-p-key\";\n    let test_path = \"/v1/chat/completions\";\n    let expected_path = \"/v1beta/openai/chat/completions\";\n    let top_p_value = 0.88f32;\n\n    // Mock to verify the body modification\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", test_api_key))\n        .and(move |req: \u0026wiremock::Request| {\n            // Custom matcher to inspect the body for a top-level \"top_p\"\n            if let Ok(body_json) = serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026req.body) {\n                if let Some(top_p) = body_json.get(\"top_p\") {\n                    return top_p\n                        .as_f64()\n                        .is_some_and(|v| (v as f32 - top_p_value).abs() \u003c f32::EPSILON);\n                }\n            }\n            false\n        })\n        .respond_with(ResponseTemplate::new(200).set_body_json(\n            serde_json::json!({ \"id\": \"chatcmpl-123\", \"object\": \"chat.completion\" }),\n        ))\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n\n    // Create a new AppConfig with top_p at the server level for this test\n    let mut config = create_test_config(\n        vec![KeyGroup {\n            name: \"openai-top-p-group\".to_string(),\n            api_keys: vec![test_api_key.to_string()],\n            target_url: server.uri(),\n            proxy_url: None,\n            top_p: None, // Group level top_p is not used for this path\n        }],\n        9993,\n    );\n    config.server.top_p = Some(top_p_value); // Set top_p at the server level\n\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler with a standard OpenAI body\n    let original_body = serde_json::json!({\n        \"model\": \"gpt-4\",\n        \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n    });\n    let body_bytes = serde_json::to_vec(\u0026original_body).unwrap();\n    let response = call_proxy_handler(\n        app_state,\n        Method::POST,\n        test_path,\n        axum::body::Body::from(body_bytes),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) with top_p injected for openai compat\"\n    );\n}\n\n#[tokio::test]\nasync fn test_health_detailed_maps_to_models_endpoint() {\n    // Goal: Verify that /health/detailed calls the upstream /v1beta/models endpoint.\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"health-check-key\";\n    let models_path = \"/v1beta/models\";\n    let mock_response_body = serde_json::json!({ \"data\": [\"model1\"] });\n\n    // Mock for the upstream models endpoint\n    Mock::given(method(\"GET\"))\n        .and(path(models_path))\n        .and(query_param(\"key\", test_api_key))\n        .respond_with(ResponseTemplate::new(200).set_body_json(\u0026mock_response_body))\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"health-group\".to_string(),\n        api_keys: vec![test_api_key.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9992);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler for the /health/detailed path\n    let response = call_proxy_handler(\n        app_state,\n        Method::GET,\n        \"/health/detailed\",\n        axum::body::Body::empty(),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) for /health/detailed\"\n    );\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .expect(\"Failed to read response body\");\n    let body_json: serde_json::Value =\n        serde_json::from_slice(\u0026body_bytes).expect(\"Invalid JSON response\");\n    assert_eq!(\n        body_json, mock_response_body,\n        \"Response body from /health/detailed did not match expected models list\"\n    );\n}\n\n#[tokio::test]\nasync fn test_content_length_is_updated_after_top_p_injection() {\n    // Goal: Verify Content-Length is recalculated after body modification.\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"content-length-key\";\n    let test_path = \"/v1/chat/completions\";\n    let expected_path = \"/v1beta/openai/chat/completions\";\n    let top_p_value = 0.88f32;\n\n    // The original body without top_p\n    let original_body = serde_json::json!({\n        \"model\": \"gpt-4\",\n        \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n    });\n\n    // The expected body *after* injection\n    let mut expected_body_json = original_body.clone();\n    expected_body_json[\"top_p\"] = serde_json::json!(top_p_value);\n    let expected_body_bytes = serde_json::to_vec(\u0026expected_body_json).unwrap();\n    let expected_content_length = expected_body_bytes.len().to_string();\n\n    // Mock to verify the body and the Content-Length header\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", test_api_key))\n        .and(move |req: \u0026wiremock::Request| {\n            // Check Content-Length header first\n            let has_correct_content_length = req\n                .headers\n                .get(\"Content-Length\")\n                .is_some_and(|val| val.to_str().unwrap() == expected_content_length);\n\n            if !has_correct_content_length {\n                return false;\n            }\n\n            // Check body content\n            if let Ok(body_json) = serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026req.body) {\n                if let Some(top_p) = body_json.get(\"top_p\") {\n                    return top_p\n                        .as_f64()\n                        .is_some_and(|v| (v as f32 - top_p_value).abs() \u003c f32::EPSILON);\n                }\n            }\n            false\n        })\n        .respond_with(ResponseTemplate::new(200).set_body_json(\n            serde_json::json!({ \"id\": \"chatcmpl-456\", \"object\": \"chat.completion\" }),\n        ))\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n\n    let mut config = create_test_config(\n        vec![KeyGroup {\n            name: \"content-length-group\".to_string(),\n            api_keys: vec![test_api_key.to_string()],\n            target_url: server.uri(),\n            proxy_url: None,\n            top_p: None,\n        }],\n        9991,\n    );\n    config.server.top_p = Some(top_p_value);\n\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler\n    let body_bytes = serde_json::to_vec(\u0026original_body).unwrap();\n    let response = call_proxy_handler(\n        app_state,\n        Method::POST,\n        test_path,\n        axum::body::Body::from(body_bytes),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) with correct content-length\"\n    );\n}\n\n#[tokio::test]\nasync fn test_top_p_client_precedence() {\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"client-precedence-key\";\n    let test_path = \"/v1/models:generateContent\";\n    let expected_path = \"/v1beta/openai/models:generateContent\";\n    let server_top_p = 0.5; // Server-side config\n    let client_top_p = 0.99; // Client-side value, should win\n\n    // Mock to verify that the client's top_p is what arrives\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", test_api_key))\n        .and(move |req: \u0026wiremock::Request| {\n            // Custom matcher to inspect the body\n            if let Ok(body_json) = serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026req.body) {\n                if let Some(config) = body_json.get(\"generationConfig\") {\n                    if let Some(top_p) = config.get(\"topP\") {\n                        // Check that the value is the one from the client\n                        return top_p\n                            .as_f64()\n                            .is_some_and(|v| (v - client_top_p).abs() \u003c f64::EPSILON);\n                    }\n                }\n            }\n            false\n        })\n        .respond_with(\n            ResponseTemplate::new(200).set_body_json(serde_json::json!({ \"candidates\": [] })),\n        )\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"client-precedence-group\".to_string(),\n        api_keys: vec![test_api_key.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: Some(server_top_p), // Set a server-side value\n    };\n    let config = create_test_config(vec![test_group], 9994);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler with a body that already contains topP\n    let original_body = serde_json::json!({\n        \"contents\": [{\"role\": \"user\", \"parts\": [{\"text\": \"Hello\"}]}],\n        \"generationConfig\": {\n            \"temperature\": 0.7,\n            \"topP\": client_top_p // Client provides topP\n        }\n    });\n    let body_bytes = serde_json::to_vec(\u0026original_body).unwrap();\n    let response = call_proxy_handler(\n        app_state,\n        Method::POST,\n        test_path,\n        axum::body::Body::from(body_bytes),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) when client top_p takes precedence\"\n    );\n}\n\n#[tokio::test]\nasync fn test_url_translation_for_v1_path() {\n    // Goal: Verify that a request to a `/v1/...` path is translated to `/v1beta/openai/...`\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"translation-key-v1\";\n    let incoming_path = \"/v1/chat/completions\";\n    let expected_translated_path = \"/v1beta/openai/chat/completions\";\n\n    // Mock to expect the *translated* path\n    Mock::given(method(\"POST\"))\n        .and(path(expected_translated_path))\n        .and(query_param(\"key\", test_api_key))\n        .respond_with(\n            ResponseTemplate::new(200).set_body_json(serde_json::json!({ \"status\": \"ok\" })),\n        )\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"translation-group\".to_string(),\n        api_keys: vec![test_api_key.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9990);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler with the original `/v1/...` path\n    let response = call_proxy_handler(\n        app_state,\n        Method::POST,\n        incoming_path,\n        axum::body::Body::empty(),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) for translated v1 path\"\n    );\n    // The mock server implicitly verifies that the path was translated correctly.\n    // If the request had gone to the original path, the mock would not have matched,\n    // and wiremock would have returned a 404, failing the test.\n}\n\n#[tokio::test]\nasync fn test_url_translation_for_non_v1_path() {\n    // Goal: Verify that a request to a path NOT starting with `/v1/` is NOT translated.\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let test_api_key = \"translation-key-non-v1\";\n    let incoming_path = \"/health\"; // A non-v1 path\n\n    // Mock to expect the *original* path, unchanged\n    Mock::given(method(\"GET\"))\n        .and(path(incoming_path))\n        .and(query_param(\"key\", test_api_key))\n        .respond_with(\n            ResponseTemplate::new(200).set_body_json(serde_json::json!({ \"status\": \"healthy\" })),\n        )\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"non-translation-group\".to_string(),\n        api_keys: vec![test_api_key.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9989);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler with the non-v1 path\n    let response = call_proxy_handler(\n        app_state,\n        Method::GET,\n        incoming_path,\n        axum::body::Body::empty(),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) for non-v1 path\"\n    );\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    let body_str = String::from_utf8(body_bytes.to_vec()).unwrap();\n    assert!(body_str.contains(\"healthy\"));\n}\n\n#[tokio::test]\nasync fn test_rotates_on_400_with_api_key_invalid_body() {\n    // Verifies that if a key returns 400 with \"API_KEY_INVALID\",\n    // the handler marks it as invalid and retries with the next key.\n\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let key1_invalid = \"key-invalid-400-special\";\n    let key2_valid = \"key-valid-after-400\";\n    let test_path = \"/v1/chat/completions\";\n    let expected_path = \"/v1beta/openai/chat/completions\";\n\n    // Mock for the first key (key1_invalid) - returns 400 with specific body\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key1_invalid))\n        .respond_with(\n            ResponseTemplate::new(400)\n                .set_body_string(\"API key not valid. Please pass a valid API key. API_KEY_INVALID\"),\n        )\n        .mount(\u0026server)\n        .await;\n\n    // Mock for the second key (key2_valid) - returns 200\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key2_valid))\n        .respond_with(ResponseTemplate::new(200).set_body_string(\"{\\\"candidates\\\": []}\"))\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"retry-400-invalid-group\".to_string(),\n        api_keys: vec![key1_invalid.to_string(), key2_valid.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9988);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler\n    let response = call_proxy_handler(\n        app_state.clone(),\n        Method::POST,\n        test_path,\n        axum::body::Body::empty(),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::OK,\n        \"Expected status OK (200) after retry on 400 with API_KEY_INVALID\"\n    );\n\n    // Verify that the first key is now marked as invalid\n    let is_invalid = app_state\n        .key_manager\n        .read()\n        .await\n        .is_key_invalid(key1_invalid);\n    assert!(is_invalid, \"Expected the first key to be marked as invalid\");\n}\n\n#[tokio::test]\nasync fn test_returns_immediately_on_400_with_other_body() {\n    // Verifies that if a key returns 400 without \"API_KEY_INVALID\",\n    // the handler immediately returns the 400 response without retrying.\n\n    // 1. Setup Mock Server\n    let server = MockServer::start().await;\n    let key1 = \"key-400-other-error\";\n    let key2 = \"key-should-not-be-used\";\n    let test_path = \"/v1/chat/completions\";\n    let expected_path = \"/v1beta/openai/chat/completions\";\n    let error_body = \"Some other bad request error\";\n\n    // Mock for the first key - returns 400 with a generic body\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key1))\n        .respond_with(ResponseTemplate::new(400).set_body_string(error_body))\n        .mount(\u0026server)\n        .await;\n\n    // A mock for the second key that should NEVER be called.\n    // If it is called, the test will fail because wiremock will report an unhandled request.\n    Mock::given(method(\"POST\"))\n        .and(path(expected_path))\n        .and(query_param(\"key\", key2))\n        .respond_with(ResponseTemplate::new(200))\n        .mount(\u0026server)\n        .await;\n\n    // 2. Setup Config and State\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n    let dummy_config_path = create_dummy_config_path_for_test(\u0026temp_dir);\n    let test_group = KeyGroup {\n        name: \"no-retry-400-group\".to_string(),\n        api_keys: vec![key1.to_string(), key2.to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n    let config = create_test_config(vec![test_group], 9987);\n    let app_state = Arc::new(\n        AppState::new(\u0026config, \u0026dummy_config_path)\n            .await\n            .expect(\"AppState failed\"),\n    );\n\n    // 3. Call handler\n    let response = call_proxy_handler(\n        app_state.clone(),\n        Method::POST,\n        test_path,\n        axum::body::Body::empty(),\n    )\n    .await;\n\n    // 4. Assertions\n    assert_eq!(\n        response.status(),\n        StatusCode::BAD_REQUEST,\n        \"Expected status 400 to be returned directly\"\n    );\n    let body_bytes = axum::body::to_bytes(response.into_body(), usize::MAX)\n        .await\n        .unwrap();\n    assert_eq!(String::from_utf8_lossy(\u0026body_bytes), error_body);\n\n    // Verify that the first key was NOT marked as invalid\n    let is_invalid = app_state.key_manager.read().await.is_key_invalid(key1);\n    assert!(\n        !is_invalid,\n        \"Expected the key NOT to be marked as invalid for a generic 400 error\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","tests","main_integration_tests.rs"],"content":"use gemini_proxy_key_rotation_rust::{error::AppError, run};\nuse std::fs::File;\nuse std::io::Write;\nuse tempfile::tempdir;\n\n#[tokio::test]\nasync fn test_run_successful_startup() {\n    let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n    let config_path = temp_dir.path().join(\"config.yaml\");\n\n    let mut temp_config = File::create(\u0026config_path).expect(\"Failed to create temp config file\");\n    let config_content = r#\"\nserver:\n  port: 8080\n  admin_token: \"test_token\"\ngroups:\n  - name: \"default\"\n    api_keys: [\"key1\"]\n\"#;\n    temp_config\n        .write_all(config_content.as_bytes())\n        .expect(\"Failed to write to temp config\");\n\n    // This test now verifies that `run` can successfully initialize the application\n    // state and router when provided with a valid configuration.\n    // It no longer tests the `main` function directly, as `main` is not part of the\n    // library's public API and testing it requires fragile workarounds.\n    let result = run(Some(config_path)).await;\n\n    assert!(result.is_ok(), \"run() should succeed with a valid config\");\n}\n\n#[tokio::test]\nasync fn test_run_fails_with_invalid_config() {\n    let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n    let config_path = temp_dir.path().join(\"config.yaml\");\n\n    let mut temp_config = File::create(\u0026config_path).expect(\"Failed to create temp config file\");\n    // Invalid structure (port is a string)\n    let config_content = r#\"\nserver:\n  port: \"not-a-number\"\n  admin_token: \"test_token\"\ngroups: []\n\"#;\n    temp_config\n        .write_all(config_content.as_bytes())\n        .expect(\"Failed to write to temp config\");\n\n    let result = run(Some(config_path)).await;\n\n    assert!(matches!(result, Err(AppError::Config(_))));\n}\n\n#[tokio::test]\nasync fn test_run_fails_without_config_file() {\n    let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n\n    // Set CONFIG_PATH to a non-existent file in our temp directory\n    let config_path = temp_dir.path().join(\"non_existent_config.yaml\");\n\n    let result = run(Some(config_path)).await;\n\n    // Expect a config error because the file is required if the path is set,\n    // and default values are not sufficient to run.\n    assert!(matches!(result, Err(AppError::Config(_))));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","tests","model_specific_blocking_tests.rs"],"content":"// tests/model_specific_blocking_tests.rs\n\nuse chrono::{Duration, Utc};\nuse gemini_proxy_key_rotation_rust::config::{AppConfig, KeyGroup, ServerConfig};\nuse gemini_proxy_key_rotation_rust::key_manager::{KeyManager, ModelBlockState};\nuse tempfile::tempdir;\n\nfn create_test_config() -\u003e AppConfig {\n    AppConfig {\n        server: ServerConfig {\n            port: 8080,\n            top_p: None,\n            admin_token: None,\n        },\n        groups: vec![KeyGroup {\n            name: \"test_group\".to_string(),\n            api_keys: vec![\"test_key_1\".to_string(), \"test_key_2\".to_string()],\n            proxy_url: None,\n            target_url: \"https://generativelanguage.googleapis.com\".to_string(),\n            top_p: None,\n        }],\n\n        internal_retries: 2,\n        temporary_block_minutes: 5,\n    }\n}\n\n#[tokio::test]\nasync fn test_model_specific_key_blocking() {\n    let temp_dir = tempdir().unwrap();\n    let config_path = temp_dir.path().join(\"test_config.yaml\");\n    let config = create_test_config();\n\n    let mut key_manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n    // Initially, both keys should be available for any model\n    assert!(key_manager.is_key_available_for_model(\"test_key_1\", Some(\"gemini-pro\")));\n    assert!(key_manager.is_key_available_for_model(\"test_key_1\", Some(\"gemini-flash\")));\n    assert!(key_manager.is_key_available_for_model(\"test_key_2\", Some(\"gemini-pro\")));\n\n    // Block key_1 for gemini-pro model\n    assert!(key_manager.mark_key_as_limited_for_model(\"test_key_1\", \"gemini-pro\"));\n\n    // key_1 should be blocked for gemini-pro but available for gemini-flash\n    assert!(!key_manager.is_key_available_for_model(\"test_key_1\", Some(\"gemini-pro\")));\n    assert!(key_manager.is_key_available_for_model(\"test_key_1\", Some(\"gemini-flash\")));\n\n    // key_2 should still be available for both models\n    assert!(key_manager.is_key_available_for_model(\"test_key_2\", Some(\"gemini-pro\")));\n    assert!(key_manager.is_key_available_for_model(\"test_key_2\", Some(\"gemini-flash\")));\n\n    // Test getting next available key for specific model\n    let key_for_pro = key_manager.get_next_available_key_info_for_model(Some(\"gemini-pro\"));\n    assert!(key_for_pro.is_some());\n    assert_eq!(key_for_pro.unwrap().key, \"test_key_2\");\n\n    let key_for_flash = key_manager.get_next_available_key_info_for_model(Some(\"gemini-flash\"));\n    assert!(key_for_flash.is_some());\n    // Should get key_1 since it's available for gemini-flash\n    assert_eq!(key_for_flash.unwrap().key, \"test_key_1\");\n}\n\n#[tokio::test]\nasync fn test_model_block_cleanup() {\n    let temp_dir = tempdir().unwrap();\n    let config_path = temp_dir.path().join(\"test_config.yaml\");\n    let config = create_test_config();\n\n    let mut key_manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n    // Manually add an expired model block\n    if let Some(key_state) = key_manager.get_key_states_mut().get_mut(\"test_key_1\") {\n        key_state.model_blocks.insert(\n            \"gemini-pro\".to_string(),\n            ModelBlockState {\n                blocked_until: Utc::now() - Duration::hours(1), // Expired 1 hour ago\n                reason: \"429 quota exceeded\".to_string(),\n            },\n        );\n    }\n\n    // Verify the block exists in the data structure (even if expired)\n    let key_states = key_manager.get_key_states();\n    let key_state = key_states.get(\"test_key_1\").unwrap();\n    assert!(key_state.model_blocks.contains_key(\"gemini-pro\"));\n\n    // Run cleanup\n    let cleaned_count = key_manager.cleanup_expired_model_blocks();\n    assert_eq!(cleaned_count, 1);\n\n    // Key should be available after cleanup\n    assert!(key_manager.is_key_available_for_model(\"test_key_1\", Some(\"gemini-pro\")));\n}\n\n#[tokio::test]\nasync fn test_model_stats() {\n    let temp_dir = tempdir().unwrap();\n    let config_path = temp_dir.path().join(\"test_config.yaml\");\n    let config = create_test_config();\n\n    let mut key_manager = KeyManager::new(\u0026config, \u0026config_path).await;\n\n    // Block both keys for different models\n    key_manager.mark_key_as_limited_for_model(\"test_key_1\", \"gemini-pro\");\n    key_manager.mark_key_as_limited_for_model(\"test_key_2\", \"gemini-pro\");\n    key_manager.mark_key_as_limited_for_model(\"test_key_1\", \"gemini-flash\");\n\n    let stats = key_manager.get_model_block_stats();\n    assert_eq!(stats.get(\"gemini-pro\"), Some(\u00262)); // 2 keys blocked for gemini-pro\n    assert_eq!(stats.get(\"gemini-flash\"), Some(\u00261)); // 1 key blocked for gemini-flash\n\n    let blocked_models_info = key_manager.get_blocked_models_info();\n    assert_eq!(blocked_models_info.len(), 2); // 2 models have blocks\n\n    // Find gemini-pro in the results\n    let gemini_pro_info = blocked_models_info\n        .iter()\n        .find(|(model, _, _)| model == \"gemini-pro\")\n        .unwrap();\n    assert_eq!(gemini_pro_info.1, 2); // 2 keys blocked\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","tests","system_integration_tests.rs"],"content":"// tests/system_integration_tests.rs\n\nuse axum::http::{Method, StatusCode};\nuse futures::future;\nuse gemini_proxy_key_rotation_rust::{\n    config::{AppConfig, KeyGroup, ServerConfig},\n    handler,\n    state::AppState,\n};\nuse std::{fs::File, sync::Arc};\nuse tempfile::tempdir;\nuse wiremock::{\n    Mock, MockServer, ResponseTemplate,\n    matchers::{method, path},\n};\n\nasync fn create_test_system() -\u003e (Arc\u003cAppState\u003e, MockServer, tempfile::TempDir) {\n    let server = MockServer::start().await;\n    let temp_dir = tempdir().unwrap();\n    let config_path = temp_dir.path().join(\"config.yaml\");\n    File::create(\u0026config_path).unwrap();\n\n    let test_group = KeyGroup {\n        name: \"test-group\".to_string(),\n        api_keys: vec![\"test-key-1\".to_string(), \"test-key-2\".to_string()],\n        target_url: server.uri(),\n        proxy_url: None,\n        top_p: None,\n    };\n\n    let config = AppConfig {\n        server: ServerConfig {\n            port: 8080,\n            top_p: None,\n            admin_token: Some(\"test_token\".to_string()),\n        },\n        groups: vec![test_group],\n        internal_retries: 3,\n        temporary_block_minutes: 1,\n    };\n\n    let app_state = Arc::new(AppState::new(\u0026config, \u0026config_path).await.unwrap());\n\n    (app_state, server, temp_dir)\n}\n\n#[tokio::test]\nasync fn test_metrics_collection() {\n    let (app_state, server, _temp_dir) = create_test_system().await;\n\n    // Mock a successful request\n    Mock::given(method(\"GET\"))\n        .and(path(\"/v1beta/openai/models\"))\n        .respond_with(ResponseTemplate::new(200).set_body_json(serde_json::json!({\"data\": []})))\n        .mount(\u0026server)\n        .await;\n\n    // Make a request to generate metrics\n    let request = axum::extract::Request::builder()\n        .method(Method::GET)\n        .uri(\"/v1/models\")\n        .body(axum::body::Body::empty())\n        .unwrap();\n\n    let _response = handler::proxy_handler(axum::extract::State(app_state.clone()), request)\n        .await\n        .unwrap();\n\n    // Metrics should be recorded (this is more of a smoke test)\n    // In a real scenario, you'd check the actual metrics values\n    // but that requires more complex setup with the metrics registry\n}\n\n#[tokio::test]\nasync fn test_error_handling_and_recovery() {\n    let (app_state, server, _temp_dir) = create_test_system().await;\n\n    // Mock server error followed by success\n    Mock::given(method(\"GET\"))\n        .and(path(\"/v1beta/openai/models\"))\n        .respond_with(ResponseTemplate::new(500).set_body_string(\"Internal Server Error\"))\n        .expect(8) // Expect 1 initial + 3 internal retries for each of the 2 keys\n        .mount(\u0026server)\n        .await;\n\n    let request = axum::extract::Request::builder()\n        .method(Method::GET)\n        .uri(\"/v1/models\")\n        .body(axum::body::Body::empty())\n        .unwrap();\n\n    let response = handler::proxy_handler(axum::extract::State(app_state.clone()), request)\n        .await\n        .unwrap();\n\n    // Should return the error response\n    assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);\n}\n\n#[tokio::test]\nasync fn test_concurrent_requests() {\n    let (app_state, server, _temp_dir) = create_test_system().await;\n\n    // Mock responses for concurrent requests\n    Mock::given(method(\"GET\"))\n        .and(path(\"/v1beta/openai/models\"))\n        .respond_with(ResponseTemplate::new(200).set_body_json(serde_json::json!({\"data\": []})))\n        .expect(10)\n        .mount(\u0026server)\n        .await;\n\n    // Create multiple concurrent requests\n    let mut handles = Vec::new();\n\n    for i in 0..10 {\n        let app_state_clone = app_state.clone();\n        let handle = tokio::spawn(async move {\n            let request = axum::extract::Request::builder()\n                .method(Method::GET)\n                .uri(format!(\"/v1/models?req={i}\"))\n                .body(axum::body::Body::empty())\n                .unwrap();\n\n            handler::proxy_handler(axum::extract::State(app_state_clone), request).await\n        });\n        handles.push(handle);\n    }\n\n    // Wait for all requests to complete\n    let results = future::join_all(handles).await;\n\n    // All requests should succeed\n    for result in results {\n        let response = result.unwrap().unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>