version: '3.8'

services:
  gemini-proxy:
    # Build the image using the Dockerfile in the current directory
    build:
      context: .
      dockerfile: Dockerfile
    container_name: gemini-proxy-openai-compose
    # Use an env_file to load all environment variables from a .env file.
    # This is cleaner than listing each variable under the 'environment' key.
    # Users should copy .env.example to .env and fill in their secrets.
    env_file:
      - .env
    # Expose ports. Reads SERVER_PORT_HOST and SERVER_PORT_CONTAINER from .env,
    # with defaults if not set.
    ports:
      - "${SERVER_PORT_HOST:-8082}:${SERVER_PORT_CONTAINER:-8080}" # Maps host port to container port
    volumes:
      # Mount the key state file directly for explicit state management.
      # This makes it clear which file is being used for persistence.
      # Ensure key_states.json exists in your project root before starting: `touch key_states.json`
      - ./key_states.json:/app/key_states.json
      # Optional: Mount config.yaml if you need some settings from it that are NOT overridden by env vars.
      # - ./config.yaml:/app/config.yaml
    restart: unless-stopped
    # Healthcheck now uses wget as curl is not available in the final image.
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:${SERVER_PORT_CONTAINER:-8080}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s # Give the container time to start

# Note: The top-level 'volumes' key for 'key_state_data' is no longer needed
# as we are now using a direct bind mount for the state file.
# Ensure you have a .env file based on .env.example with your actual API keys.