<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Proxy Dashboard</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <h1>ðŸš€ Gemini Proxy Dashboard</h1>
    </div>
    
    <div class="container">
        <div class="grid">
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status" class="loading">Loading...</div>
            </div>
            
            <!-- SYSINFO_PLACEHOLDER -->

            <div class="card">
                <h2>Request Metrics</h2>
                <div id="request-metrics" class="loading">Loading...</div>
            </div>
                    </div>
        
        <div class="card">
            <h2>API Keys Status</h2>
            <button class="refresh-btn" onclick="refreshData()">Refresh</button>
            <div id="keys-status" class="loading">Loading...</div>
        </div>
    </div>

    <script>
        let refreshInterval;
        let csrfToken = null;
        
        async function loginAndReload() {
            const token = prompt('Admin token is required. Please enter it:');
            if (!token) {
                alert('No token provided. Dashboard access is limited.');
                return;
            }
            try {
                const response = await fetch('/admin/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });
                if (response.ok) {
                    alert('Login successful. The page will now reload.');
                    location.reload();
                } else {
                    alert('Login failed. Please check the token and try again.');
                }
            } catch (error) {
                alert(`An error occurred during login: ${error.message}`);
            }
        }

        async function fetchWithAuth(endpoint, options = {}) {
            const headers = { ...options.headers };
            // Add CSRF token for POST requests
            if (options.method === 'POST' && csrfToken) {
                headers['X-CSRF-Token'] = csrfToken;
            }

            try {
                const response = await fetch(endpoint, { ...options, headers });
                
                if (response.status === 401) {
                    await loginAndReload();
                    throw new Error('Unauthorized');
                }

                if (response.status === 403) {
                    alert('Security token expired. Please try again.');
                    await getCsrfTokenAndInit(); // Refresh the token
                    throw new Error('CSRF Token Expired');
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                }

                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    return response.json();
                } else {
                    return; 
                }
            } catch (error) {
                 console.error(`Fetch error for ${endpoint}:`, error);
                 throw error;
            }
        }
        
        async function fetchData(endpoint) {
            try {
                const response = await fetch(endpoint);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Failed to fetch ${endpoint}:`, error);
                throw error;
            }
        }
        
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (days > 0) return `${days}d ${hours}h ${minutes}m`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }
        
        function renderSystemStatus(data) {
            const container = document.getElementById('system-status');
            const statusClass = data.status === 'healthy' ? 'status-healthy' : 'status-error';
            
            container.innerHTML = `
                <div class="metric">
                    <span class="metric-label">
                        <span class="status-indicator ${statusClass}"></span>
                        Status
                    </span>
                    <span class="metric-value">${data.status}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Uptime</span>
                    <span class="metric-value">${formatUptime(data.uptime_seconds)}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Version</span>
                    <span class="metric-value">${data.version}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Server</span>
                    <span class="metric-value">${data.server_info.host}:${data.server_info.port}</span>
                </div>
            `;
        }
        
        function renderRequestMetrics(data) {
            const container = document.getElementById('request-metrics');
            const keyStatus = data.key_status;
            
            container.innerHTML = `
                <div class="metric">
                    <span class="metric-label">Total Keys</span>
                    <span class="metric-value">${keyStatus.total_keys}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Active Keys</span>
                    <span class="metric-value">${keyStatus.active_keys}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Limited Keys</span>
                    <span class="metric-value">${keyStatus.limited_keys}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Invalid Keys</span>
                    <span class="metric-value">${keyStatus.invalid_keys}</span>
                </div>
            `;
        }

        async function handleKeyAction(keyId, button, endpoint, loadingText, defaultText) {
            button.disabled = true;
            button.textContent = loadingText;
            try {
                await fetchWithAuth(endpoint, { method: 'POST' });
                await refreshData();
            } catch (error) {
                // Error alerts are handled in fetchWithAuth
            } finally {
                button.disabled = false;
                button.textContent = defaultText;
            }
        }

        async function verifyKey(keyId, button) {
            await handleKeyAction(keyId, button, `/admin/keys/${keyId}/verify`, 'Verifying...', 'Verify');
        }

        async function resetKey(keyId, button) {
            await handleKeyAction(keyId, button, `/admin/keys/${keyId}/reset`, 'Resetting...', 'Reset');
        }

        async function renderKeysStatus() {
            const container = document.getElementById('keys-status');
            
            try {
                const keys = await fetchData('/admin/keys');
                
                if (keys.length === 0) {
                    container.innerHTML = '<div class="loading">No API keys found</div>';
                    return;
                }
                
                const keysByGroup = keys.reduce((acc, key) => {
                    if (!acc[key.group_name]) acc[key.group_name] = [];
                    acc[key.group_name].push(key);
                    return acc;
                }, {});
                
                let html = '<div class="key-list">';
                
                for (const [groupName, groupKeys] of Object.entries(keysByGroup)) {
                    html += `<h3 class="group-header">Group: ${groupName}</h3>`;
                    
                    groupKeys.forEach(key => {
                        const statusClassMap = {
                            'available': 'status-active',
                            'limited': 'status-limited',
                            'unavailable': 'status-limited',
                            'invalid': 'status-quarantined'
                        };
                        const statusClass = statusClassMap[key.status] || 'status-quarantined';
                        const isResettable = key.status !== 'available';

                        html += `
                            <div class="key-item ${key.status}" id="key-item-${key.id}">
                                <div class="key-info">
                                    <div class="key-preview">${key.key_preview}</div>
                                    <small class="key-id">ID: ${key.id}</small>
                                </div>
                                <div class="key-status ${statusClass}">${key.status}</div>
                                <div class="key-controls">
                                    <button class="key-btn" onclick="verifyKey('${key.id}', this)">Verify</button>
                                    <button class="key-btn" onclick="resetKey('${key.id}', this)" ${!isResettable ? 'disabled' : ''}>Reset</button>
                                </div>
                            </div>
                        `;
                    });
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (error) {
                container.innerHTML = `<div class="error">Failed to load keys: ${error.message}</div>`;
            }
        }
        
        async function getCsrfTokenAndInit() {
            try {
                const tokenResponse = await fetch('/admin/csrf-token');
                if (!tokenResponse.ok) {
                    throw new Error('Could not fetch CSRF token');
                }
                const tokenData = await tokenResponse.json();
                csrfToken = tokenData.csrf_token;
                
                // Now that we have the token, proceed with loading data
                await refreshData();
            } catch (error) {
                 console.error('Initialization failed:', error);
                 document.querySelectorAll('.loading').forEach(el => {
                    el.innerHTML = `<div class="error">Initialization failed: ${error.message}</div>`;
                });
            }
        }

        async function refreshData() {
            try {
                const healthData = await fetchData('/admin/health');
                renderSystemStatus(healthData);
                renderRequestMetrics(healthData);
                
                await renderKeysStatus();
            } catch (error) {
                console.error('Failed to refresh data:', error);
                document.querySelectorAll('.loading').forEach(el => {
                    el.innerHTML = `<div class="error">Failed to load data: ${error.message}</div>`;
                });
            }
        }
        
        // Initial load
        getCsrfTokenAndInit();
        
        // Auto-refresh every 30 seconds
        refreshInterval = setInterval(refreshData, 30000);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });
    </script>
</body>
</html>