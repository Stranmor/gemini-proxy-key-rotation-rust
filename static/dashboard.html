<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Proxy Dashboard</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <h1>üöÄ Gemini Proxy Dashboard</h1>
        <nav>
            <a href="/admin/keys-page">Key Management</a>
        </nav>
    </div>
    
    <div class="container">
        <div class="grid">
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status" class="loading">Loading...</div>
            </div>
            
            <!-- SYSINFO_PLACEHOLDER -->

            <div class="card">
                <h2>Request Metrics</h2>
                <div id="request-metrics" class="loading">Loading...</div>
            </div>
                    </div>
        
        <div class="card">
            <h2>Model-Specific Key Blocking</h2>
            <div id="model-stats" class="loading">Loading...</div>
        </div>
        
        <div class="card">
            <h2>API Keys Status</h2>
            <div class="card-controls">
                <button class="refresh-btn" onclick="manualRefresh()">Auto-Refresh: ON</button>
                <button class="toggle-refresh-btn" onclick="toggleAutoRefresh()" title="Toggle auto-refresh">‚è∏Ô∏è</button>
            </div>
            <div id="keys-status" class="loading">Loading...</div>
        </div>
    </div>

    <script>
        let refreshInterval;
        let csrfToken = null;
        
        async function loginAndReload() {
            const token = prompt('Admin token is required. Please enter it:');
            if (!token) {
                alert('No token provided. Dashboard access is limited.');
                return;
            }
            try {
                const response = await fetch('/admin/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });
                if (response.ok) {
                    alert('Login successful. The page will now reload.');
                    location.reload();
                } else {
                    alert('Login failed. Please check the token and try again.');
                }
            } catch (error) {
                alert(`An error occurred during login: ${error.message}`);
            }
        }

        async function fetchWithAuth(endpoint, options = {}) {
            const headers = { ...options.headers };
            // Add CSRF token for POST requests
            if (options.method === 'POST' && csrfToken) {
                headers['X-CSRF-Token'] = csrfToken;
            }

            try {
                const response = await fetch(endpoint, { ...options, headers });
                
                if (response.status === 401) {
                    await loginAndReload();
                    throw new Error('Unauthorized');
                }

                if (response.status === 403) {
                    alert('Security token expired. Please try again.');
                    await getCsrfTokenAndInit(); // Refresh the token
                    throw new Error('CSRF Token Expired');
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                }

                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    return response.json();
                } else {
                    return; 
                }
            } catch (error) {
                 console.error(`Fetch error for ${endpoint}:`, error);
                 throw error;
            }
        }
        
        async function fetchData(endpoint) {
            try {
                const response = await fetch(endpoint);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Failed to fetch ${endpoint}:`, error);
                throw error;
            }
        }
        
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (days > 0) return `${days}d ${hours}h ${minutes}m`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }
        
        function renderSystemStatus(data) {
            const container = document.getElementById('system-status');
            const statusClass = data.status === 'healthy' ? 'status-healthy' : 'status-error';
            
            container.innerHTML = `
                <div class="metric">
                    <span class="metric-label">
                        <span class="status-indicator ${statusClass}"></span>
                        Status
                    </span>
                    <span class="metric-value">${data.status}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Uptime</span>
                    <span class="metric-value">${formatUptime(data.uptime_seconds)}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Version</span>
                    <span class="metric-value">${data.version}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Server</span>
                    <span class="metric-value">${data.server_info.host}:${data.server_info.port}</span>
                </div>
                ${data.system_info ? `
                    <div class="metric">
                        <span class="metric-label">Memory</span>
                        <span class="metric-value">${data.system_info.memory_usage_mb}MB / ${data.system_info.total_memory_mb}MB</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">CPU</span>
                        <span class="metric-value">${data.system_info.cpu_usage_percent.toFixed(1)}%</span>
                    </div>
                ` : ''}
            `;
        }
        
        function renderRequestMetrics(data) {
            const container = document.getElementById('request-metrics');
            const keyStatus = data.key_status;
            
            const totalKeys = keyStatus.total_keys;
            const activePercentage = totalKeys > 0 ? Math.round((keyStatus.active_keys / totalKeys) * 100) : 0;
            
            container.innerHTML = `
                <div class="metrics-grid">
                    <div class="metric-card total">
                        <div class="metric-value">${keyStatus.total_keys}</div>
                        <div class="metric-label">Total Keys</div>
                    </div>
                    <div class="metric-card active">
                        <div class="metric-value">${keyStatus.active_keys}</div>
                        <div class="metric-label">Active Keys</div>
                        <div class="metric-percentage">${activePercentage}%</div>
                    </div>
                    <div class="metric-card limited">
                        <div class="metric-value">${keyStatus.limited_keys}</div>
                        <div class="metric-label">Limited Keys</div>
                    </div>
                    <div class="metric-card invalid">
                        <div class="metric-value">${keyStatus.invalid_keys}</div>
                        <div class="metric-label">Invalid Keys</div>
                    </div>
                    ${keyStatus.temporarily_unavailable_keys > 0 ? `
                        <div class="metric-card unavailable">
                            <div class="metric-value">${keyStatus.temporarily_unavailable_keys}</div>
                            <div class="metric-label">Temporarily Unavailable</div>
                        </div>
                    ` : ''}
                </div>
                ${keyStatus.groups && keyStatus.groups.length > 0 ? `
                    <div class="groups-summary">
                        <h4>Groups Overview</h4>
                        ${keyStatus.groups.map(group => `
                            <div class="group-summary">
                                <span class="group-name">${group.name}</span>
                                <span class="group-stats">${group.active_keys}/${group.total_keys} active</span>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }

        async function handleKeyAction(keyId, button, endpoint, loadingText, defaultText, successMessage) {
            const originalText = button.textContent;
            const keyItem = button.closest('.key-item');
            
            button.disabled = true;
            button.textContent = loadingText;
            button.classList.add('loading');
            
            try {
                await fetchWithAuth(endpoint, { method: 'POST' });
                
                // Show success feedback
                button.textContent = '‚úì';
                button.classList.add('success');
                
                // Refresh only the keys section for better UX
                await renderKeysStatus();
                
                // Show temporary success message
                if (successMessage) {
                    showNotification(successMessage, 'success');
                }
                
                setTimeout(() => {
                    if (button) {
                        button.classList.remove('success');
                        button.textContent = defaultText;
                    }
                }, 2000);
                
            } catch (error) {
                button.textContent = '‚úó';
                button.classList.add('error');
                showNotification(`Action failed: ${error.message}`, 'error');
                
                setTimeout(() => {
                    if (button) {
                        button.classList.remove('error');
                        button.textContent = defaultText;
                    }
                }, 3000);
            } finally {
                button.disabled = false;
                button.classList.remove('loading');
            }
        }

        async function verifyKey(keyId, button) {
            await handleKeyAction(
                keyId, 
                button, 
                `/admin/keys/${keyId}/verify`, 
                'Verifying...', 
                'Verify',
                'Key verification completed'
            );
        }

        async function resetKey(keyId, button) {
            await handleKeyAction(
                keyId, 
                button, 
                `/admin/keys/${keyId}/reset`, 
                'Resetting...', 
                'Reset',
                'Key status reset successfully'
            );
        }

        function showNotification(message, type = 'info') {
            // Remove existing notifications
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
            
            // Allow manual dismissal
            notification.addEventListener('click', () => notification.remove());
        }

        function formatTimeUntil(targetTime) {
            const now = new Date();
            const diff = targetTime - now;
            
            if (diff <= 0) return 'expired';
            
            const minutes = Math.floor(diff / (1000 * 60));
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ${hours % 24}h`;
            if (hours > 0) return `${hours}h ${minutes % 60}m`;
            return `${minutes}m`;
        }

        async function renderModelStats() {
            const container = document.getElementById('model-stats');
            
            try {
                const data = await fetchData('/admin/model-stats');
                
                if (!data.models || data.models.length === 0) {
                    container.innerHTML = '<div class="info">No model-specific blocks found</div>';
                    return;
                }
                
                let html = '<div class="model-stats-list">';
                html += `<div class="stats-header">Total Keys: ${data.total_keys} | Updated: ${new Date(data.timestamp).toLocaleString()}</div>`;
                
                data.models.forEach(model => {
                    const resetTime = new Date(model.next_reset_time);
                    const timeUntilReset = formatTimeUntil(resetTime);
                    const percentage = Math.round((model.blocked_keys_count / data.total_keys) * 100);
                    
                    html += `
                        <div class="model-stat-item">
                            <div class="model-info">
                                <div class="model-name">${model.model}</div>
                                <div class="model-details">
                                    <span class="blocked-count">${model.blocked_keys_count} blocked keys</span>
                                    <span class="reset-time">Reset: ${timeUntilReset}</span>
                                </div>
                            </div>
                            <div class="model-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${percentage}%"></div>
                                </div>
                                <span class="progress-text">${percentage}%</span>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (error) {
                container.innerHTML = `<div class="error">Failed to load model stats: ${error.message}</div>`;
            }
        }

        async function renderKeysStatus() {
            const container = document.getElementById('keys-status');
            
            try {
                const keys = await fetchData('/admin/keys');
                
                if (keys.length === 0) {
                    container.innerHTML = '<div class="info">No API keys found</div>';
                    return;
                }
                
                const keysByGroup = keys.reduce((acc, key) => {
                    if (!acc[key.group_name]) acc[key.group_name] = [];
                    acc[key.group_name].push(key);
                    return acc;
                }, {});
                
                let html = '<div class="key-list">';
                
                for (const [groupName, groupKeys] of Object.entries(keysByGroup)) {
                    const groupStats = calculateGroupStats(groupKeys);
                    
                    html += `
                        <div class="group-section">
                            <div class="group-header">
                                <h3>Group: ${groupName}</h3>
                                <div class="group-stats">
                                    <span class="stat-item">Total: ${groupStats.total}</span>
                                    <span class="stat-item active">Active: ${groupStats.active}</span>
                                    <span class="stat-item limited">Limited: ${groupStats.limited}</span>
                                    <span class="stat-item invalid">Invalid: ${groupStats.invalid}</span>
                                </div>
                            </div>
                            <div class="key-group">
                    `;
                    
                    groupKeys.forEach(key => {
                        const statusClassMap = {
                            'available': 'status-active',
                            'limited': 'status-limited',
                            'unavailable': 'status-limited',
                            'invalid': 'status-quarantined'
                        };
                        const statusClass = statusClassMap[key.status] || 'status-quarantined';
                        const isResettable = key.status !== 'available';
                        const hasModelBlocks = key.model_blocks && key.model_blocks.length > 0;

                        html += `
                            <div class="key-item ${key.status}" id="key-item-${key.id}">
                                <div class="key-info">
                                    <div class="key-preview">${key.key_preview}</div>
                                    <small class="key-id">ID: ${key.id}</small>
                                    ${hasModelBlocks ? `
                                        <div class="model-blocks">
                                            ${key.model_blocks.map(block => `
                                                <span class="model-block" title="Blocked until ${new Date(block.blocked_until).toLocaleString()}">
                                                    ${block.model}: ${formatTimeUntil(new Date(block.blocked_until))}
                                                </span>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                                <div class="key-status ${statusClass}" title="${key.status}">${key.status}</div>
                                <div class="key-controls">
                                    <button class="key-btn verify-btn" onclick="verifyKey('${key.id}', this)" title="Verify key status">
                                        Verify
                                    </button>
                                    <button class="key-btn reset-btn" onclick="resetKey('${key.id}', this)" 
                                            ${!isResettable ? 'disabled' : ''} 
                                            title="${isResettable ? 'Reset key status' : 'Key is already available'}">
                                        Reset
                                    </button>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                container.innerHTML = html;
                
            } catch (error) {
                container.innerHTML = `<div class="error">Failed to load keys: ${error.message}</div>`;
            }
        }

        function calculateGroupStats(keys) {
            return keys.reduce((stats, key) => {
                stats.total++;
                switch (key.status) {
                    case 'available':
                        stats.active++;
                        break;
                    case 'limited':
                    case 'unavailable':
                        stats.limited++;
                        break;
                    case 'invalid':
                        stats.invalid++;
                        break;
                }
                return stats;
            }, { total: 0, active: 0, limited: 0, invalid: 0 });
        }
        
        async function getCsrfTokenAndInit() {
            try {
                const tokenResponse = await fetch('/admin/csrf-token');
                if (!tokenResponse.ok) {
                    throw new Error('Could not fetch CSRF token');
                }
                const tokenData = await tokenResponse.json();
                csrfToken = tokenData.csrf_token;
                
                // Now that we have the token, proceed with loading data
                await refreshData();
            } catch (error) {
                 console.error('Initialization failed:', error);
                 document.querySelectorAll('.loading').forEach(el => {
                    el.innerHTML = `<div class="error">Initialization failed: ${error.message}</div>`;
                });
            }
        }

        async function refreshData() {
            const loadingElements = document.querySelectorAll('.loading');
            
            try {
                // Load health data first
                const healthData = await fetchData('/admin/health');
                renderSystemStatus(healthData);
                renderRequestMetrics(healthData);
                
                // Load other data in parallel for better performance
                const [modelStatsResult, keysStatusResult] = await Promise.allSettled([
                    renderModelStats(),
                    renderKeysStatus()
                ]);
                
                // Handle individual failures gracefully
                if (modelStatsResult.status === 'rejected') {
                    console.error('Failed to load model stats:', modelStatsResult.reason);
                    const container = document.getElementById('model-stats');
                    if (container) {
                        container.innerHTML = `<div class="error">Failed to load model stats: ${modelStatsResult.reason.message}</div>`;
                    }
                }
                
                if (keysStatusResult.status === 'rejected') {
                    console.error('Failed to load keys status:', keysStatusResult.reason);
                    const container = document.getElementById('keys-status');
                    if (container) {
                        container.innerHTML = `<div class="error">Failed to load keys: ${keysStatusResult.reason.message}</div>`;
                    }
                }
                
            } catch (error) {
                console.error('Failed to refresh core data:', error);
                loadingElements.forEach(el => {
                    if (el.innerHTML.includes('Loading...')) {
                        el.innerHTML = `<div class="error">Failed to load data: ${error.message}</div>`;
                    }
                });
            }
        }
        
        // Auto-refresh management
        let isAutoRefreshEnabled = true;
        let lastRefreshTime = null;
        
        function updateRefreshStatus() {
            const refreshBtn = document.querySelector('.refresh-btn');
            if (refreshBtn && lastRefreshTime) {
                const timeSince = Math.floor((Date.now() - lastRefreshTime) / 1000);
                refreshBtn.title = `Last updated ${timeSince}s ago. Auto-refresh: ${isAutoRefreshEnabled ? 'ON' : 'OFF'}`;
            }
        }
        
        function toggleAutoRefresh() {
            isAutoRefreshEnabled = !isAutoRefreshEnabled;
            const refreshBtn = document.querySelector('.refresh-btn');
            if (refreshBtn) {
                refreshBtn.textContent = isAutoRefreshEnabled ? 'Auto-Refresh: ON' : 'Auto-Refresh: OFF';
                refreshBtn.classList.toggle('auto-refresh-disabled', !isAutoRefreshEnabled);
            }
            
            if (isAutoRefreshEnabled && !refreshInterval) {
                refreshInterval = setInterval(() => {
                    if (isAutoRefreshEnabled) {
                        refreshData().then(() => {
                            lastRefreshTime = Date.now();
                            updateRefreshStatus();
                        });
                    }
                }, 30000);
            } else if (!isAutoRefreshEnabled && refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }
        
        // Enhanced refresh function
        async function manualRefresh() {
            const refreshBtn = document.querySelector('.refresh-btn');
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.textContent = 'Refreshing...';
            }
            
            try {
                await refreshData();
                lastRefreshTime = Date.now();
                showNotification('Dashboard refreshed successfully', 'success');
            } catch (error) {
                showNotification('Failed to refresh dashboard', 'error');
            } finally {
                if (refreshBtn) {
                    refreshBtn.disabled = false;
                    refreshBtn.textContent = isAutoRefreshEnabled ? 'Auto-Refresh: ON' : 'Auto-Refresh: OFF';
                }
                updateRefreshStatus();
            }
        }
        
        // Initial load
        getCsrfTokenAndInit().then(() => {
            lastRefreshTime = Date.now();
            updateRefreshStatus();
        });
        
        // Auto-refresh every 30 seconds
        refreshInterval = setInterval(() => {
            if (isAutoRefreshEnabled) {
                refreshData().then(() => {
                    lastRefreshTime = Date.now();
                    updateRefreshStatus();
                });
            }
        }, 30000);
        
        // Update refresh status every 5 seconds
        setInterval(updateRefreshStatus, 5000);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });
        
        // Handle visibility change to pause/resume auto-refresh
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                    refreshInterval = null;
                }
            } else if (isAutoRefreshEnabled && !refreshInterval) {
                refreshInterval = setInterval(() => {
                    if (isAutoRefreshEnabled) {
                        refreshData().then(() => {
                            lastRefreshTime = Date.now();
                            updateRefreshStatus();
                        });
                    }
                }, 30000);
                // Refresh immediately when page becomes visible
                refreshData().then(() => {
                    lastRefreshTime = Date.now();
                    updateRefreshStatus();
                });
            }
        });
    </script>
</body>
</html>